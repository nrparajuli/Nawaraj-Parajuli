"use strict";
var __awaiter = (this && this.__awaiter) || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function(thisArg, body) {
    var _ = {
            label: 0,
            sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
            },
            trys: [],
            ops: []
        },
        f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;

    function verb(n) {
        return function(v) {
            return step([n, v]);
        };
    }

    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [6, e];
            y = 0;
        } finally {
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProtoframePubsub = exports.ProtoframePublisher = exports.ProtoframeSubscriber = void 0;
var util_1 = require("./util");

function mkPayloadType(protocol, action, type) {
    return protocol.type + "#" + action + "#" + type;
}

function mkPayloadBody(protocol, action, type, id, body) {
    return {
        body: body,
        id: id,
        type: mkPayloadType(protocol, action, type),
    };
}

function mkPayloadResponse(protocol, type, id, response) {
    return {
        id: id,
        response: response,
        type: mkPayloadType(protocol, 'ask', type),
    };
}

function isPayloadBodyOfType(protocol, action, type, payload) {
    if (util_1.hasValue(payload)) {
        var payloadType = payload.type;
        if (util_1.hasValue(payloadType) && util_1.hasValue(payload.body)) {
            var _a = payloadType.split('#'),
                p = _a[0],
                a = _a[1],
                t = _a[2];
            return p === protocol.type && a === action && t === type;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function isPayloadResponseOfType(protocol, type, payload) {
    if (util_1.hasValue(payload)) {
        var payloadType = payload.type;
        if (util_1.hasValue(payloadType) && util_1.hasValue(payload.response)) {
            var _a = payloadType.split('#'),
                p = _a[0],
                a = _a[1],
                t = _a[2];
            return p === protocol.type && a === 'ask' && t === type;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

function destroyAll(listeners) {
    listeners.forEach(function(_a) {
        var w = _a[0],
            l = _a[1];
        return w.removeEventListener('message', l);
    });
    listeners.length = 0;
}

function awaitResponse(thisWindow, protocol, type, id) {
    return new Promise(function(accept) {
        var handle = function(ev) {
            var payload = ev.data;
            if (isPayloadResponseOfType(protocol, type, payload) &&
                payload.id === id) {
                thisWindow.removeEventListener('message', handle);
                accept(payload.response);
            }
        };
        thisWindow.addEventListener('message', handle);
    });
}

function handleTell0(thisWindow, protocol, type, handler) {
    var listener = function(ev) {
        var payload = ev.data;
        if (isPayloadBodyOfType(protocol, 'tell', type, payload)) {
            handler(payload.body);
        }
    };
    thisWindow.addEventListener('message', listener);
    return [thisWindow, listener];
}

function handleAsk0(thisWindow, targetWindow, protocol, type, targetOrigin, handler) {
    var _this = this;
    var listener = function(ev) {
        return __awaiter(_this, void 0, void 0, function() {
            var payload, response;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        payload = ev.data;
                        if (!isPayloadBodyOfType(protocol, 'ask', type, payload)) return [3 /*break*/ , 2];
                        return [4 /*yield*/ , handler(payload.body)];
                    case 1:
                        response = _a.sent();
                        targetWindow.postMessage(mkPayloadResponse(protocol, type, payload.id, response), targetOrigin);
                        _a.label = 2;
                    case 2:
                        return [2 /*return*/ ];
                }
            });
        });
    };
    thisWindow.addEventListener('message', listener);
    return [thisWindow, listener];
}

function tell0(targetWindow, protocol, type, body, targetOrigin) {
    var id = Math.random().toString();
    return targetWindow.postMessage(mkPayloadBody(protocol, 'tell', type, id, body), targetOrigin);
}

function ask0(thisWindow, targetWindow, protocol, type, body, targetOrigin, timeout) {
    return __awaiter(this, void 0, void 0, function() {
        var id, run;
        var _this = this;
        return __generator(this, function(_a) {
            id = Math.random().toString();
            run = new Promise(function(accept, reject) {
                return __awaiter(_this, void 0, void 0, function() {
                    var timeoutHandler, response;
                    return __generator(this, function(_a) {
                        switch (_a.label) {
                            case 0:
                                timeoutHandler = setTimeout(function() {
                                    return reject(new Error("Failed to get response within " + timeout + "ms"));
                                }, timeout);
                                return [4 /*yield*/ , awaitResponse(thisWindow, protocol, type, id)];
                            case 1:
                                response = _a.sent();
                                clearTimeout(timeoutHandler);
                                accept(response);
                                return [2 /*return*/ ];
                        }
                    });
                });
            });
            targetWindow.postMessage(mkPayloadBody(protocol, 'ask', type, id, body), targetOrigin);
            return [2 /*return*/ , run];
        });
    });
}
var ProtoframeSubscriber = /** @class */ (function() {
    function ProtoframeSubscriber(protocol, thisWindow) {
        if (thisWindow === void 0) {
            thisWindow = window;
        }
        this.protocol = protocol;
        this.thisWindow = thisWindow;
        this.listeners = [];
    }
    ProtoframeSubscriber.prototype.handleTell = function(type, handler) {
        this.listeners.push(handleTell0(this.thisWindow, this.protocol, type, handler));
    };
    ProtoframeSubscriber.prototype.destroy = function() {
        destroyAll(this.listeners);
    };
    return ProtoframeSubscriber;
}());
exports.ProtoframeSubscriber = ProtoframeSubscriber;
var ProtoframePublisher = /** @class */ (function() {
    function ProtoframePublisher(protocol, targetWindow, targetOrigin) {
        if (targetOrigin === void 0) {
            targetOrigin = '*';
        }
        this.protocol = protocol;
        this.targetWindow = targetWindow;
        this.targetOrigin = targetOrigin;
        this.listeners = [];
    }
    /**
     * We are a "parent" page that is embedding an iframe, and we wish to connect
     * to that iframe in order to publish messages.
     *
     * @param protocol The protocol this connector will communicate with
     * @param iframe The target iframe HTML element we are connecting to
     * @param targetOrigin The target scheme and host we expect the receiver to be
     */
    ProtoframePublisher.parent = function(protocol, iframe, targetOrigin) {
        var targetWindow = iframe.contentWindow;
        if (util_1.hasValue(targetWindow)) {
            return new ProtoframePublisher(protocol, targetWindow, targetOrigin);
        } else {
            throw new Error('iframe.contentWindow was null');
        }
    };
    /**
     * We are an "iframe" page that will be embedded, and we wish to connect to a
     * parent page in order to publish messages.
     *
     * @param protocol The protocol this connector will communicate with
     * @param targetOrigin The target scheme and host we expect the receiver to be
     * @param targetWindow The window of the parent frame. This should normally be
     *  the `window.parent`
     */
    ProtoframePublisher.iframe = function(protocol, targetOrigin, targetWindow) {
        if (targetWindow === void 0) {
            targetWindow = window.parent;
        }
        return new ProtoframePublisher(protocol, targetWindow, targetOrigin);
    };
    ProtoframePublisher.prototype.tell = function(type, body) {
        tell0(this.targetWindow, this.protocol, type, body, this.targetOrigin);
    };
    ProtoframePublisher.prototype.destroy = function() {
        destroyAll(this.listeners);
    };
    return ProtoframePublisher;
}());
exports.ProtoframePublisher = ProtoframePublisher;
var ProtoframePubsub = /** @class */ (function() {
    function ProtoframePubsub(protocol, targetWindow, thisWindow, targetOrigin) {
        if (thisWindow === void 0) {
            thisWindow = window;
        }
        if (targetOrigin === void 0) {
            targetOrigin = '*';
        }
        this.protocol = protocol;
        this.targetWindow = targetWindow;
        this.thisWindow = thisWindow;
        this.targetOrigin = targetOrigin;
        this.systemProtocol = {
            type: "system|" + this.protocol.type,
        };
        this.listeners = [];
        // Answer internally to ping requests
        handleAsk0(thisWindow, targetWindow, this.systemProtocol, 'ping', targetOrigin, function() {
            return Promise.resolve({});
        });
    }
    /**
     * Connect to the target configured in the supplied pubsub connector by
     * sending ping requests over and over until we get a response.
     *
     * @param pubsub The pubsub connector to wait until is "connected" to its
     *  target
     * @param retries How many times to retry and ping the target. By default,
     *  this will retry 50 times (thus waiting 25 seconds total)
     * @param timeout How long to wait for a response from the target before
     *  retrying. By default the timeout is 500ms (thus waiting 25 seconds total)
     */
    ProtoframePubsub.connect = function(pubsub, retries, timeout) {
        if (retries === void 0) {
            retries = 50;
        }
        if (timeout === void 0) {
            timeout = 500;
        }
        return __awaiter(this, void 0, void 0, function() {
            var i, _1;
            return __generator(this, function(_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i <= retries)) return [3 /*break*/ , 6];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/ , pubsub.ping({
                            timeout: timeout
                        })];
                    case 3:
                        _a.sent();
                        return [2 /*return*/ , pubsub];
                    case 4:
                        _1 = _a.sent();
                        return [3 /*break*/ , 5];
                    case 5:
                        i++;
                        return [3 /*break*/ , 1];
                    case 6:
                        throw new Error("Could not connect on protocol " + pubsub.protocol.type + " after " + retries * timeout + "ms");
                }
            });
        });
    };
    /**
     * We are a "parent" page that is embedding an iframe, and we wish to connect
     * to that iframe for communication.
     *
     * @param protocol The protocol this connector will communicate with
     * @param iframe The target iframe HTML element we are connecting to
     * @param targetOrigin The target scheme and host we expect the receiver to be
     * @param thisWindow The parent window (our window). This should normally be
     *  the current `window`
     */
    ProtoframePubsub.parent = function(protocol, iframe, targetOrigin, thisWindow) {
        if (targetOrigin === void 0) {
            targetOrigin = '*';
        }
        if (thisWindow === void 0) {
            thisWindow = window;
        }
        var targetWindow = iframe.contentWindow;
        if (util_1.hasValue(targetWindow)) {
            return new ProtoframePubsub(protocol, targetWindow, thisWindow, targetOrigin);
        } else {
            throw new Error('iframe.contentWindow was null');
        }
    };
    /**
     * We are an "iframe" page that will be embedded, and we wish to connect to a
     * parent page for communication.
     *
     * @param protocol The protocol this connector will communicate with
     * @param targetOrigin The target scheme and host we expect the receiver to be
     * @param thisWindow The window of the current iframe. This should normally be
     *  the current `window`
     * @param targetWindow The window of the parent frame. This should normally be
     *  the `window.parent`
     */
    ProtoframePubsub.iframe = function(protocol, targetOrigin, _a) {
        if (targetOrigin === void 0) {
            targetOrigin = '*';
        }
        var _b = _a === void 0 ? {} : _a,
            _c = _b.thisWindow,
            thisWindow = _c === void 0 ? window : _c,
            _d = _b.targetWindow,
            targetWindow = _d === void 0 ? window.parent : _d;
        return new ProtoframePubsub(protocol, targetWindow, thisWindow, targetOrigin);
    };
    /**
     * Send a 'ping' request to check if there is a listener open at the target
     * window. If this times out, then it means no listener was available *at the
     * time the ping request was sent*. Since requests are not buffered, then this
     * should be retried if we're waiting for some target iframe to start up and
     * load its assets. See `ProtoframePubsub.connect` as an implementation of
     * this functionality.
     *
     * @param timeout How long to wait for the reply before resulting in an error
     */
    ProtoframePubsub.prototype.ping = function(_a) {
        var _b = _a.timeout,
            timeout = _b === void 0 ? 10000 : _b;
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_c) {
                switch (_c.label) {
                    case 0:
                        return [4 /*yield*/ , ask0(this.thisWindow, this.targetWindow, this.systemProtocol, 'ping', {}, this.targetOrigin, timeout)];
                    case 1:
                        _c.sent();
                        return [2 /*return*/ ];
                }
            });
        });
    };
    ProtoframePubsub.prototype.handleTell = function(type, handler) {
        this.listeners.push(handleTell0(this.thisWindow, this.protocol, type, handler));
    };
    ProtoframePubsub.prototype.tell = function(type, body) {
        tell0(this.targetWindow, this.protocol, type, body, this.targetOrigin);
    };
    ProtoframePubsub.prototype.handleAsk = function(type, handler) {
        this.listeners.push(handleAsk0(this.thisWindow, this.targetWindow, this.protocol, type, this.targetOrigin, handler));
    };
    ProtoframePubsub.prototype.ask = function(type, body, timeout) {
        if (timeout === void 0) {
            timeout = 10000;
        }
        return ask0(this.thisWindow, this.targetWindow, this.protocol, type, body, this.targetOrigin, timeout);
    };
    ProtoframePubsub.prototype.destroy = function() {
        destroyAll(this.listeners);
    };
    return ProtoframePubsub;
}());
exports.ProtoframePubsub = ProtoframePubsub;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Nvbm5lY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVQSwrQkFBa0M7QUFTbEMsU0FBUyxhQUFhLENBSXBCLFFBQWlDLEVBQ2pDLE1BQXdCLEVBQ3hCLElBQU87SUFFUCxPQUFVLFFBQVEsQ0FBQyxJQUFJLFNBQUksTUFBTSxTQUFJLElBQU0sQ0FBQztBQUM5QyxDQUFDO0FBRUQsU0FBUyxhQUFhLENBSXBCLFFBQWlDLEVBQ2pDLE1BQXdCLEVBQ3hCLElBQU8sRUFDUCxFQUFVLEVBQ1YsSUFBaUM7SUFFakMsT0FBTztRQUNMLElBQUksTUFBQTtRQUNKLEVBQUUsSUFBQTtRQUNGLElBQUksRUFBRSxhQUFhLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUM7S0FDNUMsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLGlCQUFpQixDQUl4QixRQUFpQyxFQUNqQyxJQUFPLEVBQ1AsRUFBVSxFQUNWLFFBQXlDO0lBRXpDLE9BQU87UUFDTCxFQUFFLElBQUE7UUFDRixRQUFRLFVBQUE7UUFDUixJQUFJLEVBQUUsYUFBYSxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDO0tBQzNDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FJMUIsUUFBaUMsRUFDakMsTUFBd0IsRUFDeEIsSUFBTyxFQUNQLE9BQXNEO0lBRXRELElBQUksZUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3JCLElBQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDakMsSUFBSSxlQUFRLENBQUMsV0FBVyxDQUFDLElBQUksZUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM3QyxJQUFBLEtBQVksV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBakMs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