(self.webpackJsonp__wix_chat_widget = self.webpackJsonp__wix_chat_widget || []).push([
    [8876], {
        20179: function(e, t, n) {
            "use strict";
            var r = n(6789),
                i = n(92712),
                o = n(51656),
                s = n(36022),
                a = n(35129);

            function c(e) {
                if (e && e.__esModule) return e;
                var t = Object.create(null);
                return e && Object.keys(e).forEach((function(n) {
                    if ("default" !== n) {
                        var r = Object.getOwnPropertyDescriptor(e, n);
                        Object.defineProperty(t, n, r.get ? r : {
                            enumerable: !0,
                            get: function() {
                                return e[n]
                            }
                        })
                    }
                })), t.default = e, Object.freeze(t)
            }
            var u, l = c(s),
                d = function() {
                    function e(e, t) {
                        var n = this;
                        this._delegate = e, this.firebase = t, s._addComponent(e, new o.Component("app-compat", (function() {
                            return n
                        }), "PUBLIC")), this.container = e.container
                    }
                    return Object.defineProperty(e.prototype, "automaticDataCollectionEnabled", {
                        get: function() {
                            return this._delegate.automaticDataCollectionEnabled
                        },
                        set: function(e) {
                            this._delegate.automaticDataCollectionEnabled = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "name", {
                        get: function() {
                            return this._delegate.name
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "options", {
                        get: function() {
                            return this._delegate.options
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.delete = function() {
                        var e = this;
                        return new Promise((function(t) {
                            e._delegate.checkDestroyed(), t()
                        })).then((function() {
                            return e.firebase.INTERNAL.removeApp(e.name), s.deleteApp(e._delegate)
                        }))
                    }, e.prototype._getService = function(e, t) {
                        var n;
                        void 0 === t && (t = s._DEFAULT_ENTRY_NAME), this._delegate.checkDestroyed();
                        var r = this._delegate.container.getProvider(e);
                        return r.isInitialized() || "EXPLICIT" !== (null === (n = r.getComponent()) || void 0 === n ? void 0 : n.instantiationMode) || r.initialize(), r.getImmediate({
                            identifier: t
                        })
                    }, e.prototype._removeServiceInstance = function(e, t) {
                        void 0 === t && (t = s._DEFAULT_ENTRY_NAME), this._delegate.container.getProvider(e).clearInstance(t)
                    }, e.prototype._addComponent = function(e) {
                        s._addComponent(this._delegate, e)
                    }, e.prototype._addOrOverwriteComponent = function(e) {
                        s._addOrOverwriteComponent(this._delegate, e)
                    }, e.prototype.toJSON = function() {
                        return {
                            name: this.name,
                            automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
                            options: this.options
                        }
                    }, e
                }(),
                h = ((u = {})["no-app"] = "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", u["invalid-app-argument"] = "firebase.{$appName}() takes either no argument or a Firebase App instance.", u),
                p = new r.ErrorFactory("app-compat", "Firebase", h);
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var f =
                /**
                 * @license
                 * Copyright 2019 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                function e() {
                    var t =
                        /**
                         * @license
                         * Copyright 2019 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function(e) {
                            var t = {},
                                n = {
                                    __esModule: !0,
                                    initializeApp: function(i, o) {
                                        void 0 === o && (o = {});
                                        var s = l.initializeApp(i, o);
                                        if (r.contains(t, s.name)) return t[s.name];
                                        var a = new e(s, n);
                                        return t[s.name] = a, a
                                    },
                                    app: i,
                                    registerVersion: l.registerVersion,
                                    setLogLevel: l.setLogLevel,
                                    onLog: l.onLog,
                                    apps: null,
                                    SDK_VERSION: l.SDK_VERSION,
                                    INTERNAL: {
                                        registerComponent: function(t) {
                                            var o = t.name,
                                                s = o.replace("-compat", "");
                                            if (l._registerComponent(t) && "PUBLIC" === t.type) {
                                                var a = function(e) {
                                                    if (void 0 === e && (e = i()), "function" != typeof e[s]) throw p.create("invalid-app-argument", {
                                                        appName: o
                                                    });
                                                    return e[s]()
                                                };
                                                void 0 !== t.serviceProps && r.deepExtend(a, t.serviceProps), n[s] = a, e.prototype[s] = function() {
                                                    for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                                                    return this._getService.bind(this, o).apply(this, t.multipleInstances ? e : [])
                                                }
                                            }
                                            return "PUBLIC" === t.type ? n[s] : null
                                        },
                                        removeApp: function(e) {
                                            delete t[e]
                                        },
                                        useAsService: function(e, t) {
                                            return "serverAuth" === t ? null : t
                                        },
                                        modularAPIs: l
                                    }
                                };

                            function i(e) {
                                if (e = e || l._DEFAULT_ENTRY_NAME, !r.contains(t, e)) throw p.create("no-app", {
                                    appName: e
                                });
                                return t[e]
                            }
                            return n.default = n, Object.defineProperty(n, "apps", {
                                get: function() {
                                    return Object.keys(t).map((function(e) {
                                        return t[e]
                                    }))
                                }
                            }), i.App = e, n
                        }(d);
                    return t.INTERNAL = i.__assign(i.__assign({}, t.INTERNAL), {
                        createFirebaseNamespace: e,
                        extendNamespace: function(e) {
                            r.deepExtend(t, e)
                        },
                        createSubscribe: r.createSubscribe,
                        ErrorFactory: r.ErrorFactory,
                        deepExtend: r.deepExtend
                    }), t
                }(),
                m = new a.Logger("@firebase/app-compat");
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            if (r.isBrowser() && void 0 !== self.firebase) {
                m.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  ");
                var g = self.firebase.SDK_VERSION;
                g && g.indexOf("LITE") >= 0 && m.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ")
            }
            var _, v = f;
            s.registerVersion("@firebase/app-compat", "0.2.13", _), e.exports = v
        },
        36022: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            var r = n(51656),
                i = n(92712),
                o = n(35129),
                s = n(6789),
                a = n(50799),
                c = function() {
                    function e(e) {
                        this.container = e
                    }
                    return e.prototype.getPlatformInfoString = function() {
                        return this.container.getProviders().map((function(e) {
                            if (function(e) {
                                    var t = e.getComponent();
                                    return "VERSION" === (null == t ? void 0 : t.type)
                                }(e)) {
                                var t = e.getImmediate();
                                return "".concat(t.library, "/").concat(t.version)
                            }
                            return null
                        })).filter((function(e) {
                            return e
                        })).join(" ")
                    }, e
                }();
            var u, l, d = "@firebase/app",
                h = "0.9.13",
                p = new o.Logger("@firebase/app"),
                f = "[DEFAULT]",
                m = ((u = {})[d] = "fire-core", u["@firebase/app-compat"] = "fire-core-compat", u["@firebase/analytics"] = "fire-analytics", u["@firebase/analytics-compat"] = "fire-analytics-compat", u["@firebase/app-check"] = "fire-app-check", u["@firebase/app-check-compat"] = "fire-app-check-compat", u["@firebase/auth"] = "fire-auth", u["@firebase/auth-compat"] = "fire-auth-compat", u["@firebase/database"] = "fire-rtdb", u["@firebase/database-compat"] = "fire-rtdb-compat", u["@firebase/functions"] = "fire-fn", u["@firebase/functions-compat"] = "fire-fn-compat", u["@firebase/installations"] = "fire-iid", u["@firebase/installations-compat"] = "fire-iid-compat", u["@firebase/messaging"] = "fire-fcm", u["@firebase/messaging-compat"] = "fire-fcm-compat", u["@firebase/performance"] = "fire-perf", u["@firebase/performance-compat"] = "fire-perf-compat", u["@firebase/remote-config"] = "fire-rc", u["@firebase/remote-config-compat"] = "fire-rc-compat", u["@firebase/storage"] = "fire-gcs", u["@firebase/storage-compat"] = "fire-gcs-compat", u["@firebase/firestore"] = "fire-fst", u["@firebase/firestore-compat"] = "fire-fst-compat", u["fire-js"] = "fire-js", u.firebase = "fire-js-all", u),
                g = new Map,
                _ = new Map;

            function v(e, t) {
                try {
                    e.container.addComponent(t)
                } catch (n) {
                    p.debug("Component ".concat(t.name, " failed to register with FirebaseApp ").concat(e.name), n)
                }
            }

            function y(e) {
                var t, n, r = e.name;
                if (_.has(r)) return p.debug("There were multiple attempts to register component ".concat(r, ".")), !1;
                _.set(r, e);
                try {
                    for (var o = i.__values(g.values()), s = o.next(); !s.done; s = o.next()) {
                        v(s.value, e)
                    }
                } catch (e) {
                    t = {
                        error: e
                    }
                } finally {
                    try {
                        s && !s.done && (n = o.return) && n.call(o)
                    } finally {
                        if (t) throw t.error
                    }
                }
                return !0
            }

            function b(e, t) {
                var n = e.container.getProvider("heartbeat").getImmediate({
                    optional: !0
                });
                return n && n.triggerHeartbeat(), e.container.getProvider(t)
            }
            var I = ((l = {})["no-app"] = "No Firebase App '{$appName}' has been created - call initializeApp() first", l["bad-app-name"] = "Illegal App name: '{$appName}", l["duplicate-app"] = "Firebase App named '{$appName}' already exists with different options or config", l["app-deleted"] = "Firebase App named '{$appName}' already deleted", l["no-options"] = "Need to provide options, when not being deployed to hosting via source.", l["invalid-app-argument"] = "firebase.{$appName}() takes either no argument or a Firebase App instance.", l["invalid-log-argument"] = "First argument to `onLog` must be null or a function.", l["idb-open"] = "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", l["idb-get"] = "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", l["idb-set"] = "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", l["idb-delete"] = "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.", l),
                E = new s.ErrorFactory("app", "Firebase", I),
                S = function() {
                    function e(e, t, n) {
                        var o = this;
                        this._isDeleted = !1, this._options = i.__assign({}, e), this._config = i.__assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new r.Component("app", (function() {
                            return o
                        }), "PUBLIC"))
                    }
                    return Object.defineProperty(e.prototype, "automaticDataCollectionEnabled", {
                        get: function() {
                            return this.checkDestroyed(), this._automaticDataCollectionEnabled
                        },
                        set: function(e) {
                            this.checkDestroyed(), this._automaticDataCollectionEnabled = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "name", {
                        get: function() {
                            return this.checkDestroyed(), this._name
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "options", {
                        get: function() {
                            return this.checkDestroyed(), this._options
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "config", {
                        get: function() {
                            return this.checkDestroyed(), this._config
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "container", {
                        get: function() {
                            return this._container
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isDeleted", {
                        get: function() {
                            return this._isDeleted
                        },
                        set: function(e) {
                            this._isDeleted = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.checkDestroyed = function() {
                        if (this.isDeleted) throw E.create("app-deleted", {
                            appName: this._name
                        })
                    }, e
                }();

            function w(e, t) {
                var n, o;
                void 0 === t && (t = {});
                var a = e;
                "object" != typeof t && (t = {
                    name: t
                });
                var c = i.__assign({
                        name: f,
                        automaticDataCollectionEnabled: !1
                    }, t),
                    u = c.name;
                if ("string" != typeof u || !u) throw E.create("bad-app-name", {
                    appName: String(u)
                });
                if (a || (a = s.getDefaultAppConfig()), !a) throw E.create("no-options");
                var l = g.get(u);
                if (l) {
                    if (s.deepEqual(a, l.options) && s.deepEqual(c, l.config)) return l;
                    throw E.create("duplicate-app", {
                        appName: u
                    })
                }
                var d = new r.ComponentContainer(u);
                try {
                    for (var h = i.__values(_.values()), p = h.next(); !p.done; p = h.next()) {
                        var m = p.value;
                        d.addComponent(m)
                    }
                } catch (e) {
                    n = {
                        error: e
                    }
                } finally {
                    try {
                        p && !p.done && (o = h.return) && o.call(h)
                    } finally {
                        if (n) throw n.error
                    }
                }
                var v = new S(a, c, d);
                return g.set(u, v), v
            }

            function C(e, t, n) {
                var i, o = null !== (i = m[e]) && void 0 !== i ? i : e;
                n && (o += "-".concat(n));
                var s = o.match(/\s|\//),
                    a = t.match(/\s|\//);
                if (s || a) {
                    var c = ['Unable to register library "'.concat(o, '" with version "').concat(t, '":')];
                    return s && c.push('library name "'.concat(o, '" contains illegal characters (whitespace or "/")')), s && a && c.push("and"), a && c.push('version name "'.concat(t, '" contains illegal characters (whitespace or "/")')), void p.warn(c.join(" "))
                }
                y(new r.Component("".concat(o, "-version"), (function() {
                    return {
                        library: o,
                        version: t
                    }
                }), "VERSION"))
            }
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var T = "firebase-heartbeat-database",
                A = 1,
                R = "firebase-heartbeat-store",
                P = null;

            function O() {
                return P || (P = a.openDB(T, A, {
                    upgrade: function(e, t) {
                        if (0 === t) e.createObjectStore(R)
                    }
                }).catch((function(e) {
                    throw E.create("idb-open", {
                        originalErrorMessage: e.message
                    })
                }))), P
            }

            function k(e) {
                return i.__awaiter(this, void 0, void 0, (function() {
                    var t, n;
                    return i.__generator(this, (function(r) {
                        switch (r.label) {
                            case 0:
                                return r.trys.push([0, 3, , 4]), [4, O()];
                            case 1:
                                return [4, r.sent().transaction(R).objectStore(R).get(D(e))];
                            case 2:
                                return [2, r.sent()];
                            case 3:
                                return (t = r.sent()) instanceof s.FirebaseError ? p.warn(t.message) : (n = E.create("idb-get", {
                                    originalErrorMessage: null == t ? void 0 : t.message
                                }), p.warn(n.message)), [3, 4];
                            case 4:
                                return [2]
                        }
                    }))
                }))
            }

            function N(e, t) {
                return i.__awaiter(this, void 0, void 0, (function() {
                    var n, r, o, a;
                    return i.__generator(this, (function(i) {
                        switch (i.label) {
                            case 0:
                                return i.trys.push([0, 4, , 5]), [4, O()];
                            case 1:
                                return n = i.sent(), r = n.transaction(R, "readwrite"), [4, r.objectStore(R).put(t, D(e))];
                            case 2:
                                return i.sent(), [4, r.done];
                            case 3:
                                return i.sent(), [3, 5];
                            case 4:
                                return (o = i.sent()) instanceof s.FirebaseError ? p.warn(o.message) : (a = E.create("idb-set", {
                                    originalErrorMessage: null == o ? void 0 : o.message
                                }), p.warn(a.message)), [3, 5];
                            case 5:
                                return [2]
                        }
                    }))
                }))
            }

            function D(e) {
                return "".concat(e.name, "!").concat(e.options.appId)
            }
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var M = function() {
                function e(e) {
                    var t = this;
                    this.container = e, this._heartbeatsCache = null;
                    var n = this.container.getProvider("app").getImmediate();
                    this._storage = new U(n), this._heartbeatsCachePromise = this._storage.read().then((function(e) {
                        return t._heartbeatsCache = e, e
                    }))
                }
                return e.prototype.triggerHeartbeat = function() {
                    return i.__awaiter(this, void 0, void 0, (function() {
                        var e, t, n, r;
                        return i.__generator(this, (function(i) {
                            switch (i.label) {
                                case 0:
                                    return e = this.container.getProvider("platform-logger").getImmediate(), t = e.getPlatformInfoString(), n = x(), null !== this._heartbeatsCache ? [3, 2] : (r = this, [4, this._heartbeatsCachePromise]);
                                case 1:
                                    r._heartbeatsCache = i.sent(), i.label = 2;
                                case 2:
                                    return this._heartbeatsCache.lastSentHeartbeatDate === n || this._heartbeatsCache.heartbeats.some((function(e) {
                                        return e.date === n
                                    })) ? [2] : (this._heartbeatsCache.heartbeats.push({
                                        date: n,
                                        agent: t
                                    }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((function(e) {
                                        var t = new Date(e.date).valueOf();
                                        return Date.now() - t <= 2592e6
                                    })), [2, this._storage.overwrite(this._heartbeatsCache)])
                            }
                        }))
                    }))
                }, e.prototype.getHeartbeatsHeader = function() {
                    return i.__awaiter(this, void 0, void 0, (function() {
                        var e, t, n, r, o;
                        return i.__generator(this, (function(a) {
                            switch (a.label) {
                                case 0:
                                    return null !== this._heartbeatsCache ? [3, 2] : [4, this._heartbeatsCachePromise];
                                case 1:
                                    a.sent(), a.label = 2;
                                case 2:
                                    return null === this._heartbeatsCache || 0 === this._heartbeatsCache.heartbeats.length ? [2, ""] : (e = x(), t = function(e, t) {
                                        var n, r;
                                        void 0 === t && (t = 1024);
                                        var o = [],
                                            s = e.slice(),
                                            a = function(e) {
                                                var n = o.find((function(t) {
                                                    return t.agent === e.agent
                                                }));
                                                if (n) {
                                                    if (n.dates.push(e.date), F(o) > t) return n.dates.pop(), "break"
                                                } else if (o.push({
                                                        agent: e.agent,
                                                        dates: [e.date]
                                                    }), F(o) > t) return o.pop(), "break";
                                                s = s.slice(1)
                                            };
                                        try {
                                            for (var c = i.__values(e), u = c.next(); !u.done; u = c.next()) {
                                                if ("break" === a(u.value)) break
                                            }
                                        } catch (e) {
                                            n = {
                                                error: e
                                            }
                                        } finally {
                                            try {
                                                u && !u.done && (r = c.return) && r.call(c)
                                            } finally {
                                                if (n) throw n.error
                                            }
                                        }
                                        return {
                                            heartbeatsToSend: o,
                                            unsentEntries: s
                                        }
                                    }(this._heartbeatsCache.heartbeats), n = t.heartbeatsToSend, r = t.unsentEntries, o = s.base64urlEncodeWithoutPadding(JSON.stringify({
                                        version: 2,
                                        heartbeats: n
                                    })), this._heartbeatsCache.lastSentHeartbeatDate = e, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, [4, this._storage.overwrite(this._heartbeatsCache)]) : [3, 4]);
                                case 3:
                                    return a.sent(), [3, 5];
                                case 4:
                                    this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache), a.label = 5;
                                case 5:
                                    return [2, o]
                            }
                        }))
                    }))
                }, e
            }();

            function x() {
                return (new Date).toISOString().substring(0, 10)
            }
            var L, U = function() {
                function e(e) {
                    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
                }
                return e.prototype.runIndexedDBEnvironmentCheck = function() {
                    return i.__awaiter(this, void 0, void 0, (function() {
                        return i.__generator(this, (function(e) {
                            return s.isIndexedDBAvailable() ? [2, s.validateIndexedDBOpenable().then((function() {
                                return !0
                            })).catch((function() {
                                return !1
                            }))] : [2, !1]
                        }))
                    }))
                }, e.prototype.read = function() {
                    return i.__awaiter(this, void 0, void 0, (function() {
                        return i.__generator(this, (function(e) {
                            switch (e.label) {
                                case 0:
                                    return [4, this._canUseIndexedDBPromise];
                                case 1:
                                    return e.sent() ? [3, 2] : [2, {
                                        heartbeats: []
                                    }];
                                case 2:
                                    return [4, k(this.app)];
                                case 3:
                                    return [2, e.sent() || {
                                        heartbeats: []
                                    }]
                            }
                        }))
                    }))
                }, e.prototype.overwrite = function(e) {
                    var t;
                    return i.__awaiter(this, void 0, void 0, (function() {
                        var n;
                        return i.__generator(this, (function(r) {
                            switch (r.label) {
                                case 0:
                                    return [4, this._canUseIndexedDBPromise];
                                case 1:
                                    return r.sent() ? [3, 2] : [2];
                                case 2:
                                    return [4, this.read()];
                                case 3:
                                    return n = r.sent(), [2, N(this.app, {
                                        lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate,
                                        heartbeats: e.heartbeats
                                    })]
                            }
                        }))
                    }))
                }, e.prototype.add = function(e) {
                    var t;
                    return i.__awaiter(this, void 0, void 0, (function() {
                        var n;
                        return i.__generator(this, (function(r) {
                            switch (r.label) {
                                case 0:
                                    return [4, this._canUseIndexedDBPromise];
                                case 1:
                                    return r.sent() ? [3, 2] : [2];
                                case 2:
                                    return [4, this.read()];
                                case 3:
                                    return n = r.sent(), [2, N(this.app, {
                                        lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate,
                                        heartbeats: i.__spreadArray(i.__spreadArray([], i.__read(n.heartbeats), !1), i.__read(e.heartbeats), !1)
                                    })]
                            }
                        }))
                    }))
                }, e
            }();

            function F(e) {
                return s.base64urlEncodeWithoutPadding(JSON.stringify({
                    version: 2,
                    heartbeats: e
                })).length
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            L = "node", y(new r.Component("platform-logger", (function(e) {
                    return new c(e)
                }), "PRIVATE")), y(new r.Component("heartbeat", (function(e) {
                    return new M(e)
                }), "PRIVATE")), C(d, h, L), C(d, h, "cjs5"), C("fire-js", ""), Object.defineProperty(t, "FirebaseError", {
                    enumerable: !0,
                    get: function() {
                        return s.FirebaseError
                    }
                }), t.SDK_VERSION = "9.23.0", t._DEFAULT_ENTRY_NAME = f, t._addComponent = v, t._addOrOverwriteComponent = function(e, t) {
                    e.container.addOrOverwriteComponent(t)
                }, t._apps = g, t._clearComponents = function() {
                    _.clear()
                }
                /**
                 * @license
                 * Copyright 2019 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                , t._components = _, t._getProvider = b, t._registerComponent = y, t._removeServiceInstance = function(e, t, n) {
                    void 0 === n && (n = f), b(e, t).clearInstance(n)
                }, t.deleteApp = function(e) {
                    return i.__awaiter(this, void 0, void 0, (function() {
                        var t;
                        return i.__generator(this, (function(n) {
                            switch (n.label) {
                                case 0:
                                    return t = e.name, g.has(t) ? (g.delete(t), [4, Promise.all(e.container.getProviders().map((function(e) {
                                        return e.delete()
                                    })))]) : [3, 2];
                                case 1:
                                    n.sent(), e.isDeleted = !0, n.label = 2;
                                case 2:
                                    return [2]
                            }
                        }))
                    }))
                }, t.getApp = function(e) {
                    void 0 === e && (e = f);
                    var t = g.get(e);
                    if (!t && e === f && s.getDefaultAppConfig()) return w();
                    if (!t) throw E.create("no-app", {
                        appName: e
                    });
                    return t
                }, t.getApps = function() {
                    return Array.from(g.values())
                }, t.initializeApp = w, t.onLog = function(e, t) {
                    if (null !== e && "function" != typeof e) throw E.create("invalid-log-argument");
                    o.setUserLogHandler(e, t)
                }, t.registerVersion = C, t.setLogLevel = function(e) {
                    o.setLogLevel(e)
                }
        },
        9454: function(e, t, n) {
            "use strict";
            var r = n(20179),
                i = n(13058),
                o = n(51656),
                s = n(6789);

            function a(e) {
                return e && "object" == typeof e && "default" in e ? e : {
                    default: e
                }
            }

            function c(e) {
                if (e && e.__esModule) return e;
                var t = Object.create(null);
                return e && Object.keys(e).forEach((function(n) {
                    if ("default" !== n) {
                        var r = Object.getOwnPropertyDescriptor(e, n);
                        Object.defineProperty(t, n, r.get ? r : {
                            enumerable: !0,
                            get: function() {
                                return e[n]
                            }
                        })
                    }
                })), t.default = e, Object.freeze(t)
            }
            var u = a(r),
                l = c(i);

            function d() {
                var e;
                return (null === (e = null === self || void 0 === self ? void 0 : self.location) || void 0 === e ? void 0 : e.protocol) || null
            }

            function h(e = s.getUA()) {
                return !("file:" !== d() && "ionic:" !== d() && "capacitor:" !== d() || !e.toLowerCase().match(/iphone|ipad|ipod|android/))
            }

            function p(e = s.getUA()) {
                return s.isIE() && 11 === (null === document || void 0 === document ? void 0 : document.documentMode) || function(e = s.getUA()) {
                    return /Edge\/\d+/.test(e)
                }(e)
            }

            function f() {
                try {
                    const e = self.localStorage,
                        t = l._generateEventId();
                    if (e) return e.setItem(t, "1"), e.removeItem(t), !p() || s.isIndexedDBAvailable()
                } catch (e) {
                    return m() && s.isIndexedDBAvailable()
                }
                return !1
            }

            function m() {
                return void 0 !== n.g && "WorkerGlobalScope" in n.g && "importScripts" in n.g
            }

            function g() {
                return ("http:" === d() || "https:" === d() || s.isBrowserExtension() || h()) && !(s.isReactNative() || s.isNode()) && f() && !m()
            }

            function _() {
                return h() && "undefined" != typeof document
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const v = {
                    LOCAL: "local",
                    NONE: "none",
                    SESSION: "session"
                },
                y = l._assert,
                b = "persistence";
            async function I(e) {
                await e._initializationPromise;
                const t = E(),
                    n = l._persistenceKeyName(b, e.config.apiKey, e.name);
                t && t.setItem(n, e._getPersistence())
            }

            function E() {
                var e;
                try {
                    return (null === (e = "undefined" != typeof window ? window : null) || void 0 === e ? void 0 : e.sessionStorage) || null
                } catch (e) {
                    return null
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const S = l._assert;
            class w {
                constructor() {
                    this.browserResolver = l._getInstance(l.browserPopupRedirectResolver), this.cordovaResolver = l._getInstance(l.cordovaPopupRedirectResolver), this.underlyingResolver = null, this._redirectPersistence = l.browserSessionPersistence, this._completeRedirectFn = l._getRedirectResult, this._overrideRedirectResult = l._overrideRedirectResult
                }
                async _initialize(e) {
                    return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._initialize(e)
                }
                async _openPopup(e, t, n, r) {
                    return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._openPopup(e, t, n, r)
                }
                async _openRedirect(e, t, n, r) {
                    return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._openRedirect(e, t, n, r)
                }
                _isIframeWebStorageSupported(e, t) {
                    this.assertedUnderlyingResolver._isIframeWebStorageSupported(e, t)
                }
                _originValidation(e) {
                    return this.assertedUnderlyingResolver._originValidation(e)
                }
                get _shouldInitProactively() {
                    return _() || this.browserResolver._shouldInitProactively
                }
                get assertedUnderlyingResolver() {
                    return S(this.underlyingResolver, "internal-error"), this.underlyingResolver
                }
                async selectUnderlyingResolver() {
                    if (this.underlyingResolver) return;
                    const e = await async function() {
                        return !!_() && new Promise((e => {
                            const t = setTimeout((() => {
                                e(!1)
                            }), 1e3);
                            document.addEventListener("deviceready", (() => {
                                clearTimeout(t), e(!0)
                            }))
                        }))
                    }();
                    this.underlyingResolver = e ? this.cordovaResolver : this.browserResolver
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function C(e) {
                return e.unwrap()
            }

            function T(e) {
                const {
                    _tokenResponse: t
                } = e instanceof s.FirebaseError ? e.customData : e;
                if (!t) return null;
                if (!(e instanceof s.FirebaseError) && "temporaryProof" in t && "phoneNumber" in t) return l.PhoneAuthProvider.credentialFromResult(e);
                const n = t.providerId;
                if (!n || n === l.ProviderId.PASSWORD) return null;
                let r;
                switch (n) {
                    case l.ProviderId.GOOGLE:
                        r = l.GoogleAuthProvider;
                        break;
                    case l.ProviderId.FACEBOOK:
                        r = l.FacebookAuthProvider;
                        break;
                    case l.ProviderId.GITHUB:
                        r = l.GithubAuthProvider;
                        break;
                    case l.ProviderId.TWITTER:
                        r = l.TwitterAuthProvider;
                        break;
                    default:
                        const {
                            oauthIdToken: e,
                            oauthAccessToken: i,
                            oauthTokenSecret: o,
                            pendingToken: s,
                            nonce: a
                        } = t;
                        return i || o || e || s ? s ? n.startsWith("saml.") ? l.SAMLAuthCredential._create(n, s) : l.OAuthCredential._fromParams({
                            providerId: n,
                            signInMethod: n,
                            pendingToken: s,
                            idToken: e,
                            accessToken: i
                        }) : new l.OAuthProvider(n).credential({
                            idToken: e,
                            accessToken: i,
                            rawNonce: a
                        }) : null
                }
                return e instanceof s.FirebaseError ? r.credentialFromError(e) : r.credentialFromResult(e)
            }

            function A(e, t) {
                return t.catch((t => {
                    throw t instanceof s.FirebaseError && function(e, t) {
                        var n;
                        const r = null === (n = t.customData) || void 0 === n ? void 0 : n._tokenResponse;
                        if ("auth/multi-factor-auth-required" === (null == t ? void 0 : t.code)) t.resolver = new P(e, l.getMultiFactorResolver(e, t));
                        else if (r) {
                            const e = T(t),
                                n = t;
                            e && (n.credential = e, n.tenantId = r.tenantId || void 0, n.email = r.email || void 0, n.phoneNumber = r.phoneNumber || void 0)
                        }
                    }(e, t), t
                })).then((e => {
                    const t = e.operationType,
                        n = e.user;
                    return {
                        operationType: t,
                        credential: (r = e, T(r)),
                        additionalUserInfo: l.getAdditionalUserInfo(e),
                        user: O.getOrCreate(n)
                    };
                    /**
                     * @license
                     * Copyright 2020 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                    var r
                }))
            }
            async function R(e, t) {
                const n = await t;
                return {
                    verificationId: n.verificationId,
                    confirm: t => A(e, n.confirm(t))
                }
            }
            class P {
                constructor(e, t) {
                    this.resolver = t, this.auth = e.wrapped()
                }
                get session() {
                    return this.resolver.session
                }
                get hints() {
                    return this.resolver.hints
                }
                resolveSignIn(e) {
                    return A(C(this.auth), this.resolver.resolveSignIn(e))
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class O {
                constructor(e) {
                    this._delegate = e, this.multiFactor = l.multiFactor(e)
                }
                static getOrCreate(e) {
                    return O.USER_MAP.has(e) || O.USER_MAP.set(e, new O(e)), O.USER_MAP.get(e)
                }
                delete() {
                    return this._delegate.delete()
                }
                reload() {
                    return this._delegate.reload()
                }
                toJSON() {
                    return this._delegate.toJSON()
                }
                getIdTokenResult(e) {
                    return this._delegate.getIdTokenResult(e)
                }
                getIdToken(e) {
                    return this._delegate.getIdToken(e)
                }
                linkAndRetrieveDataWithCredential(e) {
                    return this.linkWithCredential(e)
                }
                async linkWithCredential(e) {
                    return A(this.auth, l.linkWithCredential(this._delegate, e))
                }
                async linkWithPhoneNumber(e, t) {
                    return R(this.auth, l.linkWithPhoneNumber(this._delegate, e, t))
                }
                async linkWithPopup(e) {
                    return A(this.auth, l.linkWithPopup(this._delegate, e, w))
                }
                async linkWithRedirect(e) {
                    return await I(l._castAuth(this.auth)), l.linkWithRedirect(this._delegate, e, w)
                }
                reauthenticateAndRetrieveDataWithCredential(e) {
                    return this.reauthenticateWithCredential(e)
                }
                async reauthenticateWithCredential(e) {
                    return A(this.auth, l.reauthenticateWithCredential(this._delegate, e))
                }
                reauthenticateWithPhoneNumber(e, t) {
                    return R(this.auth, l.reauthenticateWithPhoneNumber(this._delegate, e, t))
                }
                reauthenticateWithPopup(e) {
                    return A(this.auth, l.reauthenticateWithPopup(this._delegate, e, w))
                }
                async reauthenticateWithRedirect(e) {
                    return await I(l._castAuth(this.auth)), l.reauthenticateWithRedirect(this._delegate, e, w)
                }
                sendEmailVerification(e) {
                    return l.sendEmailVerification(this._delegate, e)
                }
                async unlink(e) {
                    return await l.unlink(this._delegate, e), this
                }
                updateEmail(e) {
                    return l.updateEmail(this._delegate, e)
                }
                updatePassword(e) {
                    return l.updatePassword(this._delegate, e)
                }
                updatePhoneNumber(e) {
                    return l.updatePhoneNumber(this._delegate, e)
                }
                updateProfile(e) {
                    return l.updateProfile(this._delegate, e)
                }
                verifyBeforeUpdateEmail(e, t) {
                    return l.verifyBeforeUpdateEmail(this._delegate, e, t)
                }
                get emailVerified() {
                    return this._delegate.emailVerified
                }
                get isAnonymous() {
                    return this._delegate.isAnonymous
                }
                get metadata() {
                    return this._delegate.metadata
                }
                get phoneNumber() {
                    return this._delegate.phoneNumber
                }
                get providerData() {
                    return this._delegate.providerData
                }
                get refreshToken() {
                    return this._delegate.refreshToken
                }
                get tenantId() {
                    return this._delegate.tenantId
                }
                get displayName() {
                    return this._delegate.displayName
                }
                get email() {
                    return this._delegate.email
                }
                get photoURL() {
                    return this._delegate.photoURL
                }
                get providerId() {
                    return this._delegate.providerId
                }
                get uid() {
                    return this._delegate.uid
                }
                get auth() {
                    return this._delegate.auth
                }
            }
            O.USER_MAP = new WeakMap;
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const k = l._assert;
            class N {
                constructor(e, t) {
                    if (this.app = e, t.isInitialized()) return this._delegate = t.getImmediate(), void this.linkUnderlyingAuth();
                    const {
                        apiKey: n
                    } = e.options;
                    k(n, "invalid-api-key", {
                        appName: e.name
                    }), k(n, "invalid-api-key", {
                        appName: e.name
                    });
                    const r = "undefined" != typeof window ? w : void 0;
                    this._delegate = t.initialize({
                        options: {
                            persistence: M(n, e.name),
                            popupRedirectResolver: r
                        }
                    }), this._delegate._updateErrorMap(l.debugErrorMap), this.linkUnderlyingAuth()
                }
                get emulatorConfig() {
                    return this._delegate.emulatorConfig
                }
                get currentUser() {
                    return this._delegate.currentUser ? O.getOrCreate(this._delegate.currentUser) : null
                }
                get languageCode() {
                    return this._delegate.languageCode
                }
                set languageCode(e) {
                    this._delegate.languageCode = e
                }
                get settings() {
                    return this._delegate.settings
                }
                get tenantId() {
                    return this._delegate.tenantId
                }
                set tenantId(e) {
                    this._delegate.tenantId = e
                }
                useDeviceLanguage() {
                    this._delegate.useDeviceLanguage()
                }
                signOut() {
                    return this._delegate.signOut()
                }
                useEmulator(e, t) {
                    l.connectAuthEmulator(this._delegate, e, t)
                }
                applyActionCode(e) {
                    return l.applyActionCode(this._delegate, e)
                }
                checkActionCode(e) {
                    return l.checkActionCode(this._delegate, e)
                }
                confirmPasswordReset(e, t) {
                    return l.confirmPasswordReset(this._delegate, e, t)
                }
                async createUserWithEmailAndPassword(e, t) {
                    return A(this._delegate, l.createUserWithEmailAndPassword(this._delegate, e, t))
                }
                fetchProvidersForEmail(e) {
                    return this.fetchSignInMethodsForEmail(e)
                }
                fetchSignInMethodsForEmail(e) {
                    return l.fetchSignInMethodsForEmail(this._delegate, e)
                }
                isSignInWithEmailLink(e) {
                    return l.isSignInWithEmailLink(this._delegate, e)
                }
                async getRedirectResult() {
                    k(g(), this._delegate, "operation-not-supported-in-this-environment");
                    const e = await l.getRedirectResult(this._delegate, w);
                    return e ? A(this._delegate, Promise.resolve(e)) : {
                        credential: null,
                        user: null
                    }
                }
                addFrameworkForLogging(e) {
                    l.addFrameworkForLogging(this._delegate, e)
                }
                onAuthStateChanged(e, t, n) {
                    const {
                        next: r,
                        error: i,
                        complete: o
                    } = D(e, t, n);
                    return this._delegate.onAuthStateChanged(r, i, o)
                }
                onIdTokenChanged(e, t, n) {
                    const {
                        next: r,
                        error: i,
                        complete: o
                    } = D(e, t, n);
                    return this._delegate.onIdTokenChanged(r, i, o)
                }
                sendSignInLinkToEmail(e, t) {
                    return l.sendSignInLinkToEmail(this._delegate, e, t)
                }
                sendPasswordResetEmail(e, t) {
                    return l.sendPasswordResetEmail(this._delegate, e, t || void 0)
                }
                async setPersistence(e) {
                    let t;
                    switch (function(e, t) {
                        y(Object.values(v).includes(t), e, "invalid-persistence-type"), s.isReactNative() ? y(t !== v.SESSION, e, "unsupported-persistence-type") : s.isNode() ? y(t === v.NONE, e, "unsupported-persistence-type") : m() ? y(t === v.NONE || t === v.LOCAL && s.isIndexedDBAvailable(), e, "unsupported-persistence-type") : y(t === v.NONE || f(), e, "unsupported-persistence-type")
                    }(this._delegate, e), e) {
                        case v.SESSION:
                            t = l.browserSessionPersistence;
                            break;
                        case v.LOCAL:
                            t = await l._getInstance(l.indexedDBLocalPersistence)._isAvailable() ? l.indexedDBLocalPersistence : l.browserLocalPersistence;
                            break;
                        case v.NONE:
                            t = l.inMemoryPersistence;
                            break;
                        default:
                            return l._fail("argument-error", {
                                appName: this._delegate.name
                            })
                    }
                    return this._delegate.setPersistence(t)
                }
                signInAndRetrieveDataWithCredential(e) {
                    return this.signInWithCredential(e)
                }
                signInAnonymously() {
                    return A(this._delegate, l.signInAnonymously(this._delegate))
                }
                signInWithCredential(e) {
                    return A(this._delegate, l.signInWithCredential(this._delegate, e))
                }
                signInWithCustomToken(e) {
                    return A(this._delegate, l.signInWithCustomToken(this._delegate, e))
                }
                signInWithEmailAndPassword(e, t) {
                    return A(this._delegate, l.signInWithEmailAndPassword(this._delegate, e, t))
                }
                signInWithEmailLink(e, t) {
                    return A(this._delegate, l.signInWithEmailLink(this._delegate, e, t))
                }
                signInWithPhoneNumber(e, t) {
                    return R(this._delegate, l.signInWithPhoneNumber(this._delegate, e, t))
                }
                async signInWithPopup(e) {
                    return k(g(), this._delegate, "operation-not-supported-in-this-environment"), A(this._delegate, l.signInWithPopup(this._delegate, e, w))
                }
                async signInWithRedirect(e) {
                    return k(g(), this._delegate, "operation-not-supported-in-this-environment"), await I(this._delegate), l.signInWithRedirect(this._delegate, e, w)
                }
                updateCurrentUser(e) {
                    return this._delegate.updateCurrentUser(e)
                }
                verifyPasswordResetCode(e) {
                    return l.verifyPasswordResetCode(this._delegate, e)
                }
                unwrap() {
                    return this._delegate
                }
                _delete() {
                    return this._delegate._delete()
                }
                linkUnderlyingAuth() {
                    this._delegate.wrapped = () => this
                }
            }

            function D(e, t, n) {
                let r = e;
                "function" != typeof e && ({
                    next: r,
                    error: t,
                    complete: n
                } = e);
                const i = r;
                return {
                    next: e => i(e && O.getOrCreate(e)),
                    error: t,
                    complete: n
                }
            }

            function M(e, t) {
                const n = function(e, t) {
                    const n = E();
                    if (!n) return [];
                    const r = l._persistenceKeyName(b, e, t);
                    switch (n.getItem(r)) {
                        case v.NONE:
                            return [l.inMemoryPersistence];
                        case v.LOCAL:
                            return [l.indexedDBLocalPersistence, l.browserSessionPersistence];
                        case v.SESSION:
                            return [l.browserSessionPersistence];
                        default:
                            return []
                    }
                }(e, t);
                if ("undefined" == typeof self || n.includes(l.indexedDBLocalPersistence) || n.push(l.indexedDBLocalPersistence), "undefined" != typeof window)
                    for (const e of [l.browserLocalPersistence, l.browserSessionPersistence]) n.includes(e) || n.push(e);
                return n.includes(l.inMemoryPersistence) || n.push(l.inMemoryPersistence), n
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            N.Persistence = v;
            class x {
                constructor() {
                    this.providerId = "phone", this._delegate = new l.PhoneAuthProvider(C(u.default.auth()))
                }
                static credential(e, t) {
                    return l.PhoneAuthProvider.credential(e, t)
                }
                verifyPhoneNumber(e, t) {
                    return this._delegate.verifyPhoneNumber(e, t)
                }
                unwrap() {
                    return this._delegate
                }
            }
            x.PHONE_SIGN_IN_METHOD = l.PhoneAuthProvider.PHONE_SIGN_IN_METHOD, x.PROVIDER_ID = l.PhoneAuthProvider.PROVIDER_ID;
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const L = l._assert;
            class U {
                constructor(e, t, n = u.default.app()) {
                    var r;
                    L(null === (r = n.options) || void 0 === r ? void 0 : r.apiKey, "invalid-api-key", {
                        appName: n.name
                    }), this._delegate = new l.RecaptchaVerifier(e, t, n.auth()), this.type = this._delegate.type
                }
                clear() {
                    this._delegate.clear()
                }
                render() {
                    return this._delegate.render()
                }
                verify() {
                    return this._delegate.verify()
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var F;
            (F = u.default).INTERNAL.registerComponent(new o.Component("auth-compat", (e => {
                const t = e.getProvider("app-compat").getImmediate(),
                    n = e.getProvider("auth");
                return new N(t, n)
            }), "PUBLIC").setServiceProps({
                ActionCodeInfo: {
                    Operation: {
                        EMAIL_SIGNIN: l.ActionCodeOperation.EMAIL_SIGNIN,
                        PASSWORD_RESET: l.ActionCodeOperation.PASSWORD_RESET,
                        RECOVER_EMAIL: l.ActionCodeOperation.RECOVER_EMAIL,
                        REVERT_SECOND_FACTOR_ADDITION: l.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,
                        VERIFY_AND_CHANGE_EMAIL: l.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,
                        VERIFY_EMAIL: l.ActionCodeOperation.VERIFY_EMAIL
                    }
                },
                EmailAuthProvider: l.EmailAuthProvider,
                FacebookAuthProvider: l.FacebookAuthProvider,
                GithubAuthProvider: l.GithubAuthProvider,
                GoogleAuthProvider: l.GoogleAuthProvider,
                OAuthProvider: l.OAuthProvider,
                SAMLAuthProvider: l.SAMLAuthProvider,
                PhoneAuthProvider: x,
                PhoneMultiFactorGenerator: l.PhoneMultiFactorGenerator,
                RecaptchaVerifier: U,
                TwitterAuthProvider: l.TwitterAuthProvider,
                Auth: N,
                AuthCredential: l.AuthCredential,
                Error: s.FirebaseError
            }).setInstantiationMode("LAZY").setMultipleInstances(!1)), F.registerVersion("@firebase/auth-compat", "0.4.2")
        },
        48660: function(e, t, n) {
            "use strict";
            var r = n(6789),
                i = n(36022),
                o = n(92712),
                s = n(35129),
                a = n(51656);

            function c() {
                return {
                    "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
                }
            }
            const u =
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                function() {
                    return {
                        "admin-restricted-operation": "This operation is restricted to administrators only.",
                        "argument-error": "",
                        "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
                        "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
                        "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
                        "code-expired": "The SMS code has expired. Please re-send the verification code to try again.",
                        "cordova-not-ready": "Cordova framework is not ready.",
                        "cors-unsupported": "This browser is not supported.",
                        "credential-already-in-use": "This credential is already associated with a different user account.",
                        "custom-token-mismatch": "The custom token corresponds to a different audience.",
                        "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
                        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.",
                        "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",
                        "email-change-needs-verification": "Multi-factor users must always have a verified email.",
                        "email-already-in-use": "The email address is already in use by another account.",
                        "emulator-config-failed": 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.',
                        "expired-action-code": "The action code has expired.",
                        "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.",
                        "internal-error": "An internal AuthError has occurred.",
                        "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
                        "invalid-app-id": "The mobile app identifier is not registed for the current project.",
                        "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
                        "invalid-auth-event": "An internal AuthError has occurred.",
                        "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.",
                        "invalid-continue-uri": "The continue URL provided in the request is invalid.",
                        "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",
                        "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.",
                        "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.",
                        "invalid-email": "The email address is badly formatted.",
                        "invalid-emulator-scheme": "Emulator URL must start with a valid scheme (http:// or https://).",
                        "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.",
                        "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.",
                        "invalid-credential": "The supplied auth credential is malformed or has expired.",
                        "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
                        "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.",
                        "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
                        "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.",
                        "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
                        "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",
                        "wrong-password": "The password is invalid or the user does not have a password.",
                        "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.",
                        "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
                        "invalid-provider-id": "The specified provider ID is invalid.",
                        "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.",
                        "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",
                        "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.",
                        "invalid-tenant-id": "The Auth instance's tenant ID is invalid.",
                        "login-blocked": "Login blocked by user-provided method: {$originalMessage}",
                        "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.",
                        "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",
                        "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",
                        "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.",
                        "missing-continue-uri": "A continue URL must be provided in the request.",
                        "missing-iframe-start": "An internal AuthError has occurred.",
                        "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.",
                        "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",
                        "missing-password": "A non-empty password must be provided",
                        "missing-multi-factor-info": "No second factor identifier is provided.",
                        "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.",
                        "missing-phone-number": "To send verification codes, provide a phone number for the recipient.",
                        "missing-verification-id": "The phone auth credential was created with an empty verification ID.",
                        "app-deleted": "This instance of FirebaseApp has been deleted.",
                        "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.",
                        "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.",
                        "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
                        "network-request-failed": "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.",
                        "no-auth-event": "An internal AuthError has occurred.",
                        "no-such-provider": "User was not linked to an account with the given provider.",
                        "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.",
                        "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
                        "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
                        "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.",
                        "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.",
                        "provider-already-linked": "User can only be linked to one identity for the given provider.",
                        "quota-exceeded": "The project's quota for this operation has been exceeded.",
                        "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.",
                        "redirect-operation-pending": "A redirect sign-in operation is already pending.",
                        "rejected-credential": "The request contains malformed or mismatching credentials.",
                        "second-factor-already-in-use": "The second factor is already enrolled on this account.",
                        "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.",
                        "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID",
                        timeout: "The operation has timed out.",
                        "user-token-expired": "The user's credential is no longer valid. The user must sign in again.",
                        "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.",
                        "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",
                        "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
                        "unsupported-persistence-type": "The current environment does not support the specified persistence type.",
                        "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.",
                        "unverified-email": "The operation requires a verified email.",
                        "user-cancelled": "The user did not grant your application the permissions it requested.",
                        "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.",
                        "user-disabled": "The user account has been disabled by an administrator.",
                        "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.",
                        "user-signed-out": "",
                        "weak-password": "The password must be 6 characters long or more.",
                        "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled.",
                        "already-initialized": "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance.",
                        "missing-recaptcha-token": "The reCAPTCHA token is missing when sending request to the backend.",
                        "invalid-recaptcha-token": "The reCAPTCHA token is invalid when sending request to the backend.",
                        "invalid-recaptcha-action": "The reCAPTCHA action is invalid when sending request to the backend.",
                        "recaptcha-not-enabled": "reCAPTCHA Enterprise integration is not enabled for this project.",
                        "missing-client-type": "The reCAPTCHA client type is missing when sending request to the backend.",
                        "missing-recaptcha-version": "The reCAPTCHA version is missing when sending request to the backend.",
                        "invalid-req-type": "Invalid request parameters.",
                        "invalid-recaptcha-version": "The reCAPTCHA version is invalid when sending request to the backend."
                    }
                },
                l = c,
                d = new r.ErrorFactory("auth", "Firebase", {
                    "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
                }),
                h = new s.Logger("@firebase/auth");

            function p(e, ...t) {
                h.logLevel <= s.LogLevel.ERROR && h.error(`Auth (${i.SDK_VERSION}): ${e}`, ...t)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function f(e, ...t) {
                throw v(e, ...t)
            }

            function m(e, ...t) {
                return v(e, ...t)
            }

            function g(e, t, n) {
                const i = Object.assign(Object.assign({}, l()), {
                    [t]: n
                });
                return new r.ErrorFactory("auth", "Firebase", i).create(t, {
                    appName: e.name
                })
            }

            function _(e, t, n) {
                if (!(t instanceof n)) throw n.name !== t.constructor.name && f(e, "argument-error"), g(e, "argument-error", `Type of ${t.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`)
            }

            function v(e, ...t) {
                if ("string" != typeof e) {
                    const n = t[0],
                        r = [...t.slice(1)];
                    return r[0] && (r[0].appName = e.name), e._errorFactory.create(n, ...r)
                }
                return d.create(e, ...t)
            }

            function y(e, t, ...n) {
                if (!e) throw v(t, ...n)
            }

            function b(e) {
                const t = "INTERNAL ASSERTION FAILED: " + e;
                throw p(t), new Error(t)
            }

            function I(e, t) {
                e || b(t)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function E() {
                var e;
                return "undefined" != typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.href) || ""
            }

            function S() {
                return "http:" === w() || "https:" === w()
            }

            function w() {
                var e;
                return "undefined" != typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.protocol) || null
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class C {
                constructor(e, t) {
                    this.shortDelay = e, this.longDelay = t, I(t > e, "Short delay should be less than long delay!"), this.isMobile = r.isMobileCordova() || r.isReactNative()
                }
                get() {
                    return "undefined" != typeof navigator && navigator && "onLine" in navigator && "boolean" == typeof navigator.onLine && (S() || r.isBrowserExtension() || "connection" in navigator) && !navigator.onLine ? Math.min(5e3, this.shortDelay) : this.isMobile ? this.longDelay : this.shortDelay
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function T(e, t) {
                I(e.emulator, "Emulator should always be set here");
                const {
                    url: n
                } = e.emulator;
                return t ? `${n}${t.startsWith("/")?t.slice(1):t}` : n
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class A {
                static initialize(e, t, n) {
                    this.fetchImpl = e, t && (this.headersImpl = t), n && (this.responseImpl = n)
                }
                static fetch() {
                    return this.fetchImpl ? this.fetchImpl : "undefined" != typeof self && "fetch" in self ? self.fetch : void b("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
                }
                static headers() {
                    return this.headersImpl ? this.headersImpl : "undefined" != typeof self && "Headers" in self ? self.Headers : void b("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
                }
                static response() {
                    return this.responseImpl ? this.responseImpl : "undefined" != typeof self && "Response" in self ? self.Response : void b("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const R = {
                    CREDENTIAL_MISMATCH: "custom-token-mismatch",
                    MISSING_CUSTOM_TOKEN: "internal-error",
                    INVALID_IDENTIFIER: "invalid-email",
                    MISSING_CONTINUE_URI: "internal-error",
                    INVALID_PASSWORD: "wrong-password",
                    MISSING_PASSWORD: "missing-password",
                    EMAIL_EXISTS: "email-already-in-use",
                    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
                    INVALID_IDP_RESPONSE: "invalid-credential",
                    INVALID_PENDING_TOKEN: "invalid-credential",
                    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
                    MISSING_REQ_TYPE: "internal-error",
                    EMAIL_NOT_FOUND: "user-not-found",
                    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
                    EXPIRED_OOB_CODE: "expired-action-code",
                    INVALID_OOB_CODE: "invalid-action-code",
                    MISSING_OOB_CODE: "internal-error",
                    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
                    INVALID_ID_TOKEN: "invalid-user-token",
                    TOKEN_EXPIRED: "user-token-expired",
                    USER_NOT_FOUND: "user-token-expired",
                    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
                    INVALID_CODE: "invalid-verification-code",
                    INVALID_SESSION_INFO: "invalid-verification-id",
                    INVALID_TEMPORARY_PROOF: "invalid-credential",
                    MISSING_SESSION_INFO: "missing-verification-id",
                    SESSION_EXPIRED: "code-expired",
                    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
                    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
                    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
                    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
                    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
                    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
                    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
                    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
                    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
                    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
                    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
                    RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
                    MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
                    INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
                    INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
                    MISSING_CLIENT_TYPE: "missing-client-type",
                    MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
                    INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
                    INVALID_REQ_TYPE: "invalid-req-type"
                },
                P = new C(3e4, 6e4);
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function O(e, t) {
                return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), {
                    tenantId: e.tenantId
                }) : t
            }
            async function k(e, t, n, i, o = {}) {
                return N(e, o, (async () => {
                    let o = {},
                        s = {};
                    i && ("GET" === t ? s = i : o = {
                        body: JSON.stringify(i)
                    });
                    const a = r.querystring(Object.assign({
                            key: e.config.apiKey
                        }, s)).slice(1),
                        c = await e._getAdditionalHeaders();
                    return c["Content-Type"] = "application/json", e.languageCode && (c["X-Firebase-Locale"] = e.languageCode), A.fetch()(M(e, e.config.apiHost, n, a), Object.assign({
                        method: t,
                        headers: c,
                        referrerPolicy: "no-referrer"
                    }, o))
                }))
            }
            async function N(e, t, n) {
                e._canInitEmulator = !1;
                const i = Object.assign(Object.assign({}, R), t);
                try {
                    const t = new x(e),
                        r = await Promise.race([n(), t.promise]);
                    t.clearNetworkTimeout();
                    const o = await r.json();
                    if ("needConfirmation" in o) throw L(e, "account-exists-with-different-credential", o);
                    if (r.ok && !("errorMessage" in o)) return o; {
                        const t = r.ok ? o.errorMessage : o.error.message,
                            [n, s] = t.split(" : ");
                        if ("FEDERATED_USER_ID_ALREADY_LINKED" === n) throw L(e, "credential-already-in-use", o);
                        if ("EMAIL_EXISTS" === n) throw L(e, "email-already-in-use", o);
                        if ("USER_DISABLED" === n) throw L(e, "user-disabled", o);
                        const a = i[n] || n.toLowerCase().replace(/[_\s]+/g, "-");
                        if (s) throw g(e, a, s);
                        f(e, a)
                    }
                } catch (t) {
                    if (t instanceof r.FirebaseError) throw t;
                    f(e, "network-request-failed", {
                        message: String(t)
                    })
                }
            }
            async function D(e, t, n, r, i = {}) {
                const o = await k(e, t, n, r, i);
                return "mfaPendingCredential" in o && f(e, "multi-factor-auth-required", {
                    _serverResponse: o
                }), o
            }

            function M(e, t, n, r) {
                const i = `${t}${n}?${r}`;
                return e.config.emulator ? T(e.config, i) : `${e.config.apiScheme}://${i}`
            }
            class x {
                constructor(e) {
                    this.auth = e, this.timer = null, this.promise = new Promise(((e, t) => {
                        this.timer = setTimeout((() => t(m(this.auth, "network-request-failed"))), P.get())
                    }))
                }
                clearNetworkTimeout() {
                    clearTimeout(this.timer)
                }
            }

            function L(e, t, n) {
                const r = {
                    appName: e.name
                };
                n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber);
                const i = m(e, t, r);
                return i.customData._tokenResponse = n, i
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function U(e) {
                if (e) try {
                    const t = new Date(Number(e));
                    if (!isNaN(t.getTime())) return t.toUTCString()
                } catch (e) {}
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function F(e, t = !1) {
                const n = r.getModularInstance(e),
                    i = await n.getIdToken(t),
                    o = q(i);
                y(o && o.exp && o.auth_time && o.iat, n.auth, "internal-error");
                const s = "object" == typeof o.firebase ? o.firebase : void 0,
                    a = null == s ? void 0 : s.sign_in_provider;
                return {
                    claims: o,
                    token: i,
                    authTime: U(j(o.auth_time)),
                    issuedAtTime: U(j(o.iat)),
                    expirationTime: U(j(o.exp)),
                    signInProvider: a || null,
                    signInSecondFactor: (null == s ? void 0 : s.sign_in_second_factor) || null
                }
            }

            function j(e) {
                return 1e3 * Number(e)
            }

            function q(e) {
                const [t, n, i] = e.split(".");
                if (void 0 === t || void 0 === n || void 0 === i) return p("JWT malformed, contained fewer than 3 sections"), null;
                try {
                    const e = r.base64Decode(n);
                    return e ? JSON.parse(e) : (p("Failed to decode base64 JWT payload"), null)
                } catch (e) {
                    return p("Caught error parsing JWT payload as JSON", null == e ? void 0 : e.toString()), null
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function H(e, t, n = !1) {
                if (n) return t;
                try {
                    return await t
                } catch (t) {
                    throw t instanceof r.FirebaseError && function({
                        code: e
                    }) {
                        return "auth/user-disabled" === e || "auth/user-token-expired" === e
                    }
                    /**
                     * @license
                     * Copyright 2020 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                    (t) && e.auth.currentUser === e && await e.auth.signOut(), t
                }
            }
            class W {
                constructor(e) {
                    this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4
                }
                _start() {
                    this.isRunning || (this.isRunning = !0, this.schedule())
                }
                _stop() {
                    this.isRunning && (this.isRunning = !1, null !== this.timerId && clearTimeout(this.timerId))
                }
                getInterval(e) {
                    var t;
                    if (e) {
                        const e = this.errorBackoff;
                        return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), e
                    } {
                        this.errorBackoff = 3e4;
                        const e = (null !== (t = this.user.stsTokenManager.expirationTime) && void 0 !== t ? t : 0) - Date.now() - 3e5;
                        return Math.max(0, e)
                    }
                }
                schedule(e = !1) {
                    if (!this.isRunning) return;
                    const t = this.getInterval(e);
                    this.timerId = setTimeout((async () => {
                        await this.iteration()
                    }), t)
                }
                async iteration() {
                    try {
                        await this.user.getIdToken(!0)
                    } catch (e) {
                        return void("auth/network-request-failed" === (null == e ? void 0 : e.code) && this.schedule(!0))
                    }
                    this.schedule()
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class B {
                constructor(e, t) {
                    this.createdAt = e, this.lastLoginAt = t, this._initializeTime()
                }
                _initializeTime() {
                    this.lastSignInTime = U(this.lastLoginAt), this.creationTime = U(this.createdAt)
                }
                _copy(e) {
                    this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime()
                }
                toJSON() {
                    return {
                        createdAt: this.createdAt,
                        lastLoginAt: this.lastLoginAt
                    }
                }
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function V(e) {
                var t;
                const n = e.auth,
                    r = await e.getIdToken(),
                    i = await H(e, async function(e, t) {
                        return k(e, "POST", "/v1/accounts:lookup", t)
                    }(n, {
                        idToken: r
                    }));
                y(null == i ? void 0 : i.users.length, n, "internal-error");
                const s = i.users[0];
                e._notifyReloadListener(s);
                const a = (null === (t = s.providerUserInfo) || void 0 === t ? void 0 : t.length) ? s.providerUserInfo.map((e => {
                    var {
                        providerId: t
                    } = e, n = o.__rest(e, ["providerId"]);
                    return {
                        providerId: t,
                        uid: n.rawId || "",
                        displayName: n.displayName || null,
                        email: n.email || null,
                        phoneNumber: n.phoneNumber || null,
                        photoURL: n.photoUrl || null
                    }
                })) : [];
                const c = (u = e.providerData, l = a, [...u.filter((e => !l.some((t => t.providerId === e.providerId)))), ...l]);
                var u, l;
                const d = e.isAnonymous,
                    h = !(e.email && s.passwordHash || (null == c ? void 0 : c.length)),
                    p = !!d && h,
                    f = {
                        uid: s.localId,
                        displayName: s.displayName || null,
                        photoURL: s.photoUrl || null,
                        email: s.email || null,
                        emailVerified: s.emailVerified || !1,
                        phoneNumber: s.phoneNumber || null,
                        tenantId: s.tenantId || null,
                        providerData: c,
                        metadata: new B(s.createdAt, s.lastLoginAt),
                        isAnonymous: p
                    };
                Object.assign(e, f)
            }
            async function G(e) {
                const t = r.getModularInstance(e);
                await V(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class z {
                constructor() {
                    this.refreshToken = null, this.accessToken = null, this.expirationTime = null
                }
                get isExpired() {
                    return !this.expirationTime || Date.now() > this.expirationTime - 3e4
                }
                updateFromServerResponse(e) {
                    y(e.idToken, "internal-error"), y(void 0 !== e.idToken, "internal-error"), y(void 0 !== e.refreshToken, "internal-error");
                    const t = "expiresIn" in e && void 0 !== e.expiresIn ? Number(e.expiresIn) : function(e) {
                        const t = q(e);
                        return y(t, "internal-error"), y(void 0 !== t.exp, "internal-error"), y(void 0 !== t.iat, "internal-error"), Number(t.exp) - Number(t.iat)
                    }(e.idToken);
                    this.updateTokensAndExpiration(e.idToken, e.refreshToken, t)
                }
                async getToken(e, t = !1) {
                    return y(!this.accessToken || this.refreshToken, e, "user-token-expired"), t || !this.accessToken || this.isExpired ? this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null : this.accessToken
                }
                clearRefreshToken() {
                    this.refreshToken = null
                }
                async refresh(e, t) {
                    const {
                        accessToken: n,
                        refreshToken: i,
                        expiresIn: o
                    } =
                    /**
                     * @license
                     * Copyright 2020 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                    await async function(e, t) {
                        const n = await N(e, {}, (async () => {
                            const n = r.querystring({
                                    grant_type: "refresh_token",
                                    refresh_token: t
                                }).slice(1),
                                {
                                    tokenApiHost: i,
                                    apiKey: o
                                } = e.config,
                                s = M(e, i, "/v1/token", `key=${o}`),
                                a = await e._getAdditionalHeaders();
                            return a["Content-Type"] = "application/x-www-form-urlencoded", A.fetch()(s, {
                                method: "POST",
                                headers: a,
                                body: n
                            })
                        }));
                        return {
                            accessToken: n.access_token,
                            expiresIn: n.expires_in,
                            refreshToken: n.refresh_token
                        }
                    }(e, t);
                    this.updateTokensAndExpiration(n, i, Number(o))
                }
                updateTokensAndExpiration(e, t, n) {
                    this.refreshToken = t || null, this.accessToken = e || null, this.expirationTime = Date.now() + 1e3 * n
                }
                static fromJSON(e, t) {
                    const {
                        refreshToken: n,
                        accessToken: r,
                        expirationTime: i
                    } = t, o = new z;
                    return n && (y("string" == typeof n, "internal-error", {
                        appName: e
                    }), o.refreshToken = n), r && (y("string" == typeof r, "internal-error", {
                        appName: e
                    }), o.accessToken = r), i && (y("number" == typeof i, "internal-error", {
                        appName: e
                    }), o.expirationTime = i), o
                }
                toJSON() {
                    return {
                        refreshToken: this.refreshToken,
                        accessToken: this.accessToken,
                        expirationTime: this.expirationTime
                    }
                }
                _assign(e) {
                    this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime
                }
                _clone() {
                    return Object.assign(new z, this.toJSON())
                }
                _performRefresh() {
                    return b("not implemented")
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function $(e, t) {
                y("string" == typeof e || void 0 === e, "internal-error", {
                    appName: t
                })
            }
            class K {
                constructor(e) {
                    var {
                        uid: t,
                        auth: n,
                        stsTokenManager: r
                    } = e, i = o.__rest(e, ["uid", "auth", "stsTokenManager"]);
                    this.providerId = "firebase", this.proactiveRefresh = new W(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = t, this.auth = n, this.stsTokenManager = r, this.accessToken = r.accessToken, this.displayName = i.displayName || null, this.email = i.email || null, this.emailVerified = i.emailVerified || !1, this.phoneNumber = i.phoneNumber || null, this.photoURL = i.photoURL || null, this.isAnonymous = i.isAnonymous || !1, this.tenantId = i.tenantId || null, this.providerData = i.providerData ? [...i.providerData] : [], this.metadata = new B(i.createdAt || void 0, i.lastLoginAt || void 0)
                }
                async getIdToken(e) {
                    const t = await H(this, this.stsTokenManager.getToken(this.auth, e));
                    return y(t, this.auth, "internal-error"), this.accessToken !== t && (this.accessToken = t, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), t
                }
                getIdTokenResult(e) {
                    return F(this, e)
                }
                reload() {
                    return G(this)
                }
                _assign(e) {
                    this !== e && (y(this.uid === e.uid, this.auth, "internal-error"), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map((e => Object.assign({}, e))), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager))
                }
                _clone(e) {
                    const t = new K(Object.assign(Object.assign({}, this), {
                        auth: e,
                        stsTokenManager: this.stsTokenManager._clone()
                    }));
                    return t.metadata._copy(this.metadata), t
                }
                _onReload(e) {
                    y(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null)
                }
                _notifyReloadListener(e) {
                    this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e
                }
                _startProactiveRefresh() {
                    this.proactiveRefresh._start()
                }
                _stopProactiveRefresh() {
                    this.proactiveRefresh._stop()
                }
                async _updateTokensIfNecessary(e, t = !1) {
                    let n = !1;
                    e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), n = !0), t && await V(this), await this.auth._persistUserIfCurrent(this), n && this.auth._notifyListenersIfCurrent(this)
                }
                async delete() {
                    const e = await this.getIdToken();
                    return await H(this, async function(e, t) {
                        return k(e, "POST", "/v1/accounts:delete", t)
                    }(this.auth, {
                        idToken: e
                    })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut()
                }
                toJSON() {
                    return Object.assign(Object.assign({
                        uid: this.uid,
                        email: this.email || void 0,
                        emailVerified: this.emailVerified,
                        displayName: this.displayName || void 0,
                        isAnonymous: this.isAnonymous,
                        photoURL: this.photoURL || void 0,
                        phoneNumber: this.phoneNumber || void 0,
                        tenantId: this.tenantId || void 0,
                        providerData: this.providerData.map((e => Object.assign({}, e))),
                        stsTokenManager: this.stsTokenManager.toJSON(),
                        _redirectEventId: this._redirectEventId
                    }, this.metadata.toJSON()), {
                        apiKey: this.auth.config.apiKey,
                        appName: this.auth.name
                    })
                }
                get refreshToken() {
                    return this.stsTokenManager.refreshToken || ""
                }
                static _fromJSON(e, t) {
                    var n, r, i, o, s, a, c, u;
                    const l = null !== (n = t.displayName) && void 0 !== n ? n : void 0,
                        d = null !== (r = t.email) && void 0 !== r ? r : void 0,
                        h = null !== (i = t.phoneNumber) && void 0 !== i ? i : void 0,
                        p = null !== (o = t.photoURL) && void 0 !== o ? o : void 0,
                        f = null !== (s = t.tenantId) && void 0 !== s ? s : void 0,
                        m = null !== (a = t._redirectEventId) && void 0 !== a ? a : void 0,
                        g = null !== (c = t.createdAt) && void 0 !== c ? c : void 0,
                        _ = null !== (u = t.lastLoginAt) && void 0 !== u ? u : void 0,
                        {
                            uid: v,
                            emailVerified: b,
                            isAnonymous: I,
                            providerData: E,
                            stsTokenManager: S
                        } = t;
                    y(v && S, e, "internal-error");
                    const w = z.fromJSON(this.name, S);
                    y("string" == typeof v, e, "internal-error"), $(l, e.name), $(d, e.name), y("boolean" == typeof b, e, "internal-error"), y("boolean" == typeof I, e, "internal-error"), $(h, e.name), $(p, e.name), $(f, e.name), $(m, e.name), $(g, e.name), $(_, e.name);
                    const C = new K({
                        uid: v,
                        auth: e,
                        email: d,
                        emailVerified: b,
                        displayName: l,
                        isAnonymous: I,
                        photoURL: p,
                        phoneNumber: h,
                        tenantId: f,
                        stsTokenManager: w,
                        createdAt: g,
                        lastLoginAt: _
                    });
                    return E && Array.isArray(E) && (C.providerData = E.map((e => Object.assign({}, e)))), m && (C._redirectEventId = m), C
                }
                static async _fromIdTokenResponse(e, t, n = !1) {
                    const r = new z;
                    r.updateFromServerResponse(t);
                    const i = new K({
                        uid: t.localId,
                        auth: e,
                        stsTokenManager: r,
                        isAnonymous: n
                    });
                    return await V(i), i
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Y = new Map;

            function J(e) {
                I(e instanceof Function, "Expected a class definition");
                let t = Y.get(e);
                return t ? (I(t instanceof e, "Instance stored in cache mismatched with class"), t) : (t = new e, Y.set(e, t), t)
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Q {
                constructor() {
                    this.type = "NONE", this.storage = {}
                }
                async _isAvailable() {
                    return !0
                }
                async _set(e, t) {
                    this.storage[e] = t
                }
                async _get(e) {
                    const t = this.storage[e];
                    return void 0 === t ? null : t
                }
                async _remove(e) {
                    delete this.storage[e]
                }
                _addListener(e, t) {}
                _removeListener(e, t) {}
            }
            Q.type = "NONE";
            const X = Q;
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function Z(e, t, n) {
                return `firebase:${e}:${t}:${n}`
            }
            class ee {
                constructor(e, t, n) {
                    this.persistence = e, this.auth = t, this.userKey = n;
                    const {
                        config: r,
                        name: i
                    } = this.auth;
                    this.fullUserKey = Z(this.userKey, r.apiKey, i), this.fullPersistenceKey = Z("persistence", r.apiKey, i), this.boundEventHandler = t._onStorageEvent.bind(t), this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
                }
                setCurrentUser(e) {
                    return this.persistence._set(this.fullUserKey, e.toJSON())
                }
                async getCurrentUser() {
                    const e = await this.persistence._get(this.fullUserKey);
                    return e ? K._fromJSON(this.auth, e) : null
                }
                removeCurrentUser() {
                    return this.persistence._remove(this.fullUserKey)
                }
                savePersistenceForRedirect() {
                    return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
                }
                async setPersistence(e) {
                    if (this.persistence === e) return;
                    const t = await this.getCurrentUser();
                    return await this.removeCurrentUser(), this.persistence = e, t ? this.setCurrentUser(t) : void 0
                }
                delete() {
                    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
                }
                static async create(e, t, n = "authUser") {
                    if (!t.length) return new ee(J(X), e, n);
                    const r = (await Promise.all(t.map((async e => {
                        if (await e._isAvailable()) return e
                    })))).filter((e => e));
                    let i = r[0] || J(X);
                    const o = Z(n, e.config.apiKey, e.name);
                    let s = null;
                    for (const n of t) try {
                        const t = await n._get(o);
                        if (t) {
                            const r = K._fromJSON(e, t);
                            n !== i && (s = r), i = n;
                            break
                        }
                    } catch (e) {}
                    const a = r.filter((e => e._shouldAllowMigration));
                    return i._shouldAllowMigration && a.length ? (i = a[0], s && await i._set(o, s.toJSON()), await Promise.all(t.map((async e => {
                        if (e !== i) try {
                            await e._remove(o)
                        } catch (e) {}
                    }))), new ee(i, e, n)) : new ee(i, e, n)
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function te(e) {
                const t = e.toLowerCase();
                if (t.includes("opera/") || t.includes("opr/") || t.includes("opios/")) return "Opera";
                if (oe(t)) return "IEMobile";
                if (t.includes("msie") || t.includes("trident/")) return "IE";
                if (t.includes("edge/")) return "Edge";
                if (ne(t)) return "Firefox";
                if (t.includes("silk/")) return "Silk";
                if (ae(t)) return "Blackberry";
                if (ce(t)) return "Webos";
                if (re(t)) return "Safari";
                if ((t.includes("chrome/") || ie(t)) && !t.includes("edge/")) return "Chrome";
                if (se(t)) return "Android"; {
                    const t = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/,
                        n = e.match(t);
                    if (2 === (null == n ? void 0 : n.length)) return n[1]
                }
                return "Other"
            }

            function ne(e = r.getUA()) {
                return /firefox\//i.test(e)
            }

            function re(e = r.getUA()) {
                const t = e.toLowerCase();
                return t.includes("safari/") && !t.includes("chrome/") && !t.includes("crios/") && !t.includes("android")
            }

            function ie(e = r.getUA()) {
                return /crios\//i.test(e)
            }

            function oe(e = r.getUA()) {
                return /iemobile/i.test(e)
            }

            function se(e = r.getUA()) {
                return /android/i.test(e)
            }

            function ae(e = r.getUA()) {
                return /blackberry/i.test(e)
            }

            function ce(e = r.getUA()) {
                return /webos/i.test(e)
            }

            function ue(e = r.getUA()) {
                return /iphone|ipad|ipod/i.test(e) || /macintosh/i.test(e) && /mobile/i.test(e)
            }

            function le(e = r.getUA()) {
                return ue(e) || se(e) || ce(e) || ae(e) || /windows phone/i.test(e) || oe(e)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function de(e, t = []) {
                let n;
                switch (e) {
                    case "Browser":
                        n = te(r.getUA());
                        break;
                    case "Worker":
                        n = `${te(r.getUA())}-${e}`;
                        break;
                    default:
                        n = e
                }
                const o = t.length ? t.join(",") : "FirebaseCore-web";
                return `${n}/JsCore/${i.SDK_VERSION}/${o}`
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function he(e, t) {
                return k(e, "GET", "/v2/recaptchaConfig", O(e, t))
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function pe(e) {
                return void 0 !== e && void 0 !== e.getResponse
            }

            function fe(e) {
                return void 0 !== e && void 0 !== e.enterprise
            }
            class me {
                constructor(e) {
                    if (this.siteKey = "", this.emailPasswordEnabled = !1, void 0 === e.recaptchaKey) throw new Error("recaptchaKey undefined");
                    this.siteKey = e.recaptchaKey.split("/")[3], this.emailPasswordEnabled = e.recaptchaEnforcementState.some((e => "EMAIL_PASSWORD_PROVIDER" === e.provider && "OFF" !== e.enforcementState))
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function ge(e) {
                return new Promise(((t, n) => {
                    const r = document.createElement("script");
                    var i, o;
                    r.setAttribute("src", e), r.onload = t, r.onerror = e => {
                        const t = m("internal-error");
                        t.customData = e, n(t)
                    }, r.type = "text/javascript", r.charset = "UTF-8", (null !== (o = null === (i = document.getElementsByTagName("head")) || void 0 === i ? void 0 : i[0]) && void 0 !== o ? o : document).appendChild(r)
                }))
            }

            function _e(e) {
                return `__${e}${Math.floor(1e6*Math.random())}`
            }
            class ve {
                constructor(e) {
                    this.type = "recaptcha-enterprise", this.auth = Ee(e)
                }
                async verify(e = "verify", t = !1) {
                    function n(t, n, r) {
                        const i = window.grecaptcha;
                        fe(i) ? i.enterprise.ready((() => {
                            i.enterprise.execute(t, {
                                action: e
                            }).then((e => {
                                n(e)
                            })).catch((() => {
                                n("NO_RECAPTCHA")
                            }))
                        })) : r(Error("No reCAPTCHA enterprise script loaded."))
                    }
                    return new Promise(((e, r) => {
                        (async function(e) {
                            if (!t) {
                                if (null == e.tenantId && null != e._agentRecaptchaConfig) return e._agentRecaptchaConfig.siteKey;
                                if (null != e.tenantId && void 0 !== e._tenantRecaptchaConfigs[e.tenantId]) return e._tenantRecaptchaConfigs[e.tenantId].siteKey
                            }
                            return new Promise((async (t, n) => {
                                he(e, {
                                    clientType: "CLIENT_TYPE_WEB",
                                    version: "RECAPTCHA_ENTERPRISE"
                                }).then((r => {
                                    if (void 0 !== r.recaptchaKey) {
                                        const n = new me(r);
                                        return null == e.tenantId ? e._agentRecaptchaConfig = n : e._tenantRecaptchaConfigs[e.tenantId] = n, t(n.siteKey)
                                    }
                                    n(new Error("recaptcha Enterprise site key undefined"))
                                })).catch((e => {
                                    n(e)
                                }))
                            }))
                        })(this.auth).then((i => {
                            if (!t && fe(window.grecaptcha)) n(i, e, r);
                            else {
                                if ("undefined" == typeof window) return void r(new Error("RecaptchaVerifier is only supported in browser"));
                                ge("https://www.google.com/recaptcha/enterprise.js?render=" + i).then((() => {
                                    n(i, e, r)
                                })).catch((e => {
                                    r(e)
                                }))
                            }
                        })).catch((e => {
                            r(e)
                        }))
                    }))
                }
            }
            async function ye(e, t, n, r = !1) {
                const i = new ve(e);
                let o;
                try {
                    o = await i.verify(n)
                } catch (e) {
                    o = await i.verify(n, !0)
                }
                const s = Object.assign({}, t);
                return r ? Object.assign(s, {
                    captchaResp: o
                }) : Object.assign(s, {
                    captchaResponse: o
                }), Object.assign(s, {
                    clientType: "CLIENT_TYPE_WEB"
                }), Object.assign(s, {
                    recaptchaVersion: "RECAPTCHA_ENTERPRISE"
                }), s
            }
            /**
             * @license
             * Copyright 2022 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class be {
                constructor(e) {
                    this.auth = e, this.queue = []
                }
                pushCallback(e, t) {
                    const n = t => new Promise(((n, r) => {
                        try {
                            n(e(t))
                        } catch (e) {
                            r(e)
                        }
                    }));
                    n.onAbort = t, this.queue.push(n);
                    const r = this.queue.length - 1;
                    return () => {
                        this.queue[r] = () => Promise.resolve()
                    }
                }
                async runMiddleware(e) {
                    if (this.auth.currentUser === e) return;
                    const t = [];
                    try {
                        for (const n of this.queue) await n(e), n.onAbort && t.push(n.onAbort)
                    } catch (e) {
                        t.reverse();
                        for (const e of t) try {
                            e()
                        } catch (e) {}
                        throw this.auth._errorFactory.create("login-blocked", {
                            originalMessage: null == e ? void 0 : e.message
                        })
                    }
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ie {
                constructor(e, t, n, r) {
                    this.app = e, this.heartbeatServiceProvider = t, this.appCheckServiceProvider = n, this.config = r, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new Se(this), this.idTokenSubscription = new Se(this), this.beforeStateQueue = new be(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = d, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = {
                        appVerificationDisabledForTesting: !1
                    }, this.frameworks = [], this.name = e.name, this.clientVersion = r.sdkClientVersion
                }
                _initializeWithPersistence(e, t) {
                    return t && (this._popupRedirectResolver = J(t)), this._initializationPromise = this.queue((async () => {
                        var n, r;
                        if (!this._deleted && (this.persistenceManager = await ee.create(this, e), !this._deleted)) {
                            if (null === (n = this._popupRedirectResolver) || void 0 === n ? void 0 : n._shouldInitProactively) try {
                                await this._popupRedirectResolver._initialize(this)
                            } catch (e) {}
                            await this.initializeCurrentUser(t), this.lastNotifiedUid = (null === (r = this.currentUser) || void 0 === r ? void 0 : r.uid) || null, this._deleted || (this._isInitialized = !0)
                        }
                    })), this._initializationPromise
                }
                async _onStorageEvent() {
                    if (this._deleted) return;
                    const e = await this.assertedPersistence.getCurrentUser();
                    return this.currentUser || e ? this.currentUser && e && this.currentUser.uid === e.uid ? (this._currentUser._assign(e), void await this.currentUser.getIdToken()) : void await this._updateCurrentUser(e, !0) : void 0
                }
                async initializeCurrentUser(e) {
                    var t;
                    const n = await this.assertedPersistence.getCurrentUser();
                    let r = n,
                        i = !1;
                    if (e && this.config.authDomain) {
                        await this.getOrInitRedirectPersistenceManager();
                        const n = null === (t = this.redirectUser) || void 0 === t ? void 0 : t._redirectEventId,
                            o = null == r ? void 0 : r._redirectEventId,
                            s = await this.tryRedirectSignIn(e);
                        n && n !== o || !(null == s ? void 0 : s.user) || (r = s.user, i = !0)
                    }
                    if (!r) return this.directlySetCurrentUser(null);
                    if (!r._redirectEventId) {
                        if (i) try {
                            await this.beforeStateQueue.runMiddleware(r)
                        } catch (e) {
                            r = n, this._popupRedirectResolver._overrideRedirectResult(this, (() => Promise.reject(e)))
                        }
                        return r ? this.reloadAndSetCurrentUserOrClear(r) : this.directlySetCurrentUser(null)
                    }
                    return y(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === r._redirectEventId ? this.directlySetCurrentUser(r) : this.reloadAndSetCurrentUserOrClear(r)
                }
                async tryRedirectSignIn(e) {
                    let t = null;
                    try {
                        t = await this._popupRedirectResolver._completeRedirectFn(this, e, !0)
                    } catch (e) {
                        await this._setRedirectUser(null)
                    }
                    return t
                }
                async reloadAndSetCurrentUserOrClear(e) {
                    try {
                        await V(e)
                    } catch (e) {
                        if ("auth/network-request-failed" !== (null == e ? void 0 : e.code)) return this.directlySetCurrentUser(null)
                    }
                    return this.directlySetCurrentUser(e)
                }
                useDeviceLanguage() {
                    this.languageCode = function() {
                        if ("undefined" == typeof navigator) return null;
                        const e = navigator;
                        return e.languages && e.languages[0] || e.language || null
                    }()
                }
                async _delete() {
                    this._deleted = !0
                }
                async updateCurrentUser(e) {
                    const t = e ? r.getModularInstance(e) : null;
                    return t && y(t.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(t && t._clone(this))
                }
                async _updateCurrentUser(e, t = !1) {
                    if (!this._deleted) return e && y(this.tenantId === e.tenantId, this, "tenant-id-mismatch"), t || await this.beforeStateQueue.runMiddleware(e), this.queue((async () => {
                        await this.directlySetCurrentUser(e), this.notifyAuthListeners()
                    }))
                }
                async signOut() {
                    return await this.beforeStateQueue.runMiddleware(null), (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null, !0)
                }
                setPersistence(e) {
                    return this.queue((async () => {
                        await this.assertedPersistence.setPersistence(J(e))
                    }))
                }
                async initializeRecaptchaConfig() {
                    const e = await he(this, {
                            clientType: "CLIENT_TYPE_WEB",
                            version: "RECAPTCHA_ENTERPRISE"
                        }),
                        t = new me(e);
                    if (null == this.tenantId ? this._agentRecaptchaConfig = t : this._tenantRecaptchaConfigs[this.tenantId] = t, t.emailPasswordEnabled) {
                        new ve(this).verify()
                    }
                }
                _getRecaptchaConfig() {
                    return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
                }
                _getPersistence() {
                    return this.assertedPersistence.persistence.type
                }
                _updateErrorMap(e) {
                    this._errorFactory = new r.ErrorFactory("auth", "Firebase", e())
                }
                onAuthStateChanged(e, t, n) {
                    return this.registerStateListener(this.authStateSubscription, e, t, n)
                }
                beforeAuthStateChanged(e, t) {
                    return this.beforeStateQueue.pushCallback(e, t)
                }
                onIdTokenChanged(e, t, n) {
                    return this.registerStateListener(this.idTokenSubscription, e, t, n)
                }
                toJSON() {
                    var e;
                    return {
                        apiKey: this.config.apiKey,
                        authDomain: this.config.authDomain,
                        appName: this.name,
                        currentUser: null === (e = this._currentUser) || void 0 === e ? void 0 : e.toJSON()
                    }
                }
                async _setRedirectUser(e, t) {
                    const n = await this.getOrInitRedirectPersistenceManager(t);
                    return null === e ? n.removeCurrentUser() : n.setCurrentUser(e)
                }
                async getOrInitRedirectPersistenceManager(e) {
                    if (!this.redirectPersistenceManager) {
                        const t = e && J(e) || this._popupRedirectResolver;
                        y(t, this, "argument-error"), this.redirectPersistenceManager = await ee.create(this, [J(t._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
                    }
                    return this.redirectPersistenceManager
                }
                async _redirectUserForId(e) {
                    var t, n;
                    return this._isInitialized && await this.queue((async () => {})), (null === (t = this._currentUser) || void 0 === t ? void 0 : t._redirectEventId) === e ? this._currentUser : (null === (n = this.redirectUser) || void 0 === n ? void 0 : n._redirectEventId) === e ? this.redirectUser : null
                }
                async _persistUserIfCurrent(e) {
                    if (e === this.currentUser) return this.queue((async () => this.directlySetCurrentUser(e)))
                }
                _notifyListenersIfCurrent(e) {
                    e === this.currentUser && this.notifyAuthListeners()
                }
                _key() {
                    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
                }
                _startProactiveRefresh() {
                    this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh()
                }
                _stopProactiveRefresh() {
                    this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh()
                }
                get _currentUser() {
                    return this.currentUser
                }
                notifyAuthListeners() {
                    var e, t;
                    if (!this._isInitialized) return;
                    this.idTokenSubscription.next(this.currentUser);
                    const n = null !== (t = null === (e = this.currentUser) || void 0 === e ? void 0 : e.uid) && void 0 !== t ? t : null;
                    this.lastNotifiedUid !== n && (this.lastNotifiedUid = n, this.authStateSubscription.next(this.currentUser))
                }
                registerStateListener(e, t, n, r) {
                    if (this._deleted) return () => {};
                    const i = "function" == typeof t ? t : t.next.bind(t),
                        o = this._isInitialized ? Promise.resolve() : this._initializationPromise;
                    return y(o, this, "internal-error"), o.then((() => i(this.currentUser))), "function" == typeof t ? e.addObserver(t, n, r) : e.addObserver(t)
                }
                async directlySetCurrentUser(e) {
                    this.currentUser && this.currentUser !== e && this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh(), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser()
                }
                queue(e) {
                    return this.operations = this.operations.then(e, e), this.operations
                }
                get assertedPersistence() {
                    return y(this.persistenceManager, this, "internal-error"), this.persistenceManager
                }
                _logFramework(e) {
                    e && !this.frameworks.includes(e) && (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = de(this.config.clientPlatform, this._getFrameworks()))
                }
                _getFrameworks() {
                    return this.frameworks
                }
                async _getAdditionalHeaders() {
                    var e;
                    const t = {
                        "X-Client-Version": this.clientVersion
                    };
                    this.app.options.appId && (t["X-Firebase-gmpid"] = this.app.options.appId);
                    const n = await (null === (e = this.heartbeatServiceProvider.getImmediate({
                        optional: !0
                    })) || void 0 === e ? void 0 : e.getHeartbeatsHeader());
                    n && (t["X-Firebase-Client"] = n);
                    const r = await this._getAppCheckToken();
                    return r && (t["X-Firebase-AppCheck"] = r), t
                }
                async _getAppCheckToken() {
                    var e;
                    const t = await (null === (e = this.appCheckServiceProvider.getImmediate({
                        optional: !0
                    })) || void 0 === e ? void 0 : e.getToken());
                    return (null == t ? void 0 : t.error) && function(e, ...t) {
                        h.logLevel <= s.LogLevel.WARN && h.warn(`Auth (${i.SDK_VERSION}): ${e}`, ...t)
                    }(`Error while retrieving App Check token: ${t.error}`), null == t ? void 0 : t.token
                }
            }

            function Ee(e) {
                return r.getModularInstance(e)
            }
            class Se {
                constructor(e) {
                    this.auth = e, this.observer = null, this.addObserver = r.createSubscribe((e => this.observer = e))
                }
                get next() {
                    return y(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer)
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function we(e, t) {
                const n = i._getProvider(e, "auth");
                if (n.isInitialized()) {
                    const e = n.getImmediate(),
                        i = n.getOptions();
                    if (r.deepEqual(i, null != t ? t : {})) return e;
                    f(e, "already-initialized")
                }
                return n.initialize({
                    options: t
                })
            }

            function Ce(e, t, n) {
                const r = Ee(e);
                y(r._canInitEmulator, r, "emulator-config-failed"), y(/^https?:\/\//.test(t), r, "invalid-emulator-scheme");
                const i = !!(null == n ? void 0 : n.disableWarnings),
                    o = Te(t),
                    {
                        host: s,
                        port: a
                    } = function(e) {
                        const t = Te(e),
                            n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length));
                        if (!n) return {
                            host: "",
                            port: null
                        };
                        const r = n[2].split("@").pop() || "",
                            i = /^(\[[^\]]+\])(:|$)/.exec(r);
                        if (i) {
                            const e = i[1];
                            return {
                                host: e,
                                port: Ae(r.substr(e.length + 1))
                            }
                        } {
                            const [e, t] = r.split(":");
                            return {
                                host: e,
                                port: Ae(t)
                            }
                        }
                    }(t),
                    c = null === a ? "" : `:${a}`;
                r.config.emulator = {
                    url: `${o}//${s}${c}/`
                }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({
                    host: s,
                    port: a,
                    protocol: o.replace(":", ""),
                    options: Object.freeze({
                        disableWarnings: i
                    })
                }), i || function() {
                    function e() {
                        const e = document.createElement("p"),
                            t = e.style;
                        e.innerText = "Running in emulator mode. Do not use with production credentials.", t.position = "fixed", t.width = "100%", t.backgroundColor = "#ffffff", t.border = ".1em solid #000000", t.color = "#b50000", t.bottom = "0px", t.left = "0px", t.margin = "0px", t.zIndex = "10000", t.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e)
                    }
                    "undefined" != typeof console && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
                    "undefined" != typeof window && "undefined" != typeof document && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", e) : e())
                }
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                ()
            }

            function Te(e) {
                const t = e.indexOf(":");
                return t < 0 ? "" : e.substr(0, t + 1)
            }

            function Ae(e) {
                if (!e) return null;
                const t = Number(e);
                return isNaN(t) ? null : t
            }
            class Re {
                constructor(e, t) {
                    this.providerId = e, this.signInMethod = t
                }
                toJSON() {
                    return b("not implemented")
                }
                _getIdTokenResponse(e) {
                    return b("not implemented")
                }
                _linkToIdToken(e, t) {
                    return b("not implemented")
                }
                _getReauthenticationResolver(e) {
                    return b("not implemented")
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function Pe(e, t) {
                return k(e, "POST", "/v1/accounts:resetPassword", O(e, t))
            }
            async function Oe(e, t) {
                return k(e, "POST", "/v1/accounts:update", t)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function ke(e, t) {
                return D(e, "POST", "/v1/accounts:signInWithPassword", O(e, t))
            }
            async function Ne(e, t) {
                return k(e, "POST", "/v1/accounts:sendOobCode", O(e, t))
            }
            async function De(e, t) {
                return Ne(e, t)
            }
            async function Me(e, t) {
                return Ne(e, t)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class xe extends Re {
                constructor(e, t, n, r = null) {
                    super("password", n), this._email = e, this._password = t, this._tenantId = r
                }
                static _fromEmailAndPassword(e, t) {
                    return new xe(e, t, "password")
                }
                static _fromEmailAndCode(e, t, n = null) {
                    return new xe(e, t, "emailLink", n)
                }
                toJSON() {
                    return {
                        email: this._email,
                        password: this._password,
                        signInMethod: this.signInMethod,
                        tenantId: this._tenantId
                    }
                }
                static fromJSON(e) {
                    const t = "string" == typeof e ? JSON.parse(e) : e;
                    if ((null == t ? void 0 : t.email) && (null == t ? void 0 : t.password)) {
                        if ("password" === t.signInMethod) return this._fromEmailAndPassword(t.email, t.password);
                        if ("emailLink" === t.signInMethod) return this._fromEmailAndCode(t.email, t.password, t.tenantId)
                    }
                    return null
                }
                async _getIdTokenResponse(e) {
                    var t;
                    switch (this.signInMethod) {
                        case "password":
                            const n = {
                                returnSecureToken: !0,
                                email: this._email,
                                password: this._password,
                                clientType: "CLIENT_TYPE_WEB"
                            };
                            if (null === (t = e._getRecaptchaConfig()) || void 0 === t ? void 0 : t.emailPasswordEnabled) {
                                const t = await ye(e, n, "signInWithPassword");
                                return ke(e, t)
                            }
                            return ke(e, n).catch((async t => {
                                if ("auth/missing-recaptcha-token" === t.code) {
                                    console.log("Sign-in with email address and password is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.");
                                    const t = await ye(e, n, "signInWithPassword");
                                    return ke(e, t)
                                }
                                return Promise.reject(t)
                            }));
                        case "emailLink":
                            /**
                             * @license
                             * Copyright 2020 Google LLC
                             *
                             * Licensed under the Apache License, Version 2.0 (the "License");
                             * you may not use this file except in compliance with the License.
                             * You may obtain a copy of the License at
                             *
                             *   http://www.apache.org/licenses/LICENSE-2.0
                             *
                             * Unless required by applicable law or agreed to in writing, software
                             * distributed under the License is distributed on an "AS IS" BASIS,
                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                             * See the License for the specific language governing permissions and
                             * limitations under the License.
                             */
                            return async function(e, t) {
                                return D(e, "POST", "/v1/accounts:signInWithEmailLink", O(e, t))
                            }(e, {
                                email: this._email,
                                oobCode: this._password
                            });
                        default:
                            f(e, "internal-error")
                    }
                }
                async _linkToIdToken(e, t) {
                    switch (this.signInMethod) {
                        case "password":
                            return Oe(e, {
                                idToken: t,
                                returnSecureToken: !0,
                                email: this._email,
                                password: this._password
                            });
                        case "emailLink":
                            return async function(e, t) {
                                return D(e, "POST", "/v1/accounts:signInWithEmailLink", O(e, t))
                            }(e, {
                                idToken: t,
                                email: this._email,
                                oobCode: this._password
                            });
                        default:
                            f(e, "internal-error")
                    }
                }
                _getReauthenticationResolver(e) {
                    return this._getIdTokenResponse(e)
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function Le(e, t) {
                return D(e, "POST", "/v1/accounts:signInWithIdp", O(e, t))
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ue extends Re {
                constructor() {
                    super(...arguments), this.pendingToken = null
                }
                static _fromParams(e) {
                    const t = new Ue(e.providerId, e.signInMethod);
                    return e.idToken || e.accessToken ? (e.idToken && (t.idToken = e.idToken), e.accessToken && (t.accessToken = e.accessToken), e.nonce && !e.pendingToken && (t.nonce = e.nonce), e.pendingToken && (t.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (t.accessToken = e.oauthToken, t.secret = e.oauthTokenSecret) : f("argument-error"), t
                }
                toJSON() {
                    return {
                        idToken: this.idToken,
                        accessToken: this.accessToken,
                        secret: this.secret,
                        nonce: this.nonce,
                        pendingToken: this.pendingToken,
                        providerId: this.providerId,
                        signInMethod: this.signInMethod
                    }
                }
                static fromJSON(e) {
                    const t = "string" == typeof e ? JSON.parse(e) : e,
                        {
                            providerId: n,
                            signInMethod: r
                        } = t,
                        i = o.__rest(t, ["providerId", "signInMethod"]);
                    if (!n || !r) return null;
                    const s = new Ue(n, r);
                    return s.idToken = i.idToken || void 0, s.accessToken = i.accessToken || void 0, s.secret = i.secret, s.nonce = i.nonce, s.pendingToken = i.pendingToken || null, s
                }
                _getIdTokenResponse(e) {
                    return Le(e, this.buildRequest())
                }
                _linkToIdToken(e, t) {
                    const n = this.buildRequest();
                    return n.idToken = t, Le(e, n)
                }
                _getReauthenticationResolver(e) {
                    const t = this.buildRequest();
                    return t.autoCreate = !1, Le(e, t)
                }
                buildRequest() {
                    const e = {
                        requestUri: "http://localhost",
                        returnSecureToken: !0
                    };
                    if (this.pendingToken) e.pendingToken = this.pendingToken;
                    else {
                        const t = {};
                        this.idToken && (t.id_token = this.idToken), this.accessToken && (t.access_token = this.accessToken), this.secret && (t.oauth_token_secret = this.secret), t.providerId = this.providerId, this.nonce && !this.pendingToken && (t.nonce = this.nonce), e.postBody = r.querystring(t)
                    }
                    return e
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Fe = {
                USER_NOT_FOUND: "user-not-found"
            };
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class je extends Re {
                constructor(e) {
                    super("phone", "phone"), this.params = e
                }
                static _fromVerification(e, t) {
                    return new je({
                        verificationId: e,
                        verificationCode: t
                    })
                }
                static _fromTokenResponse(e, t) {
                    return new je({
                        phoneNumber: e,
                        temporaryProof: t
                    })
                }
                _getIdTokenResponse(e) {
                    return async function(e, t) {
                        return D(e, "POST", "/v1/accounts:signInWithPhoneNumber", O(e, t))
                    }(e, this._makeVerificationRequest())
                }
                _linkToIdToken(e, t) {
                    return async function(e, t) {
                        const n = await D(e, "POST", "/v1/accounts:signInWithPhoneNumber", O(e, t));
                        if (n.temporaryProof) throw L(e, "account-exists-with-different-credential", n);
                        return n
                    }(e, Object.assign({
                        idToken: t
                    }, this._makeVerificationRequest()))
                }
                _getReauthenticationResolver(e) {
                    return async function(e, t) {
                        return D(e, "POST", "/v1/accounts:signInWithPhoneNumber", O(e, Object.assign(Object.assign({}, t), {
                            operation: "REAUTH"
                        })), Fe)
                    }(e, this._makeVerificationRequest())
                }
                _makeVerificationRequest() {
                    const {
                        temporaryProof: e,
                        phoneNumber: t,
                        verificationId: n,
                        verificationCode: r
                    } = this.params;
                    return e && t ? {
                        temporaryProof: e,
                        phoneNumber: t
                    } : {
                        sessionInfo: n,
                        code: r
                    }
                }
                toJSON() {
                    const e = {
                        providerId: this.providerId
                    };
                    return this.params.phoneNumber && (e.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (e.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (e.verificationCode = this.params.verificationCode), this.params.verificationId && (e.verificationId = this.params.verificationId), e
                }
                static fromJSON(e) {
                    "string" == typeof e && (e = JSON.parse(e));
                    const {
                        verificationId: t,
                        verificationCode: n,
                        phoneNumber: r,
                        temporaryProof: i
                    } = e;
                    return n || t || r || i ? new je({
                        verificationId: t,
                        verificationCode: n,
                        phoneNumber: r,
                        temporaryProof: i
                    }) : null
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class qe {
                constructor(e) {
                    var t, n, i, o, s, a;
                    const c = r.querystringDecode(r.extractQuerystring(e)),
                        u = null !== (t = c.apiKey) && void 0 !== t ? t : null,
                        l = null !== (n = c.oobCode) && void 0 !== n ? n : null,
                        d = function(e) {
                            switch (e) {
                                case "recoverEmail":
                                    return "RECOVER_EMAIL";
                                case "resetPassword":
                                    return "PASSWORD_RESET";
                                case "signIn":
                                    return "EMAIL_SIGNIN";
                                case "verifyEmail":
                                    return "VERIFY_EMAIL";
                                case "verifyAndChangeEmail":
                                    return "VERIFY_AND_CHANGE_EMAIL";
                                case "revertSecondFactorAddition":
                                    return "REVERT_SECOND_FACTOR_ADDITION";
                                default:
                                    return null
                            }
                        }(null !== (i = c.mode) && void 0 !== i ? i : null);
                    y(u && l && d, "argument-error"), this.apiKey = u, this.operation = d, this.code = l, this.continueUrl = null !== (o = c.continueUrl) && void 0 !== o ? o : null, this.languageCode = null !== (s = c.languageCode) && void 0 !== s ? s : null, this.tenantId = null !== (a = c.tenantId) && void 0 !== a ? a : null
                }
                static parseLink(e) {
                    const t = function(e) {
                        const t = r.querystringDecode(r.extractQuerystring(e)).link,
                            n = t ? r.querystringDecode(r.extractQuerystring(t)).deep_link_id : null,
                            i = r.querystringDecode(r.extractQuerystring(e)).deep_link_id;
                        return (i ? r.querystringDecode(r.extractQuerystring(i)).link : null) || i || n || t || e
                    }(e);
                    try {
                        return new qe(t)
                    } catch (e) {
                        return null
                    }
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class He {
                constructor() {
                    this.providerId = He.PROVIDER_ID
                }
                static credential(e, t) {
                    return xe._fromEmailAndPassword(e, t)
                }
                static credentialWithLink(e, t) {
                    const n = qe.parseLink(t);
                    return y(n, "argument-error"), xe._fromEmailAndCode(e, n.code, n.tenantId)
                }
            }
            He.PROVIDER_ID = "password", He.EMAIL_PASSWORD_SIGN_IN_METHOD = "password", He.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class We {
                constructor(e) {
                    this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {}
                }
                setDefaultLanguage(e) {
                    this.defaultLanguageCode = e
                }
                setCustomParameters(e) {
                    return this.customParameters = e, this
                }
                getCustomParameters() {
                    return this.customParameters
                }
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Be extends We {
                constructor() {
                    super(...arguments), this.scopes = []
                }
                addScope(e) {
                    return this.scopes.includes(e) || this.scopes.push(e), this
                }
                getScopes() {
                    return [...this.scopes]
                }
            }
            class Ve extends Be {
                static credentialFromJSON(e) {
                    const t = "string" == typeof e ? JSON.parse(e) : e;
                    return y("providerId" in t && "signInMethod" in t, "argument-error"), Ue._fromParams(t)
                }
                credential(e) {
                    return this._credential(Object.assign(Object.assign({}, e), {
                        nonce: e.rawNonce
                    }))
                }
                _credential(e) {
                    return y(e.idToken || e.accessToken, "argument-error"), Ue._fromParams(Object.assign(Object.assign({}, e), {
                        providerId: this.providerId,
                        signInMethod: this.providerId
                    }))
                }
                static credentialFromResult(e) {
                    return Ve.oauthCredentialFromTaggedObject(e)
                }
                static credentialFromError(e) {
                    return Ve.oauthCredentialFromTaggedObject(e.customData || {})
                }
                static oauthCredentialFromTaggedObject({
                    _tokenResponse: e
                }) {
                    if (!e) return null;
                    const {
                        oauthIdToken: t,
                        oauthAccessToken: n,
                        oauthTokenSecret: r,
                        pendingToken: i,
                        nonce: o,
                        providerId: s
                    } = e;
                    if (!(n || r || t || i)) return null;
                    if (!s) return null;
                    try {
                        return new Ve(s)._credential({
                            idToken: t,
                            accessToken: n,
                            nonce: o,
                            pendingToken: i
                        })
                    } catch (e) {
                        return null
                    }
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ge extends Be {
                constructor() {
                    super("facebook.com")
                }
                static credential(e) {
                    return Ue._fromParams({
                        providerId: Ge.PROVIDER_ID,
                        signInMethod: Ge.FACEBOOK_SIGN_IN_METHOD,
                        accessToken: e
                    })
                }
                static credentialFromResult(e) {
                    return Ge.credentialFromTaggedObject(e)
                }
                static credentialFromError(e) {
                    return Ge.credentialFromTaggedObject(e.customData || {})
                }
                static credentialFromTaggedObject({
                    _tokenResponse: e
                }) {
                    if (!e || !("oauthAccessToken" in e)) return null;
                    if (!e.oauthAccessToken) return null;
                    try {
                        return Ge.credential(e.oauthAccessToken)
                    } catch (e) {
                        return null
                    }
                }
            }
            Ge.FACEBOOK_SIGN_IN_METHOD = "facebook.com", Ge.PROVIDER_ID = "facebook.com";
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class ze extends Be {
                constructor() {
                    super("google.com"), this.addScope("profile")
                }
                static credential(e, t) {
                    return Ue._fromParams({
                        providerId: ze.PROVIDER_ID,
                        signInMethod: ze.GOOGLE_SIGN_IN_METHOD,
                        idToken: e,
                        accessToken: t
                    })
                }
                static credentialFromResult(e) {
                    return ze.credentialFromTaggedObject(e)
                }
                static credentialFromError(e) {
                    return ze.credentialFromTaggedObject(e.customData || {})
                }
                static credentialFromTaggedObject({
                    _tokenResponse: e
                }) {
                    if (!e) return null;
                    const {
                        oauthIdToken: t,
                        oauthAccessToken: n
                    } = e;
                    if (!t && !n) return null;
                    try {
                        return ze.credential(t, n)
                    } catch (e) {
                        return null
                    }
                }
            }
            ze.GOOGLE_SIGN_IN_METHOD = "google.com", ze.PROVIDER_ID = "google.com";
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class $e extends Be {
                constructor() {
                    super("github.com")
                }
                static credential(e) {
                    return Ue._fromParams({
                        providerId: $e.PROVIDER_ID,
                        signInMethod: $e.GITHUB_SIGN_IN_METHOD,
                        accessToken: e
                    })
                }
                static credentialFromResult(e) {
                    return $e.credentialFromTaggedObject(e)
                }
                static credentialFromError(e) {
                    return $e.credentialFromTaggedObject(e.customData || {})
                }
                static credentialFromTaggedObject({
                    _tokenResponse: e
                }) {
                    if (!e || !("oauthAccessToken" in e)) return null;
                    if (!e.oauthAccessToken) return null;
                    try {
                        return $e.credential(e.oauthAccessToken)
                    } catch (e) {
                        return null
                    }
                }
            }
            $e.GITHUB_SIGN_IN_METHOD = "github.com", $e.PROVIDER_ID = "github.com";
            class Ke extends Re {
                constructor(e, t) {
                    super(e, e), this.pendingToken = t
                }
                _getIdTokenResponse(e) {
                    return Le(e, this.buildRequest())
                }
                _linkToIdToken(e, t) {
                    const n = this.buildRequest();
                    return n.idToken = t, Le(e, n)
                }
                _getReauthenticationResolver(e) {
                    const t = this.buildRequest();
                    return t.autoCreate = !1, Le(e, t)
                }
                toJSON() {
                    return {
                        signInMethod: this.signInMethod,
                        providerId: this.providerId,
                        pendingToken: this.pendingToken
                    }
                }
                static fromJSON(e) {
                    const t = "string" == typeof e ? JSON.parse(e) : e,
                        {
                            providerId: n,
                            signInMethod: r,
                            pendingToken: i
                        } = t;
                    return n && r && i && n === r ? new Ke(n, i) : null
                }
                static _create(e, t) {
                    return new Ke(e, t)
                }
                buildRequest() {
                    return {
                        requestUri: "http://localhost",
                        returnSecureToken: !0,
                        pendingToken: this.pendingToken
                    }
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ye extends We {
                constructor(e) {
                    y(e.startsWith("saml."), "argument-error"), super(e)
                }
                static credentialFromResult(e) {
                    return Ye.samlCredentialFromTaggedObject(e)
                }
                static credentialFromError(e) {
                    return Ye.samlCredentialFromTaggedObject(e.customData || {})
                }
                static credentialFromJSON(e) {
                    const t = Ke.fromJSON(e);
                    return y(t, "argument-error"), t
                }
                static samlCredentialFromTaggedObject({
                    _tokenResponse: e
                }) {
                    if (!e) return null;
                    const {
                        pendingToken: t,
                        providerId: n
                    } = e;
                    if (!t || !n) return null;
                    try {
                        return Ke._create(n, t)
                    } catch (e) {
                        return null
                    }
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Je extends Be {
                constructor() {
                    super("twitter.com")
                }
                static credential(e, t) {
                    return Ue._fromParams({
                        providerId: Je.PROVIDER_ID,
                        signInMethod: Je.TWITTER_SIGN_IN_METHOD,
                        oauthToken: e,
                        oauthTokenSecret: t
                    })
                }
                static credentialFromResult(e) {
                    return Je.credentialFromTaggedObject(e)
                }
                static credentialFromError(e) {
                    return Je.credentialFromTaggedObject(e.customData || {})
                }
                static credentialFromTaggedObject({
                    _tokenResponse: e
                }) {
                    if (!e) return null;
                    const {
                        oauthAccessToken: t,
                        oauthTokenSecret: n
                    } = e;
                    if (!t || !n) return null;
                    try {
                        return Je.credential(t, n)
                    } catch (e) {
                        return null
                    }
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function Qe(e, t) {
                return D(e, "POST", "/v1/accounts:signUp", O(e, t))
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            Je.TWITTER_SIGN_IN_METHOD = "twitter.com", Je.PROVIDER_ID = "twitter.com";
            class Xe {
                constructor(e) {
                    this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType
                }
                static async _fromIdTokenResponse(e, t, n, r = !1) {
                    const i = await K._fromIdTokenResponse(e, n, r),
                        o = Ze(n);
                    return new Xe({
                        user: i,
                        providerId: o,
                        _tokenResponse: n,
                        operationType: t
                    })
                }
                static async _forOperation(e, t, n) {
                    await e._updateTokensIfNecessary(n, !0);
                    const r = Ze(n);
                    return new Xe({
                        user: e,
                        providerId: r,
                        _tokenResponse: n,
                        operationType: t
                    })
                }
            }

            function Ze(e) {
                return e.providerId ? e.providerId : "phoneNumber" in e ? "phone" : null
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class et extends r.FirebaseError {
                constructor(e, t, n, r) {
                    var i;
                    super(t.code, t.message), this.operationType = n, this.user = r, Object.setPrototypeOf(this, et.prototype), this.customData = {
                        appName: e.name,
                        tenantId: null !== (i = e.tenantId) && void 0 !== i ? i : void 0,
                        _serverResponse: t.customData._serverResponse,
                        operationType: n
                    }
                }
                static _fromErrorAndOperation(e, t, n, r) {
                    return new et(e, t, n, r)
                }
            }

            function tt(e, t, n, r) {
                return ("reauthenticate" === t ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch((n => {
                    if ("auth/multi-factor-auth-required" === n.code) throw et._fromErrorAndOperation(e, n, t, r);
                    throw n
                }))
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function nt(e) {
                return new Set(e.map((({
                    providerId: e
                }) => e)).filter((e => !!e)))
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function rt(e, t, n = !1) {
                const r = await H(e, t._linkToIdToken(e.auth, await e.getIdToken()), n);
                return Xe._forOperation(e, "link", r)
            }
            async function it(e, t, n) {
                await V(t);
                const r = !1 === e ? "provider-already-linked" : "no-such-provider";
                y(nt(t.providerData).has(n) === e, t.auth, r)
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function ot(e, t, n = !1) {
                const {
                    auth: r
                } = e, i = "reauthenticate";
                try {
                    const o = await H(e, tt(r, i, t, e), n);
                    y(o.idToken, r, "internal-error");
                    const s = q(o.idToken);
                    y(s, r, "internal-error");
                    const {
                        sub: a
                    } = s;
                    return y(e.uid === a, r, "user-mismatch"), Xe._forOperation(e, i, o)
                } catch (e) {
                    throw "auth/user-not-found" === (null == e ? void 0 : e.code) && f(r, "user-mismatch"), e
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function st(e, t, n = !1) {
                const r = "signIn",
                    i = await tt(e, r, t),
                    o = await Xe._fromIdTokenResponse(e, r, i);
                return n || await e._updateCurrentUser(o.user), o
            }
            async function at(e, t) {
                return st(Ee(e), t)
            }
            async function ct(e, t) {
                const n = r.getModularInstance(e);
                return await it(!1, n, t.providerId), rt(n, t)
            }
            async function ut(e, t) {
                return ot(r.getModularInstance(e), t)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class lt {
                constructor(e, t) {
                    this.factorId = e, this.uid = t.mfaEnrollmentId, this.enrollmentTime = new Date(t.enrolledAt).toUTCString(), this.displayName = t.displayName
                }
                static _fromServerResponse(e, t) {
                    return "phoneInfo" in t ? dt._fromServerResponse(e, t) : "totpInfo" in t ? ht._fromServerResponse(e, t) : f(e, "internal-error")
                }
            }
            class dt extends lt {
                constructor(e) {
                    super("phone", e), this.phoneNumber = e.phoneInfo
                }
                static _fromServerResponse(e, t) {
                    return new dt(t)
                }
            }
            class ht extends lt {
                constructor(e) {
                    super("totp", e)
                }
                static _fromServerResponse(e, t) {
                    return new ht(t)
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function pt(e, t, n) {
                var r;
                y((null === (r = n.url) || void 0 === r ? void 0 : r.length) > 0, e, "invalid-continue-uri"), y(void 0 === n.dynamicLinkDomain || n.dynamicLinkDomain.length > 0, e, "invalid-dynamic-link-domain"), t.continueUrl = n.url, t.dynamicLinkDomain = n.dynamicLinkDomain, t.canHandleCodeInApp = n.handleCodeInApp, n.iOS && (y(n.iOS.bundleId.length > 0, e, "missing-ios-bundle-id"), t.iOSBundleId = n.iOS.bundleId), n.android && (y(n.android.packageName.length > 0, e, "missing-android-pkg-name"), t.androidInstallApp = n.android.installApp, t.androidMinimumVersionCode = n.android.minimumVersion, t.androidPackageName = n.android.packageName)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function ft(e, t) {
                const n = r.getModularInstance(e),
                    i = await Pe(n, {
                        oobCode: t
                    }),
                    o = i.requestType;
                switch (y(o, n, "internal-error"), o) {
                    case "EMAIL_SIGNIN":
                        break;
                    case "VERIFY_AND_CHANGE_EMAIL":
                        y(i.newEmail, n, "internal-error");
                        break;
                    case "REVERT_SECOND_FACTOR_ADDITION":
                        y(i.mfaInfo, n, "internal-error");
                    default:
                        y(i.email, n, "internal-error")
                }
                let s = null;
                return i.mfaInfo && (s = lt._fromServerResponse(Ee(n), i.mfaInfo)), {
                    data: {
                        email: ("VERIFY_AND_CHANGE_EMAIL" === i.requestType ? i.newEmail : i.email) || null,
                        previousEmail: ("VERIFY_AND_CHANGE_EMAIL" === i.requestType ? i.email : i.newEmail) || null,
                        multiFactorInfo: s
                    },
                    operation: o
                }
            }
            async function mt(e, t, n) {
                const {
                    auth: r
                } = e, i = {
                    idToken: await e.getIdToken(),
                    returnSecureToken: !0
                };
                t && (i.email = t), n && (i.password = n);
                const o = await H(e, Oe(r, i));
                await e._updateTokensIfNecessary(o, !0)
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class gt {
                constructor(e, t, n = {}) {
                    this.isNewUser = e, this.providerId = t, this.profile = n
                }
            }
            class _t extends gt {
                constructor(e, t, n, r) {
                    super(e, t, n), this.username = r
                }
            }
            class vt extends gt {
                constructor(e, t) {
                    super(e, "facebook.com", t)
                }
            }
            class yt extends _t {
                constructor(e, t) {
                    super(e, "github.com", t, "string" == typeof(null == t ? void 0 : t.login) ? null == t ? void 0 : t.login : null)
                }
            }
            class bt extends gt {
                constructor(e, t) {
                    super(e, "google.com", t)
                }
            }
            class It extends _t {
                constructor(e, t, n) {
                    super(e, "twitter.com", t, n)
                }
            }

            function Et(e, t, n, i) {
                return r.getModularInstance(e).onIdTokenChanged(t, n, i)
            }

            function St(e, t, n) {
                return r.getModularInstance(e).beforeAuthStateChanged(t, n)
            }
            class wt {
                constructor(e, t, n) {
                    this.type = e, this.credential = t, this.auth = n
                }
                static _fromIdtoken(e, t) {
                    return new wt("enroll", e, t)
                }
                static _fromMfaPendingCredential(e) {
                    return new wt("signin", e)
                }
                toJSON() {
                    return {
                        multiFactorSession: {
                            ["enroll" === this.type ? "idToken" : "pendingCredential"]: this.credential
                        }
                    }
                }
                static fromJSON(e) {
                    var t, n;
                    if (null == e ? void 0 : e.multiFactorSession) {
                        if (null === (t = e.multiFactorSession) || void 0 === t ? void 0 : t.pendingCredential) return wt._fromMfaPendingCredential(e.multiFactorSession.pendingCredential);
                        if (null === (n = e.multiFactorSession) || void 0 === n ? void 0 : n.idToken) return wt._fromIdtoken(e.multiFactorSession.idToken)
                    }
                    return null
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ct {
                constructor(e, t, n) {
                    this.session = e, this.hints = t, this.signInResolver = n
                }
                static _fromError(e, t) {
                    const n = Ee(e),
                        r = t.customData._serverResponse,
                        i = (r.mfaInfo || []).map((e => lt._fromServerResponse(n, e)));
                    y(r.mfaPendingCredential, n, "internal-error");
                    const o = wt._fromMfaPendingCredential(r.mfaPendingCredential);
                    return new Ct(o, i, (async e => {
                        const i = await e._process(n, o);
                        delete r.mfaInfo, delete r.mfaPendingCredential;
                        const s = Object.assign(Object.assign({}, r), {
                            idToken: i.idToken,
                            refreshToken: i.refreshToken
                        });
                        switch (t.operationType) {
                            case "signIn":
                                const e = await Xe._fromIdTokenResponse(n, t.operationType, s);
                                return await n._updateCurrentUser(e.user), e;
                            case "reauthenticate":
                                return y(t.user, n, "internal-error"), Xe._forOperation(t.user, t.operationType, s);
                            default:
                                f(n, "internal-error")
                        }
                    }))
                }
                async resolveSignIn(e) {
                    const t = e;
                    return this.signInResolver(t)
                }
            }
            class Tt {
                constructor(e) {
                    this.user = e, this.enrolledFactors = [], e._onReload((t => {
                        t.mfaInfo && (this.enrolledFactors = t.mfaInfo.map((t => lt._fromServerResponse(e.auth, t))))
                    }))
                }
                static _fromUser(e) {
                    return new Tt(e)
                }
                async getSession() {
                    return wt._fromIdtoken(await this.user.getIdToken(), this.user.auth)
                }
                async enroll(e, t) {
                    const n = e,
                        r = await this.getSession(),
                        i = await H(this.user, n._process(this.user.auth, r, t));
                    return await this.user._updateTokensIfNecessary(i), this.user.reload()
                }
                async unenroll(e) {
                    const t = "string" == typeof e ? e : e.uid,
                        n = await this.user.getIdToken();
                    try {
                        const e = await H(this.user, (r = this.user.auth, i = {
                            idToken: n,
                            mfaEnrollmentId: t
                        }, k(r, "POST", "/v2/accounts/mfaEnrollment:withdraw", O(r, i))));
                        this.enrolledFactors = this.enrolledFactors.filter((({
                            uid: e
                        }) => e !== t)), await this.user._updateTokensIfNecessary(e), await this.user.reload()
                    } catch (e) {
                        throw e
                    }
                    var r, i
                }
            }
            const At = new WeakMap;
            const Rt = "__sak";
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Pt {
                constructor(e, t) {
                    this.storageRetriever = e, this.type = t
                }
                _isAvailable() {
                    try {
                        return this.storage ? (this.storage.setItem(Rt, "1"), this.storage.removeItem(Rt), Promise.resolve(!0)) : Promise.resolve(!1)
                    } catch (e) {
                        return Promise.resolve(!1)
                    }
                }
                _set(e, t) {
                    return this.storage.setItem(e, JSON.stringify(t)), Promise.resolve()
                }
                _get(e) {
                    const t = this.storage.getItem(e);
                    return Promise.resolve(t ? JSON.parse(t) : null)
                }
                _remove(e) {
                    return this.storage.removeItem(e), Promise.resolve()
                }
                get storage() {
                    return this.storageRetriever()
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ot extends Pt {
                constructor() {
                    super((() => window.localStorage), "LOCAL"), this.boundEventHandler = (e, t) => this.onStorageEvent(e, t), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = function() {
                        const e = r.getUA();
                        return re(e) || ue(e)
                    }() && function() {
                        try {
                            return !(!window || window === window.top)
                        } catch (e) {
                            return !1
                        }
                    }(), this.fallbackToPolling = le(), this._shouldAllowMigration = !0
                }
                forAllChangedKeys(e) {
                    for (const t of Object.keys(this.listeners)) {
                        const n = this.storage.getItem(t),
                            r = this.localCache[t];
                        n !== r && e(t, r, n)
                    }
                }
                onStorageEvent(e, t = !1) {
                    if (!e.key) return void this.forAllChangedKeys(((e, t, n) => {
                        this.notifyListeners(e, n)
                    }));
                    const n = e.key;
                    if (t ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) {
                        const r = this.storage.getItem(n);
                        if (e.newValue !== r) null !== e.newValue ? this.storage.setItem(n, e.newValue) : this.storage.removeItem(n);
                        else if (this.localCache[n] === e.newValue && !t) return
                    }
                    const i = () => {
                            const e = this.storage.getItem(n);
                            (t || this.localCache[n] !== e) && this.notifyListeners(n, e)
                        },
                        o = this.storage.getItem(n);
                    r.isIE() && 10 === document.documentMode && o !== e.newValue && e.newValue !== e.oldValue ? setTimeout(i, 10) : i()
                }
                notifyListeners(e, t) {
                    this.localCache[e] = t;
                    const n = this.listeners[e];
                    if (n)
                        for (const e of Array.from(n)) e(t ? JSON.parse(t) : t)
                }
                startPolling() {
                    this.stopPolling(), this.pollTimer = setInterval((() => {
                        this.forAllChangedKeys(((e, t, n) => {
                            this.onStorageEvent(new StorageEvent("storage", {
                                key: e,
                                oldValue: t,
                                newValue: n
                            }), !0)
                        }))
                    }), 1e3)
                }
                stopPolling() {
                    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
                }
                attachListener() {
                    window.addEventListener("storage", this.boundEventHandler)
                }
                detachListener() {
                    window.removeEventListener("storage", this.boundEventHandler)
                }
                _addListener(e, t) {
                    0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = new Set, this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(t)
                }
                _removeListener(e, t) {
                    this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling())
                }
                async _set(e, t) {
                    await super._set(e, t), this.localCache[e] = JSON.stringify(t)
                }
                async _get(e) {
                    const t = await super._get(e);
                    return this.localCache[e] = JSON.stringify(t), t
                }
                async _remove(e) {
                    await super._remove(e), delete this.localCache[e]
                }
            }
            Ot.type = "LOCAL";
            const kt = Ot;
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Nt extends Pt {
                constructor() {
                    super((() => window.sessionStorage), "SESSION")
                }
                _addListener(e, t) {}
                _removeListener(e, t) {}
            }
            Nt.type = "SESSION";
            const Dt = Nt;
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Mt {
                constructor(e) {
                    this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this)
                }
                static _getInstance(e) {
                    const t = this.receivers.find((t => t.isListeningto(e)));
                    if (t) return t;
                    const n = new Mt(e);
                    return this.receivers.push(n), n
                }
                isListeningto(e) {
                    return this.eventTarget === e
                }
                async handleEvent(e) {
                    const t = e,
                        {
                            eventId: n,
                            eventType: r,
                            data: i
                        } = t.data,
                        o = this.handlersMap[r];
                    if (!(null == o ? void 0 : o.size)) return;
                    t.ports[0].postMessage({
                        status: "ack",
                        eventId: n,
                        eventType: r
                    });
                    const s = Array.from(o).map((async e => e(t.origin, i))),
                        a = await
                    function(e) {
                        return Promise.all(e.map((async e => {
                            try {
                                return {
                                    fulfilled: !0,
                                    value: await e
                                }
                            } catch (e) {
                                return {
                                    fulfilled: !1,
                                    reason: e
                                }
                            }
                        })))
                    }(s);
                    t.ports[0].postMessage({
                        status: "done",
                        eventId: n,
                        eventType: r,
                        response: a
                    })
                }
                _subscribe(e, t) {
                    0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = new Set), this.handlersMap[e].add(t)
                }
                _unsubscribe(e, t) {
                    this.handlersMap[e] && t && this.handlersMap[e].delete(t), t && 0 !== this.handlersMap[e].size || delete this.handlersMap[e], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler)
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function xt(e = "", t = 10) {
                let n = "";
                for (let e = 0; e < t; e++) n += Math.floor(10 * Math.random());
                return e + n
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            Mt.receivers = [];
            class Lt {
                constructor(e) {
                    this.target = e, this.handlers = new Set
                }
                removeMessageHandler(e) {
                    e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e)
                }
                async _send(e, t, n = 50) {
                    const r = "undefined" != typeof MessageChannel ? new MessageChannel : null;
                    if (!r) throw new Error("connection_unavailable");
                    let i, o;
                    return new Promise(((s, a) => {
                        const c = xt("", 20);
                        r.port1.start();
                        const u = setTimeout((() => {
                            a(new Error("unsupported_event"))
                        }), n);
                        o = {
                            messageChannel: r,
                            onMessage(e) {
                                const t = e;
                                if (t.data.eventId === c) switch (t.data.status) {
                                    case "ack":
                                        clearTimeout(u), i = setTimeout((() => {
                                            a(new Error("timeout"))
                                        }), 3e3);
                                        break;
                                    case "done":
                                        clearTimeout(i), s(t.data.response);
                                        break;
                                    default:
                                        clearTimeout(u), clearTimeout(i), a(new Error("invalid_response"))
                                }
                            }
                        }, this.handlers.add(o), r.port1.addEventListener("message", o.onMessage), this.target.postMessage({
                            eventType: e,
                            eventId: c,
                            data: t
                        }, [r.port2])
                    })).finally((() => {
                        o && this.removeMessageHandler(o)
                    }))
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function Ut() {
                return window
            }
            /**
             * @license
             * Copyright 2020 Google LLC.
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function Ft() {
                return void 0 !== Ut().WorkerGlobalScope && "function" == typeof Ut().importScripts
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const jt = "firebaseLocalStorageDb",
                qt = "firebaseLocalStorage",
                Ht = "fbase_key";
            class Wt {
                constructor(e) {
                    this.request = e
                }
                toPromise() {
                    return new Promise(((e, t) => {
                        this.request.addEventListener("success", (() => {
                            e(this.request.result)
                        })), this.request.addEventListener("error", (() => {
                            t(this.request.error)
                        }))
                    }))
                }
            }

            function Bt(e, t) {
                return e.transaction([qt], t ? "readwrite" : "readonly").objectStore(qt)
            }

            function Vt() {
                const e = indexedDB.open(jt, 1);
                return new Promise(((t, n) => {
                    e.addEventListener("error", (() => {
                        n(e.error)
                    })), e.addEventListener("upgradeneeded", (() => {
                        const t = e.result;
                        try {
                            t.createObjectStore(qt, {
                                keyPath: Ht
                            })
                        } catch (e) {
                            n(e)
                        }
                    })), e.addEventListener("success", (async () => {
                        const n = e.result;
                        n.objectStoreNames.contains(qt) ? t(n) : (n.close(), await
                            function() {
                                const e = indexedDB.deleteDatabase(jt);
                                return new Wt(e).toPromise()
                            }(), t(await Vt()))
                    }))
                }))
            }
            async function Gt(e, t, n) {
                const r = Bt(e, !0).put({
                    [Ht]: t,
                    value: n
                });
                return new Wt(r).toPromise()
            }

            function zt(e, t) {
                const n = Bt(e, !0).delete(t);
                return new Wt(n).toPromise()
            }
            class $t {
                constructor() {
                    this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then((() => {}), (() => {}))
                }
                async _openDb() {
                    return this.db || (this.db = await Vt()), this.db
                }
                async _withRetries(e) {
                    let t = 0;
                    for (;;) try {
                        const t = await this._openDb();
                        return await e(t)
                    } catch (e) {
                        if (t++ > 3) throw e;
                        this.db && (this.db.close(), this.db = void 0)
                    }
                }
                async initializeServiceWorkerMessaging() {
                    return Ft() ? this.initializeReceiver() : this.initializeSender()
                }
                async initializeReceiver() {
                    this.receiver = Mt._getInstance(Ft() ? self : null), this.receiver._subscribe("keyChanged", (async (e, t) => ({
                        keyProcessed: (await this._poll()).includes(t.key)
                    }))), this.receiver._subscribe("ping", (async (e, t) => ["keyChanged"]))
                }
                async initializeSender() {
                    var e, t;
                    if (this.activeServiceWorker = await async function() {
                            if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker)) return null;
                            try {
                                return (await navigator.serviceWorker.ready).active
                            } catch (e) {
                                return null
                            }
                        }(), !this.activeServiceWorker) return;
                    this.sender = new Lt(this.activeServiceWorker);
                    const n = await this.sender._send("ping", {}, 800);
                    n && (null === (e = n[0]) || void 0 === e ? void 0 : e.fulfilled) && (null === (t = n[0]) || void 0 === t ? void 0 : t.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = !0)
                }
                async notifyServiceWorker(e) {
                    var t;
                    if (this.sender && this.activeServiceWorker && ((null === (t = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === t ? void 0 : t.controller) || null) === this.activeServiceWorker) try {
                        await this.sender._send("keyChanged", {
                            key: e
                        }, this.serviceWorkerReceiverAvailable ? 800 : 50)
                    } catch (t) {}
                }
                async _isAvailable() {
                    try {
                        if (!indexedDB) return !1;
                        const e = await Vt();
                        return await Gt(e, Rt, "1"), await zt(e, Rt), !0
                    } catch (e) {}
                    return !1
                }
                async _withPendingWrite(e) {
                    this.pendingWrites++;
                    try {
                        await e()
                    } finally {
                        this.pendingWrites--
                    }
                }
                async _set(e, t) {
                    return this._withPendingWrite((async () => (await this._withRetries((n => Gt(n, e, t))), this.localCache[e] = t, this.notifyServiceWorker(e))))
                }
                async _get(e) {
                    const t = await this._withRetries((t => async function(e, t) {
                        const n = Bt(e, !1).get(t),
                            r = await new Wt(n).toPromise();
                        return void 0 === r ? null : r.value
                    }(t, e)));
                    return this.localCache[e] = t, t
                }
                async _remove(e) {
                    return this._withPendingWrite((async () => (await this._withRetries((t => zt(t, e))), delete this.localCache[e], this.notifyServiceWorker(e))))
                }
                async _poll() {
                    const e = await this._withRetries((e => {
                        const t = Bt(e, !1).getAll();
                        return new Wt(t).toPromise()
                    }));
                    if (!e) return [];
                    if (0 !== this.pendingWrites) return [];
                    const t = [],
                        n = new Set;
                    for (const {
                            fbase_key: r,
                            value: i
                        } of e) n.add(r), JSON.stringify(this.localCache[r]) !== JSON.stringify(i) && (this.notifyListeners(r, i), t.push(r));
                    for (const e of Object.keys(this.localCache)) this.localCache[e] && !n.has(e) && (this.notifyListeners(e, null), t.push(e));
                    return t
                }
                notifyListeners(e, t) {
                    this.localCache[e] = t;
                    const n = this.listeners[e];
                    if (n)
                        for (const e of Array.from(n)) e(t)
                }
                startPolling() {
                    this.stopPolling(), this.pollTimer = setInterval((async () => this._poll()), 800)
                }
                stopPolling() {
                    this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null)
                }
                _addListener(e, t) {
                    0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[e] || (this.listeners[e] = new Set, this._get(e)), this.listeners[e].add(t)
                }
                _removeListener(e, t) {
                    this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && this.stopPolling()
                }
            }
            $t.type = "LOCAL";
            const Kt = $t;
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Yt = 1e12;
            class Jt {
                constructor(e) {
                    this.auth = e, this.counter = Yt, this._widgets = new Map
                }
                render(e, t) {
                    const n = this.counter;
                    return this._widgets.set(n, new Qt(e, this.auth.name, t || {})), this.counter++, n
                }
                reset(e) {
                    var t;
                    const n = e || Yt;
                    null === (t = this._widgets.get(n)) || void 0 === t || t.delete(), this._widgets.delete(n)
                }
                getResponse(e) {
                    var t;
                    const n = e || Yt;
                    return (null === (t = this._widgets.get(n)) || void 0 === t ? void 0 : t.getResponse()) || ""
                }
                async execute(e) {
                    var t;
                    const n = e || Yt;
                    return null === (t = this._widgets.get(n)) || void 0 === t || t.execute(), ""
                }
            }
            class Qt {
                constructor(e, t, n) {
                    this.params = n, this.timerId = null, this.deleted = !1, this.responseToken = null, this.clickHandler = () => {
                        this.execute()
                    };
                    const r = "string" == typeof e ? document.getElementById(e) : e;
                    y(r, "argument-error", {
                        appName: t
                    }), this.container = r, this.isVisible = "invisible" !== this.params.size, this.isVisible ? this.execute() : this.container.addEventListener("click", this.clickHandler)
                }
                getResponse() {
                    return this.checkIfDeleted(), this.responseToken
                }
                delete() {
                    this.checkIfDeleted(), this.deleted = !0, this.timerId && (clearTimeout(this.timerId), this.timerId = null), this.container.removeEventListener("click", this.clickHandler)
                }
                execute() {
                    this.checkIfDeleted(), this.timerId || (this.timerId = window.setTimeout((() => {
                        this.responseToken = function(e) {
                            const t = [],
                                n = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
                            for (let r = 0; r < e; r++) t.push(n.charAt(Math.floor(Math.random() * n.length)));
                            return t.join("")
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        (50);
                        const {
                            callback: e,
                            "expired-callback": t
                        } = this.params;
                        if (e) try {
                            e(this.responseToken)
                        } catch (e) {}
                        this.timerId = window.setTimeout((() => {
                            if (this.timerId = null, this.responseToken = null, t) try {
                                t()
                            } catch (e) {}
                            this.isVisible && this.execute()
                        }), 6e4)
                    }), 500))
                }
                checkIfDeleted() {
                    if (this.deleted) throw new Error("reCAPTCHA mock was already deleted!")
                }
            }
            const Xt = _e("rcb"),
                Zt = new C(3e4, 6e4);
            class en {
                constructor() {
                    var e;
                    this.hostLanguage = "", this.counter = 0, this.librarySeparatelyLoaded = !!(null === (e = Ut().grecaptcha) || void 0 === e ? void 0 : e.render)
                }
                load(e, t = "") {
                    return y(function(e) {
                        return e.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(e)
                    }(t), e, "argument-error"), this.shouldResolveImmediately(t) && pe(Ut().grecaptcha) ? Promise.resolve(Ut().grecaptcha) : new Promise(((n, i) => {
                        const o = Ut().setTimeout((() => {
                            i(m(e, "network-request-failed"))
                        }), Zt.get());
                        Ut()[Xt] = () => {
                            Ut().clearTimeout(o), delete Ut()[Xt];
                            const r = Ut().grecaptcha;
                            if (!r || !pe(r)) return void i(m(e, "internal-error"));
                            const s = r.render;
                            r.render = (e, t) => {
                                const n = s(e, t);
                                return this.counter++, n
                            }, this.hostLanguage = t, n(r)
                        };
                        ge(`https://www.google.com/recaptcha/api.js??${r.querystring({onload:Xt,render:"explicit",hl:t})}`).catch((() => {
                            clearTimeout(o), i(m(e, "internal-error"))
                        }))
                    }))
                }
                clearedOneInstance() {
                    this.counter--
                }
                shouldResolveImmediately(e) {
                    var t;
                    return !!(null === (t = Ut().grecaptcha) || void 0 === t ? void 0 : t.render) && (e === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded)
                }
            }
            class tn {
                async load(e) {
                    return new Jt(e)
                }
                clearedOneInstance() {}
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const nn = "recaptcha",
                rn = {
                    theme: "light",
                    type: "image"
                };
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class on {
                constructor(e, t) {
                    this.verificationId = e, this.onConfirmation = t
                }
                confirm(e) {
                    const t = je._fromVerification(this.verificationId, e);
                    return this.onConfirmation(t)
                }
            }
            async function sn(e, t, n) {
                var r;
                const i = await n.verify();
                try {
                    let o;
                    if (y("string" == typeof i, e, "argument-error"), y(n.type === nn, e, "argument-error"), o = "string" == typeof t ? {
                            phoneNumber: t
                        } : t, "session" in o) {
                        const t = o.session;
                        if ("phoneNumber" in o) {
                            y("enroll" === t.type, e, "internal-error");
                            const n =
                                /**
                                 * @license
                                 * Copyright 2020 Google LLC
                                 *
                                 * Licensed under the Apache License, Version 2.0 (the "License");
                                 * you may not use this file except in compliance with the License.
                                 * You may obtain a copy of the License at
                                 *
                                 *   http://www.apache.org/licenses/LICENSE-2.0
                                 *
                                 * Unless required by applicable law or agreed to in writing, software
                                 * distributed under the License is distributed on an "AS IS" BASIS,
                                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                 * See the License for the specific language governing permissions and
                                 * limitations under the License.
                                 */
                                await
                            function(e, t) {
                                return k(e, "POST", "/v2/accounts/mfaEnrollment:start", O(e, t))
                            }(e, {
                                idToken: t.credential,
                                phoneEnrollmentInfo: {
                                    phoneNumber: o.phoneNumber,
                                    recaptchaToken: i
                                }
                            });
                            return n.phoneSessionInfo.sessionInfo
                        } {
                            y("signin" === t.type, e, "internal-error");
                            const n = (null === (r = o.multiFactorHint) || void 0 === r ? void 0 : r.uid) || o.multiFactorUid;
                            y(n, e, "missing-multi-factor-info");
                            const s = await
                            function(e, t) {
                                return k(e, "POST", "/v2/accounts/mfaSignIn:start", O(e, t))
                            }(e, {
                                mfaPendingCredential: t.credential,
                                mfaEnrollmentId: n,
                                phoneSignInInfo: {
                                    recaptchaToken: i
                                }
                            });
                            return s.phoneResponseInfo.sessionInfo
                        }
                    } {
                        const {
                            sessionInfo: t
                        } = await async function(e, t) {
                            return k(e, "POST", "/v1/accounts:sendVerificationCode", O(e, t))
                        }(e, {
                            phoneNumber: o.phoneNumber,
                            recaptchaToken: i
                        });
                        return t
                    }
                } finally {
                    n._reset()
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class an {
                constructor(e) {
                    this.providerId = an.PROVIDER_ID, this.auth = Ee(e)
                }
                verifyPhoneNumber(e, t) {
                    return sn(this.auth, e, r.getModularInstance(t))
                }
                static credential(e, t) {
                    return je._fromVerification(e, t)
                }
                static credentialFromResult(e) {
                    const t = e;
                    return an.credentialFromTaggedObject(t)
                }
                static credentialFromError(e) {
                    return an.credentialFromTaggedObject(e.customData || {})
                }
                static credentialFromTaggedObject({
                    _tokenResponse: e
                }) {
                    if (!e) return null;
                    const {
                        phoneNumber: t,
                        temporaryProof: n
                    } = e;
                    return t && n ? je._fromTokenResponse(t, n) : null
                }
            }
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function cn(e, t) {
                return t ? J(t) : (y(e._popupRedirectResolver, e, "argument-error"), e._popupRedirectResolver)
            }
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            an.PROVIDER_ID = "phone", an.PHONE_SIGN_IN_METHOD = "phone";
            class un extends Re {
                constructor(e) {
                    super("custom", "custom"), this.params = e
                }
                _getIdTokenResponse(e) {
                    return Le(e, this._buildIdpRequest())
                }
                _linkToIdToken(e, t) {
                    return Le(e, this._buildIdpRequest(t))
                }
                _getReauthenticationResolver(e) {
                    return Le(e, this._buildIdpRequest())
                }
                _buildIdpRequest(e) {
                    const t = {
                        requestUri: this.params.requestUri,
                        sessionId: this.params.sessionId,
                        postBody: this.params.postBody,
                        tenantId: this.params.tenantId,
                        pendingToken: this.params.pendingToken,
                        returnSecureToken: !0,
                        returnIdpCredential: !0
                    };
                    return e && (t.idToken = e), t
                }
            }

            function ln(e) {
                return st(e.auth, new un(e), e.bypassAuthState)
            }

            function dn(e) {
                const {
                    auth: t,
                    user: n
                } = e;
                return y(n, t, "internal-error"), ot(n, new un(e), e.bypassAuthState)
            }
            async function hn(e) {
                const {
                    auth: t,
                    user: n
                } = e;
                return y(n, t, "internal-error"), rt(n, new un(e), e.bypassAuthState)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class pn {
                constructor(e, t, n, r, i = !1) {
                    this.auth = e, this.resolver = n, this.user = r, this.bypassAuthState = i, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(t) ? t : [t]
                }
                execute() {
                    return new Promise((async (e, t) => {
                        this.pendingPromise = {
                            resolve: e,
                            reject: t
                        };
                        try {
                            this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this)
                        } catch (e) {
                            this.reject(e)
                        }
                    }))
                }
                async onAuthEvent(e) {
                    const {
                        urlResponse: t,
                        sessionId: n,
                        postBody: r,
                        tenantId: i,
                        error: o,
                        type: s
                    } = e;
                    if (o) return void this.reject(o);
                    const a = {
                        auth: this.auth,
                        requestUri: t,
                        sessionId: n,
                        tenantId: i || void 0,
                        postBody: r || void 0,
                        user: this.user,
                        bypassAuthState: this.bypassAuthState
                    };
                    try {
                        this.resolve(await this.getIdpTask(s)(a))
                    } catch (e) {
                        this.reject(e)
                    }
                }
                onError(e) {
                    this.reject(e)
                }
                getIdpTask(e) {
                    switch (e) {
                        case "signInViaPopup":
                        case "signInViaRedirect":
                            return ln;
                        case "linkViaPopup":
                        case "linkViaRedirect":
                            return hn;
                        case "reauthViaPopup":
                        case "reauthViaRedirect":
                            return dn;
                        default:
                            f(this.auth, "internal-error")
                    }
                }
                resolve(e) {
                    I(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp()
                }
                reject(e) {
                    I(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp()
                }
                unregisterAndCleanUp() {
                    this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp()
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const fn = new C(2e3, 1e4);
            class mn extends pn {
                constructor(e, t, n, r, i) {
                    super(e, t, r, i), this.provider = n, this.authWindow = null, this.pollId = null, mn.currentPopupAction && mn.currentPopupAction.cancel(), mn.currentPopupAction = this
                }
                async executeNotNull() {
                    const e = await this.execute();
                    return y(e, this.auth, "internal-error"), e
                }
                async onExecution() {
                    I(1 === this.filter.length, "Popup operations only handle one event");
                    const e = xt();
                    this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch((e => {
                        this.reject(e)
                    })), this.resolver._isIframeWebStorageSupported(this.auth, (e => {
                        e || this.reject(m(this.auth, "web-storage-unsupported"))
                    })), this.pollUserCancellation()
                }
                get eventId() {
                    var e;
                    return (null === (e = this.authWindow) || void 0 === e ? void 0 : e.associatedEvent) || null
                }
                cancel() {
                    this.reject(m(this.auth, "cancelled-popup-request"))
                }
                cleanUp() {
                    this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, mn.currentPopupAction = null
                }
                pollUserCancellation() {
                    const e = () => {
                        var t, n;
                        (null === (n = null === (t = this.authWindow) || void 0 === t ? void 0 : t.window) || void 0 === n ? void 0 : n.closed) ? this.pollId = window.setTimeout((() => {
                            this.pollId = null, this.reject(m(this.auth, "popup-closed-by-user"))
                        }), 8e3): this.pollId = window.setTimeout(e, fn.get())
                    };
                    e()
                }
            }
            mn.currentPopupAction = null;
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const gn = "pendingRedirect",
                _n = new Map;
            class vn extends pn {
                constructor(e, t, n = !1) {
                    super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], t, void 0, n), this.eventId = null
                }
                async execute() {
                    let e = _n.get(this.auth._key());
                    if (!e) {
                        try {
                            const t = await async function(e, t) {
                                const n = En(t),
                                    r = In(e);
                                if (!await r._isAvailable()) return !1;
                                const i = "true" === await r._get(n);
                                return await r._remove(n), i
                            }(this.resolver, this.auth) ? await super.execute() : null;
                            e = () => Promise.resolve(t)
                        } catch (t) {
                            e = () => Promise.reject(t)
                        }
                        _n.set(this.auth._key(), e)
                    }
                    return this.bypassAuthState || _n.set(this.auth._key(), (() => Promise.resolve(null))), e()
                }
                async onAuthEvent(e) {
                    if ("signInViaRedirect" === e.type) return super.onAuthEvent(e);
                    if ("unknown" !== e.type) {
                        if (e.eventId) {
                            const t = await this.auth._redirectUserForId(e.eventId);
                            if (t) return this.user = t, super.onAuthEvent(e);
                            this.resolve(null)
                        }
                    } else this.resolve(null)
                }
                async onExecution() {}
                cleanUp() {}
            }
            async function yn(e, t) {
                return In(e)._set(En(t), "true")
            }

            function bn(e, t) {
                _n.set(e._key(), t)
            }

            function In(e) {
                return J(e._redirectPersistence)
            }

            function En(e) {
                return Z(gn, e.config.apiKey, e.name)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            async function Sn(e, t, n = !1) {
                const r = Ee(e),
                    i = cn(r, t),
                    o = new vn(r, i, n),
                    s = await o.execute();
                return s && !n && (delete s.user._redirectEventId, await r._persistUserIfCurrent(s.user), await r._setRedirectUser(null, t)), s
            }
            async function wn(e) {
                const t = xt(`${e.uid}:::`);
                return e._redirectEventId = t, await e.auth._setRedirectUser(e), await e.auth._persistUserIfCurrent(e), t
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Cn {
                constructor(e) {
                    this.auth = e, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now()
                }
                registerConsumer(e) {
                    this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null)
                }
                unregisterConsumer(e) {
                    this.consumers.delete(e)
                }
                onEvent(e) {
                    if (this.hasEventBeenHandled(e)) return !1;
                    let t = !1;
                    return this.consumers.forEach((n => {
                        this.isEventForConsumer(e, n) && (t = !0, this.sendToConsumer(e, n), this.saveEventToCache(e))
                    })), this.hasHandledPotentialRedirect || ! function(e) {
                        switch (e.type) {
                            case "signInViaRedirect":
                            case "linkViaRedirect":
                            case "reauthViaRedirect":
                                return !0;
                            case "unknown":
                                return An(e);
                            default:
                                return !1
                        }
                    }
                    /**
                     * @license
                     * Copyright 2020 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                    (e) || (this.hasHandledPotentialRedirect = !0, t || (this.queuedRedirectEvent = e, t = !0)), t
                }
                sendToConsumer(e, t) {
                    var n;
                    if (e.error && !An(e)) {
                        const r = (null === (n = e.error.code) || void 0 === n ? void 0 : n.split("auth/")[1]) || "internal-error";
                        t.onError(m(this.auth, r))
                    } else t.onAuthEvent(e)
                }
                isEventForConsumer(e, t) {
                    const n = null === t.eventId || !!e.eventId && e.eventId === t.eventId;
                    return t.filter.includes(e.type) && n
                }
                hasEventBeenHandled(e) {
                    return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(Tn(e))
                }
                saveEventToCache(e) {
                    this.cachedEventUids.add(Tn(e)), this.lastProcessedEventTime = Date.now()
                }
            }

            function Tn(e) {
                return [e.type, e.eventId, e.sessionId, e.tenantId].filter((e => e)).join("-")
            }

            function An({
                type: e,
                error: t
            }) {
                return "unknown" === e && "auth/no-auth-event" === (null == t ? void 0 : t.code)
            }
            async function Rn(e, t = {}) {
                return k(e, "GET", "/v1/projects", t)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Pn = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
                On = /^https?/;

            function kn(e) {
                const t = E(),
                    {
                        protocol: n,
                        hostname: r
                    } = new URL(t);
                if (e.startsWith("chrome-extension://")) {
                    const i = new URL(e);
                    return "" === i.hostname && "" === r ? "chrome-extension:" === n && e.replace("chrome-extension://", "") === t.replace("chrome-extension://", "") : "chrome-extension:" === n && i.hostname === r
                }
                if (!On.test(n)) return !1;
                if (Pn.test(e)) return r === e;
                const i = e.replace(/\./g, "\\.");
                return new RegExp("^(.+\\." + i + "|" + i + ")$", "i").test(r)
            }
            /**
             * @license
             * Copyright 2020 Google LLC.
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Nn = new C(3e4, 6e4);

            function Dn() {
                const e = Ut().___jsl;
                if (null == e ? void 0 : e.H)
                    for (const t of Object.keys(e.H))
                        if (e.H[t].r = e.H[t].r || [], e.H[t].L = e.H[t].L || [], e.H[t].r = [...e.H[t].L], e.CP)
                            for (let t = 0; t < e.CP.length; t++) e.CP[t] = null
            }
            let Mn = null;

            function xn(e) {
                return Mn = Mn || function(e) {
                    return new Promise(((t, n) => {
                        var r, i, o;

                        function s() {
                            Dn(), gapi.load("gapi.iframes", {
                                callback: () => {
                                    t(gapi.iframes.getContext())
                                },
                                ontimeout: () => {
                                    Dn(), n(m(e, "network-request-failed"))
                                },
                                timeout: Nn.get()
                            })
                        }
                        if (null === (i = null === (r = Ut().gapi) || void 0 === r ? void 0 : r.iframes) || void 0 === i ? void 0 : i.Iframe) t(gapi.iframes.getContext());
                        else {
                            if (!(null === (o = Ut().gapi) || void 0 === o ? void 0 : o.load)) {
                                const t = _e("iframefcb");
                                return Ut()[t] = () => {
                                    gapi.load ? s() : n(m(e, "network-request-failed"))
                                }, ge(`https://apis.google.com/js/api.js?onload=${t}`).catch((e => n(e)))
                            }
                            s()
                        }
                    })).catch((e => {
                        throw Mn = null, e
                    }))
                }(e), Mn
            }
            /**
             * @license
             * Copyright 2020 Google LLC.
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Ln = new C(5e3, 15e3),
                Un = "__/auth/iframe",
                Fn = "emulator/auth/iframe",
                jn = {
                    style: {
                        position: "absolute",
                        top: "-100px",
                        width: "1px",
                        height: "1px"
                    },
                    "aria-hidden": "true",
                    tabindex: "-1"
                },
                qn = new Map([
                    ["identitytoolkit.googleapis.com", "p"],
                    ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
                    ["test-identitytoolkit.sandbox.googleapis.com", "t"]
                ]);

            function Hn(e) {
                const t = e.config;
                y(t.authDomain, e, "auth-domain-config-required");
                const n = t.emulator ? T(t, Fn) : `https://${e.config.authDomain}/${Un}`,
                    o = {
                        apiKey: t.apiKey,
                        appName: e.name,
                        v: i.SDK_VERSION
                    },
                    s = qn.get(e.config.apiHost);
                s && (o.eid = s);
                const a = e._getFrameworks();
                return a.length && (o.fw = a.join(",")), `${n}?${r.querystring(o).slice(1)}`
            }
            /**
             * @license
             * Copyright 2020 Google LLC.
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Wn = {
                location: "yes",
                resizable: "yes",
                statusbar: "yes",
                toolbar: "no"
            };
            class Bn {
                constructor(e) {
                    this.window = e, this.associatedEvent = null
                }
                close() {
                    if (this.window) try {
                        this.window.close()
                    } catch (e) {}
                }
            }

            function Vn(e, t, n, i = 500, o = 600) {
                const s = Math.max((window.screen.availHeight - o) / 2, 0).toString(),
                    a = Math.max((window.screen.availWidth - i) / 2, 0).toString();
                let c = "";
                const u = Object.assign(Object.assign({}, Wn), {
                        width: i.toString(),
                        height: o.toString(),
                        top: s,
                        left: a
                    }),
                    l = r.getUA().toLowerCase();
                n && (c = ie(l) ? "_blank" : n), ne(l) && (t = t || "http://localhost", u.scrollbars = "yes");
                const d = Object.entries(u).reduce(((e, [t, n]) => `${e}${t}=${n},`), "");
                if (function(e = r.getUA()) {
                        var t;
                        return ue(e) && !!(null === (t = window.navigator) || void 0 === t ? void 0 : t.standalone)
                    }(l) && "_self" !== c) return function(e, t) {
                    const n = document.createElement("a");
                    n.href = e, n.target = t;
                    const r = document.createEvent("MouseEvent");
                    r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r)
                }
                /**
                 * @license
                 * Copyright 2021 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                (t || "", c), new Bn(null);
                const h = window.open(t || "", c, d);
                y(h, e, "popup-blocked");
                try {
                    h.focus()
                } catch (e) {}
                return new Bn(h)
            }
            const Gn = "__/auth/handler",
                zn = "emulator/auth/handler",
                $n = encodeURIComponent("fac");
            async function Kn(e, t, n, o, s, a) {
                y(e.config.authDomain, e, "auth-domain-config-required"), y(e.config.apiKey, e, "invalid-api-key");
                const c = {
                    apiKey: e.config.apiKey,
                    appName: e.name,
                    authType: n,
                    redirectUrl: o,
                    v: i.SDK_VERSION,
                    eventId: s
                };
                if (t instanceof We) {
                    t.setDefaultLanguage(e.languageCode), c.providerId = t.providerId || "", r.isEmpty(t.getCustomParameters()) || (c.customParameters = JSON.stringify(t.getCustomParameters()));
                    for (const [e, t] of Object.entries(a || {})) c[e] = t
                }
                if (t instanceof Be) {
                    const e = t.getScopes().filter((e => "" !== e));
                    e.length > 0 && (c.scopes = e.join(","))
                }
                e.tenantId && (c.tid = e.tenantId);
                const u = c;
                for (const e of Object.keys(u)) void 0 === u[e] && delete u[e];
                const l = await e._getAppCheckToken(),
                    d = l ? `#${$n}=${encodeURIComponent(l)}` : "";
                return `${function({config:e}){if(!e.emulator)return`
                https: //${e.authDomain}/${Gn}`;return T(e,zn)}
                    /**
                     * @license
                     * Copyright 2020 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                    (e)
            } ? $ {
                r.querystring(u).slice(1)
            }
            $ {
                d
            }
            `}const Yn="webStorageSupport";const Jn=class{constructor(){this.eventManagers={},this.iframes={},this.originValidationPromises={},this._redirectPersistence=Dt,this._completeRedirectFn=Sn,this._overrideRedirectResult=bn}async _openPopup(e,t,n,r){var i;I(null===(i=this.eventManagers[e._key()])||void 0===i?void 0:i.manager,"_initialize() not called before _openPopup()");return Vn(e,await Kn(e,t,n,E(),r),xt())}async _openRedirect(e,t,n,r){await this._originValidation(e);return function(e){Ut().location.href=e}(await Kn(e,t,n,E(),r)),new Promise((()=>{}))}_initialize(e){const t=e._key();if(this.eventManagers[t]){const{manager:e,promise:n}=this.eventManagers[t];return e?Promise.resolve(e):(I(n,"If manager is not set, promise should be"),n)}const n=this.initAndGetManager(e);return this.eventManagers[t]={promise:n},n.catch((()=>{delete this.eventManagers[t]})),n}async initAndGetManager(e){const t=await async function(e){const t=await xn(e),n=Ut().gapi;return y(n,e,"internal-error"),t.open({where:document.body,url:Hn(e),messageHandlersFilter:n.iframes.CROSS_ORIGIN_IFRAMES_FILTER,attributes:jn,dontclear:!0},(t=>new Promise((async(n,r)=>{await t.restyle({setHideOnLeave:!1});const i=m(e,"network-request-failed"),o=Ut().setTimeout((()=>{r(i)}),Ln.get());function s(){Ut().clearTimeout(o),n(t)}t.ping(s).then(s,(()=>{r(i)}))}))))}(e),n=new Cn(e);return t.register("authEvent",(t=>{y(null==t?void 0:t.authEvent,e,"invalid-auth-event");return{status:n.onEvent(t.authEvent)?"ACK":"ERROR"}}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),this.eventManagers[e._key()]={manager:n},this.iframes[e._key()]=t,n}_isIframeWebStorageSupported(e,t){this.iframes[e._key()].send(Yn,{type:Yn},(n=>{var r;const i=null===(r=null==n?void 0:n[0])||void 0===r?void 0:r[Yn];void 0!==i&&t(!!i),f(e,"internal-error")}),gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)}_originValidation(e){const t=e._key();return this.originValidationPromises[t]||(this.originValidationPromises[t]=async function(e){if(e.config.emulator)return;const{authorizedDomains:t}=await Rn(e);for(const e of t)try{if(kn(e))return}catch(e){}f(e,"unauthorized-domain")}(e)),this.originValidationPromises[t]}get _shouldInitProactively(){return le()||re()||ue()}};class Qn{constructor(e){this.factorId=e}_process(e,t,n){switch(t.type){case"enroll":return this._finalizeEnroll(e,t.credential,n);case"signin":return this._finalizeSignIn(e,t.credential);default:return b("unexpected MultiFactorSessionType")}}}class Xn extends Qn{constructor(e){super("phone"),this.credential=e}static _fromCredential(e){return new Xn(e)}_finalizeEnroll(e,t,n){return function(e,t){return k(e,"POST","/v2/accounts/mfaEnrollment:finalize",O(e,t))}(e,{idToken:t,displayName:n,phoneVerificationInfo:this.credential._makeVerificationRequest()})}_finalizeSignIn(e,t){return function(e,t){return k(e,"POST","/v2/accounts/mfaSignIn:finalize",O(e,t))}(e,{mfaPendingCredential:t,phoneVerificationInfo:this.credential._makeVerificationRequest()})}}class Zn{constructor(){}static assertion(e){return Xn._fromCredential(e)}}Zn.FACTOR_ID="phone";class er{static assertionForEnrollment(e,t){return tr._fromSecret(e,t)}static assertionForSignIn(e,t){return tr._fromEnrollmentId(e,t)}static async generateSecret(e){const t=e;y(void 0!==t.auth,"internal-error");const n=await(r=t.auth,i={idToken:t.credential,totpEnrollmentInfo:{}},k(r,"POST","/v2/accounts/mfaEnrollment:start",O(r,i)));var r,i;return nr._fromStartTotpMfaEnrollmentResponse(n,t.auth)}}er.FACTOR_ID="totp";class tr extends Qn{constructor(e,t,n){super("totp"),this.otp=e,this.enrollmentId=t,this.secret=n}static _fromSecret(e,t){return new tr(t,void 0,e)}static _fromEnrollmentId(e,t){return new tr(t,e)}async _finalizeEnroll(e,t,n){return y(void 0!==this.secret,e,"argument-error"),function(e,t){return k(e,"POST","/v2/accounts/mfaEnrollment:finalize",O(e,t))}(e,{idToken:t,displayName:n,totpVerificationInfo:this.secret._makeTotpVerificationInfo(this.otp)})}async _finalizeSignIn(e,t){y(void 0!==this.enrollmentId&&void 0!==this.otp,e,"argument-error");const n={verificationCode:this.otp};return function(e,t){return k(e,"POST","/v2/accounts/mfaSignIn:finalize",O(e,t))}(e,{mfaPendingCredential:t,mfaEnrollmentId:this.enrollmentId,totpVerificationInfo:n})}}class nr{constructor(e,t,n,r,i,o,s){this.sessionInfo=o,this.auth=s,this.secretKey=e,this.hashingAlgorithm=t,this.codeLength=n,this.codeIntervalSeconds=r,this.enrollmentCompletionDeadline=i}static _fromStartTotpMfaEnrollmentResponse(e,t){return new nr(e.totpSessionInfo.sharedSecretKey,e.totpSessionInfo.hashingAlgorithm,e.totpSessionInfo.verificationCodeLength,e.totpSessionInfo.periodSec,new Date(e.totpSessionInfo.finalizeEnrollmentTime).toUTCString(),e.totpSessionInfo.sessionInfo,t)}_makeTotpVerificationInfo(e){return{sessionInfo:this.sessionInfo,verificationCode:e}}generateQrCodeUrl(e,t){var n;let r=!1;return(rr(e)||rr(t))&&(r=!0),r&&(rr(e)&&(e=(null===(n=this.auth.currentUser)||void 0===n?void 0:n.email)||"unknownuser"),rr(t)&&(t=this.auth.name)),`
            otpauth: //totp/${t}:${e}?secret=${this.secretKey}&issuer=${t}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`}}function rr(e){return void 0===e||0===(null==e?void 0:e.length)}var ir="@firebase/auth",or="0.23.2";
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                class sr {
                    constructor(e) {
                        this.auth = e, this.internalListeners = new Map
                    }
                    getUid() {
                        var e;
                        return this.assertAuthConfigured(), (null === (e = this.auth.currentUser) || void 0 === e ? void 0 : e.uid) || null
                    }
                    async getToken(e) {
                        if (this.assertAuthConfigured(), await this.auth._initializationPromise, !this.auth.currentUser) return null;
                        return {
                            accessToken: await this.auth.currentUser.getIdToken(e)
                        }
                    }
                    addAuthTokenListener(e) {
                        if (this.assertAuthConfigured(), this.internalListeners.has(e)) return;
                        const t = this.auth.onIdTokenChanged((t => {
                            e((null == t ? void 0 : t.stsTokenManager.accessToken) || null)
                        }));
                        this.internalListeners.set(e, t), this.updateProactiveRefresh()
                    }
                    removeAuthTokenListener(e) {
                        this.assertAuthConfigured();
                        const t = this.internalListeners.get(e);
                        t && (this.internalListeners.delete(e), t(), this.updateProactiveRefresh())
                    }
                    assertAuthConfigured() {
                        y(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
                    }
                    updateProactiveRefresh() {
                        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
                    }
                }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const ar = r.getExperimentalSetting("authIdTokenMaxAge") || 300;
            let cr = null;
            var ur;
            ur = "Browser", i._registerComponent(new a.Component("auth", ((e, {
                    options: t
                }) => {
                    const n = e.getProvider("app").getImmediate(),
                        r = e.getProvider("heartbeat"),
                        i = e.getProvider("app-check-internal"),
                        {
                            apiKey: o,
                            authDomain: s
                        } = n.options;
                    y(o && !o.includes(":"), "invalid-api-key", {
                        appName: n.name
                    });
                    const a = {
                            apiKey: o,
                            authDomain: s,
                            clientPlatform: ur,
                            apiHost: "identitytoolkit.googleapis.com",
                            tokenApiHost: "securetoken.googleapis.com",
                            apiScheme: "https",
                            sdkClientVersion: de(ur)
                        },
                        c = new Ie(n, r, i, a);
                    return function(e, t) {
                        const n = (null == t ? void 0 : t.persistence) || [],
                            r = (Array.isArray(n) ? n : [n]).map(J);
                        (null == t ? void 0 : t.errorMap) && e._updateErrorMap(t.errorMap), e._initializeWithPersistence(r, null == t ? void 0 : t.popupRedirectResolver)
                    }(c, t), c
                }), "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback(((e, t, n) => {
                    e.getProvider("auth-internal").initialize()
                }))), i._registerComponent(new a.Component("auth-internal", (e => (e => new sr(e))(Ee(e.getProvider("auth").getImmediate()))), "PRIVATE").setInstantiationMode("EXPLICIT")), i.registerVersion(ir, or, function(e) {
                    switch (e) {
                        case "Node":
                            return "node";
                        case "ReactNative":
                            return "rn";
                        case "Worker":
                            return "webworker";
                        case "Cordova":
                            return "cordova";
                        default:
                            return
                    }
                }(ur)), i.registerVersion(ir, or, "cjs2017"), t.AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {
                    ADMIN_ONLY_OPERATION: "auth/admin-restricted-operation",
                    ARGUMENT_ERROR: "auth/argument-error",
                    APP_NOT_AUTHORIZED: "auth/app-not-authorized",
                    APP_NOT_INSTALLED: "auth/app-not-installed",
                    CAPTCHA_CHECK_FAILED: "auth/captcha-check-failed",
                    CODE_EXPIRED: "auth/code-expired",
                    CORDOVA_NOT_READY: "auth/cordova-not-ready",
                    CORS_UNSUPPORTED: "auth/cors-unsupported",
                    CREDENTIAL_ALREADY_IN_USE: "auth/credential-already-in-use",
                    CREDENTIAL_MISMATCH: "auth/custom-token-mismatch",
                    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "auth/requires-recent-login",
                    DEPENDENT_SDK_INIT_BEFORE_AUTH: "auth/dependent-sdk-initialized-before-auth",
                    DYNAMIC_LINK_NOT_ACTIVATED: "auth/dynamic-link-not-activated",
                    EMAIL_CHANGE_NEEDS_VERIFICATION: "auth/email-change-needs-verification",
                    EMAIL_EXISTS: "auth/email-already-in-use",
                    EMULATOR_CONFIG_FAILED: "auth/emulator-config-failed",
                    EXPIRED_OOB_CODE: "auth/expired-action-code",
                    EXPIRED_POPUP_REQUEST: "auth/cancelled-popup-request",
                    INTERNAL_ERROR: "auth/internal-error",
                    INVALID_API_KEY: "auth/invalid-api-key",
                    INVALID_APP_CREDENTIAL: "auth/invalid-app-credential",
                    INVALID_APP_ID: "auth/invalid-app-id",
                    INVALID_AUTH: "auth/invalid-user-token",
                    INVALID_AUTH_EVENT: "auth/invalid-auth-event",
                    INVALID_CERT_HASH: "auth/invalid-cert-hash",
                    INVALID_CODE: "auth/invalid-verification-code",
                    INVALID_CONTINUE_URI: "auth/invalid-continue-uri",
                    INVALID_CORDOVA_CONFIGURATION: "auth/invalid-cordova-configuration",
                    INVALID_CUSTOM_TOKEN: "auth/invalid-custom-token",
                    INVALID_DYNAMIC_LINK_DOMAIN: "auth/invalid-dynamic-link-domain",
                    INVALID_EMAIL: "auth/invalid-email",
                    INVALID_EMULATOR_SCHEME: "auth/invalid-emulator-scheme",
                    INVALID_IDP_RESPONSE: "auth/invalid-credential",
                    INVALID_MESSAGE_PAYLOAD: "auth/invalid-message-payload",
                    INVALID_MFA_SESSION: "auth/invalid-multi-factor-session",
                    INVALID_OAUTH_CLIENT_ID: "auth/invalid-oauth-client-id",
                    INVALID_OAUTH_PROVIDER: "auth/invalid-oauth-provider",
                    INVALID_OOB_CODE: "auth/invalid-action-code",
                    INVALID_ORIGIN: "auth/unauthorized-domain",
                    INVALID_PASSWORD: "auth/wrong-password",
                    INVALID_PERSISTENCE: "auth/invalid-persistence-type",
                    INVALID_PHONE_NUMBER: "auth/invalid-phone-number",
                    INVALID_PROVIDER_ID: "auth/invalid-provider-id",
                    INVALID_RECIPIENT_EMAIL: "auth/invalid-recipient-email",
                    INVALID_SENDER: "auth/invalid-sender",
                    INVALID_SESSION_INFO: "auth/invalid-verification-id",
                    INVALID_TENANT_ID: "auth/invalid-tenant-id",
                    MFA_INFO_NOT_FOUND: "auth/multi-factor-info-not-found",
                    MFA_REQUIRED: "auth/multi-factor-auth-required",
                    MISSING_ANDROID_PACKAGE_NAME: "auth/missing-android-pkg-name",
                    MISSING_APP_CREDENTIAL: "auth/missing-app-credential",
                    MISSING_AUTH_DOMAIN: "auth/auth-domain-config-required",
                    MISSING_CODE: "auth/missing-verification-code",
                    MISSING_CONTINUE_URI: "auth/missing-continue-uri",
                    MISSING_IFRAME_START: "auth/missing-iframe-start",
                    MISSING_IOS_BUNDLE_ID: "auth/missing-ios-bundle-id",
                    MISSING_OR_INVALID_NONCE: "auth/missing-or-invalid-nonce",
                    MISSING_MFA_INFO: "auth/missing-multi-factor-info",
                    MISSING_MFA_SESSION: "auth/missing-multi-factor-session",
                    MISSING_PHONE_NUMBER: "auth/missing-phone-number",
                    MISSING_SESSION_INFO: "auth/missing-verification-id",
                    MODULE_DESTROYED: "auth/app-deleted",
                    NEED_CONFIRMATION: "auth/account-exists-with-different-credential",
                    NETWORK_REQUEST_FAILED: "auth/network-request-failed",
                    NULL_USER: "auth/null-user",
                    NO_AUTH_EVENT: "auth/no-auth-event",
                    NO_SUCH_PROVIDER: "auth/no-such-provider",
                    OPERATION_NOT_ALLOWED: "auth/operation-not-allowed",
                    OPERATION_NOT_SUPPORTED: "auth/operation-not-supported-in-this-environment",
                    POPUP_BLOCKED: "auth/popup-blocked",
                    POPUP_CLOSED_BY_USER: "auth/popup-closed-by-user",
                    PROVIDER_ALREADY_LINKED: "auth/provider-already-linked",
                    QUOTA_EXCEEDED: "auth/quota-exceeded",
                    REDIRECT_CANCELLED_BY_USER: "auth/redirect-cancelled-by-user",
                    REDIRECT_OPERATION_PENDING: "auth/redirect-operation-pending",
                    REJECTED_CREDENTIAL: "auth/rejected-credential",
                    SECOND_FACTOR_ALREADY_ENROLLED: "auth/second-factor-already-in-use",
                    SECOND_FACTOR_LIMIT_EXCEEDED: "auth/maximum-second-factor-count-exceeded",
                    TENANT_ID_MISMATCH: "auth/tenant-id-mismatch",
                    TIMEOUT: "auth/timeout",
                    TOKEN_EXPIRED: "auth/user-token-expired",
                    TOO_MANY_ATTEMPTS_TRY_LATER: "auth/too-many-requests",
                    UNAUTHORIZED_DOMAIN: "auth/unauthorized-continue-uri",
                    UNSUPPORTED_FIRST_FACTOR: "auth/unsupported-first-factor",
                    UNSUPPORTED_PERSISTENCE: "auth/unsupported-persistence-type",
                    UNSUPPORTED_TENANT_OPERATION: "auth/unsupported-tenant-operation",
                    UNVERIFIED_EMAIL: "auth/unverified-email",
                    USER_CANCELLED: "auth/user-cancelled",
                    USER_DELETED: "auth/user-not-found",
                    USER_DISABLED: "auth/user-disabled",
                    USER_MISMATCH: "auth/user-mismatch",
                    USER_SIGNED_OUT: "auth/user-signed-out",
                    WEAK_PASSWORD: "auth/weak-password",
                    WEB_STORAGE_UNSUPPORTED: "auth/web-storage-unsupported",
                    ALREADY_INITIALIZED: "auth/already-initialized",
                    RECAPTCHA_NOT_ENABLED: "auth/recaptcha-not-enabled",
                    MISSING_RECAPTCHA_TOKEN: "auth/missing-recaptcha-token",
                    INVALID_RECAPTCHA_TOKEN: "auth/invalid-recaptcha-token",
                    INVALID_RECAPTCHA_ACTION: "auth/invalid-recaptcha-action",
                    MISSING_CLIENT_TYPE: "auth/missing-client-type",
                    MISSING_RECAPTCHA_VERSION: "auth/missing-recaptcha-version",
                    INVALID_RECAPTCHA_VERSION: "auth/invalid-recaptcha-version",
                    INVALID_REQ_TYPE: "auth/invalid-req-type"
                }, t.ActionCodeOperation = {
                    EMAIL_SIGNIN: "EMAIL_SIGNIN",
                    PASSWORD_RESET: "PASSWORD_RESET",
                    RECOVER_EMAIL: "RECOVER_EMAIL",
                    REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION",
                    VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL",
                    VERIFY_EMAIL: "VERIFY_EMAIL"
                }, t.ActionCodeURL = qe, t.AuthCredential = Re, t.AuthEventManager = Cn, t.AuthImpl = Ie, t.AuthPopup = Bn, t.EmailAuthCredential = xe, t.EmailAuthProvider = He, t.FacebookAuthProvider = Ge, t.FactorId = {
                    PHONE: "phone",
                    TOTP: "totp"
                }, t.FetchProvider = A, t.GithubAuthProvider = $e, t.GoogleAuthProvider = ze, t.OAuthCredential = Ue, t.OAuthProvider = Ve, t.OperationType = {
                    LINK: "link",
                    REAUTHENTICATE: "reauthenticate",
                    SIGN_IN: "signIn"
                }, t.PhoneAuthCredential = je, t.PhoneAuthProvider = an, t.PhoneMultiFactorGenerator = Zn, t.ProviderId = {
                    FACEBOOK: "facebook.com",
                    GITHUB: "github.com",
                    GOOGLE: "google.com",
                    PASSWORD: "password",
                    PHONE: "phone",
                    TWITTER: "twitter.com"
                }, t.RecaptchaVerifier = class {
                    constructor(e, t = Object.assign({}, rn), n) {
                        this.parameters = t, this.type = nn, this.destroyed = !1, this.widgetId = null, this.tokenChangeListeners = new Set, this.renderPromise = null, this.recaptcha = null, this.auth = Ee(n), this.isInvisible = "invisible" === this.parameters.size, y("undefined" != typeof document, this.auth, "operation-not-supported-in-this-environment");
                        const r = "string" == typeof e ? document.getElementById(e) : e;
                        y(r, this.auth, "argument-error"), this.container = r, this.parameters.callback = this.makeTokenCallback(this.parameters.callback), this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new tn : new en, this.validateStartingState()
                    }
                    async verify() {
                        this.assertNotDestroyed();
                        const e = await this.render(),
                            t = this.getAssertedRecaptcha(),
                            n = t.getResponse(e);
                        return n || new Promise((n => {
                            const r = e => {
                                e && (this.tokenChangeListeners.delete(r), n(e))
                            };
                            this.tokenChangeListeners.add(r), this.isInvisible && t.execute(e)
                        }))
                    }
                    render() {
                        try {
                            this.assertNotDestroyed()
                        } catch (e) {
                            return Promise.reject(e)
                        }
                        return this.renderPromise || (this.renderPromise = this.makeRenderPromise().catch((e => {
                            throw this.renderPromise = null, e
                        }))), this.renderPromise
                    }
                    _reset() {
                        this.assertNotDestroyed(), null !== this.widgetId && this.getAssertedRecaptcha().reset(this.widgetId)
                    }
                    clear() {
                        this.assertNotDestroyed(), this.destroyed = !0, this._recaptchaLoader.clearedOneInstance(), this.isInvisible || this.container.childNodes.forEach((e => {
                            this.container.removeChild(e)
                        }))
                    }
                    validateStartingState() {
                        y(!this.parameters.sitekey, this.auth, "argument-error"), y(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error"), y("undefined" != typeof document, this.auth, "operation-not-supported-in-this-environment")
                    }
                    makeTokenCallback(e) {
                        return t => {
                            if (this.tokenChangeListeners.forEach((e => e(t))), "function" == typeof e) e(t);
                            else if ("string" == typeof e) {
                                const n = Ut()[e];
                                "function" == typeof n && n(t)
                            }
                        }
                    }
                    assertNotDestroyed() {
                        y(!this.destroyed, this.auth, "internal-error")
                    }
                    async makeRenderPromise() {
                        if (await this.init(), !this.widgetId) {
                            let e = this.container;
                            if (!this.isInvisible) {
                                const t = document.createElement("div");
                                e.appendChild(t), e = t
                            }
                            this.widgetId = this.getAssertedRecaptcha().render(e, this.parameters)
                        }
                        return this.widgetId
                    }
                    async init() {
                        y(S() && !Ft(), this.auth, "internal-error"), await
                        function() {
                            let e = null;
                            return new Promise((t => {
                                "complete" !== document.readyState ? (e = () => t(), window.addEventListener("load", e)) : t()
                            })).catch((t => {
                                throw e && window.removeEventListener("load", e), t
                            }))
                        }(), this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || void 0);
                        const e = await async function(e) {
                            return (await k(e, "GET", "/v1/recaptchaParams")).recaptchaSiteKey || ""
                        }(this.auth);
                        y(e, this.auth, "internal-error"), this.parameters.sitekey = e
                    }
                    getAssertedRecaptcha() {
                        return y(this.recaptcha, this.auth, "internal-error"), this.recaptcha
                    }
                }, t.SAMLAuthCredential = Ke, t.SAMLAuthProvider = Ye, t.SignInMethod = {
                    EMAIL_LINK: "emailLink",
                    EMAIL_PASSWORD: "password",
                    FACEBOOK: "facebook.com",
                    GITHUB: "github.com",
                    GOOGLE: "google.com",
                    PHONE: "phone",
                    TWITTER: "twitter.com"
                }, t.TotpMultiFactorGenerator = er, t.TotpSecret = nr, t.TwitterAuthProvider = Je, t.UserImpl = K, t._assert = y, t._castAuth = Ee, t._clearRedirectOutcomes = function() {
                    _n.clear()
                }, t._createError = m, t._fail = f, t._generateEventId = xt, t._getClientVersion = de, t._getInstance = J, t._getProjectConfig = Rn, t._getRedirectResult = Sn, t._getRedirectUrl = Kn, t._isAndroid = se, t._isIOS = ue, t._isIOS7Or8 = function(e = r.getUA()) {
                    return /(iPad|iPhone|iPod).*OS 7_\d/i.test(e) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(e)
                }, t._overrideRedirectResult = bn, t._persistenceKeyName = Z, t.applyActionCode = async function(e, t) {
                    await async function(e, t) {
                        return k(e, "POST", "/v1/accounts:update", O(e, t))
                    }(r.getModularInstance(e), {
                        oobCode: t
                    })
                }, t.beforeAuthStateChanged = St, t.browserLocalPersistence = kt, t.browserPopupRedirectResolver = Jn, t.browserSessionPersistence = Dt, t.checkActionCode = ft, t.confirmPasswordReset = async function(e, t, n) {
                    await Pe(r.getModularInstance(e), {
                        oobCode: t,
                        newPassword: n
                    })
                }, t.connectAuthEmulator = Ce, t.createUserWithEmailAndPassword = async function(e, t, n) {
                    var r;
                    const i = Ee(e),
                        o = {
                            returnSecureToken: !0,
                            email: t,
                            password: n,
                            clientType: "CLIENT_TYPE_WEB"
                        };
                    let s;
                    if (null === (r = i._getRecaptchaConfig()) || void 0 === r ? void 0 : r.emailPasswordEnabled) {
                        const e = await ye(i, o, "signUpPassword");
                        s = Qe(i, e)
                    } else s = Qe(i, o).catch((async e => {
                        if ("auth/missing-recaptcha-token" === e.code) {
                            console.log("Sign-up is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-up flow.");
                            const e = await ye(i, o, "signUpPassword");
                            return Qe(i, e)
                        }
                        return Promise.reject(e)
                    }));
                    const a = await s.catch((e => Promise.reject(e))),
                        c = await Xe._fromIdTokenResponse(i, "signIn", a);
                    return await i._updateCurrentUser(c.user), c
                }, t.debugAssert = I, t.debugErrorMap = u, t.deleteUser = async function(e) {
                    return r.getModularInstance(e).delete()
                }, t.fetchSignInMethodsForEmail =
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                async function(e, t) {
                    const n = {
                            identifier: t,
                            continueUri: S() ? E() : "http://localhost"
                        },
                        {
                            signinMethods: i
                        } =
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        await async function(e, t) {
                            return k(e, "POST", "/v1/accounts:createAuthUri", O(e, t))
                        }(r.getModularInstance(e), n);
                    return i || []
                }, t.getAdditionalUserInfo = function(e) {
                    const {
                        user: t,
                        _tokenResponse: n
                    } = e;
                    return t.isAnonymous && !n ? {
                        providerId: null,
                        isNewUser: !1,
                        profile: null
                    } : function(e) {
                        var t, n;
                        if (!e) return null;
                        const {
                            providerId: r
                        } = e, i = e.rawUserInfo ? JSON.parse(e.rawUserInfo) : {}, o = e.isNewUser || "identitytoolkit#SignupNewUserResponse" === e.kind;
                        if (!r && (null == e ? void 0 : e.idToken)) {
                            const r = null === (n = null === (t = q(e.idToken)) || void 0 === t ? void 0 : t.firebase) || void 0 === n ? void 0 : n.sign_in_provider;
                            if (r) return new gt(o, "anonymous" !== r && "custom" !== r ? r : null)
                        }
                        if (!r) return null;
                        switch (r) {
                            case "facebook.com":
                                return new vt(o, i);
                            case "github.com":
                                return new yt(o, i);
                            case "google.com":
                                return new bt(o, i);
                            case "twitter.com":
                                return new It(o, i, e.screenName || null);
                            case "custom":
                            case "anonymous":
                                return new gt(o, null);
                            default:
                                return new gt(o, r, i)
                        }
                    }(n)
                }
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                , t.getAuth = function(e = i.getApp()) {
                    const t = i._getProvider(e, "auth");
                    if (t.isInitialized()) return t.getImmediate();
                    const n = we(e, {
                            popupRedirectResolver: Jn,
                            persistence: [Kt, kt, Dt]
                        }),
                        o = r.getExperimentalSetting("authTokenSyncURL");
                    if (o) {
                        const e = (s = o, async e => {
                            const t = e && await e.getIdTokenResult(),
                                n = t && ((new Date).getTime() - Date.parse(t.issuedAtTime)) / 1e3;
                            if (n && n > ar) return;
                            const r = null == t ? void 0 : t.token;
                            cr !== r && (cr = r, await fetch(s, {
                                method: r ? "POST" : "DELETE",
                                headers: r ? {
                                    Authorization: `Bearer ${r}`
                                } : {}
                            }))
                        });
                        St(n, e, (() => e(n.currentUser))), Et(n, (t => e(t)))
                    }
                    var s;
                    const a = r.getDefaultEmulatorHost("auth");
                    return a && Ce(n, `http://${a}`), n
                }, t.getIdToken = function(e, t = !1) {
                    return r.getModularInstance(e).getIdToken(t)
                }, t.getIdTokenResult = F, t.getMultiFactorResolver = function(e, t) {
                    var n;
                    const i = r.getModularInstance(e),
                        o = t;
                    return y(t.customData.operationType, i, "argument-error"), y(null === (n = o.customData._serverResponse) || void 0 === n ? void 0 : n.mfaPendingCredential, i, "argument-error"), Ct._fromError(i, o)
                }, t.getRedirectResult = async function(e, t) {
                    return await Ee(e)._initializationPromise, Sn(e, t, !1)
                }, t.inMemoryPersistence = X, t.indexedDBLocalPersistence = Kt, t.initializeAuth = we, t.initializeRecaptchaConfig = function(e) {
                    return Ee(e).initializeRecaptchaConfig()
                }, t.isSignInWithEmailLink = function(e, t) {
                    const n = qe.parseLink(t);
                    return "EMAIL_SIGNIN" === (null == n ? void 0 : n.operation)
                }, t.linkWithCredential = ct, t.linkWithPhoneNumber = async function(e, t, n) {
                    const i = r.getModularInstance(e);
                    await it(!1, i, "phone");
                    const o = await sn(i.auth, t, r.getModularInstance(n));
                    return new on(o, (e => ct(i, e)))
                }, t.linkWithPopup = async function(e, t, n) {
                    const i = r.getModularInstance(e);
                    _(i.auth, t, We);
                    const o = cn(i.auth, n);
                    return new mn(i.auth, "linkViaPopup", t, o, i).executeNotNull()
                }, t.linkWithRedirect = function(e, t, n) {
                    return async function(e, t, n) {
                        const i = r.getModularInstance(e);
                        _(i.auth, t, We), await i.auth._initializationPromise;
                        const o = cn(i.auth, n);
                        await it(!1, i, t.providerId), await yn(o, i.auth);
                        const s = await wn(i);
                        return o._openRedirect(i.auth, t, "linkViaRedirect", s)
                    }(e, t, n)
                }, t.multiFactor = function(e) {
                    const t = r.getModularInstance(e);
                    return At.has(t) || At.set(t, Tt._fromUser(t)), At.get(t)
                }, t.onAuthStateChanged = function(e, t, n, i) {
                    return r.getModularInstance(e).onAuthStateChanged(t, n, i)
                }, t.onIdTokenChanged = Et, t.parseActionCodeURL = function(e) {
                    return qe.parseLink(e)
                }, t.prodErrorMap = l, t.reauthenticateWithCredential = ut, t.reauthenticateWithPhoneNumber = async function(e, t, n) {
                    const i = r.getModularInstance(e),
                        o = await sn(i.auth, t, r.getModularInstance(n));
                    return new on(o, (e => ut(i, e)))
                }, t.reauthenticateWithPopup = async function(e, t, n) {
                    const i = r.getModularInstance(e);
                    _(i.auth, t, We);
                    const o = cn(i.auth, n);
                    return new mn(i.auth, "reauthViaPopup", t, o, i).executeNotNull()
                }, t.reauthenticateWithRedirect = function(e, t, n) {
                    return async function(e, t, n) {
                        const i = r.getModularInstance(e);
                        _(i.auth, t, We), await i.auth._initializationPromise;
                        const o = cn(i.auth, n);
                        await yn(o, i.auth);
                        const s = await wn(i);
                        return o._openRedirect(i.auth, t, "reauthViaRedirect", s)
                    }(e, t, n)
                }, t.reload = G, t.sendEmailVerification = async function(e, t) {
                    const n = r.getModularInstance(e),
                        i = {
                            requestType: "VERIFY_EMAIL",
                            idToken: await e.getIdToken()
                        };
                    t && pt(n.auth, i, t);
                    const {
                        email: o
                    } = await async function(e, t) {
                        return Ne(e, t)
                    }(n.auth, i);
                    o !== e.email && await e.reload()
                }, t.sendPasswordResetEmail = async function(e, t, n) {
                    var r;
                    const i = Ee(e),
                        o = {
                            requestType: "PASSWORD_RESET",
                            email: t,
                            clientType: "CLIENT_TYPE_WEB"
                        };
                    if (null === (r = i._getRecaptchaConfig()) || void 0 === r ? void 0 : r.emailPasswordEnabled) {
                        const e = await ye(i, o, "getOobCode", !0);
                        n && pt(i, e, n), await De(i, e)
                    } else n && pt(i, o, n), await De(i, o).catch((async e => {
                        if ("auth/missing-recaptcha-token" !== e.code) return Promise.reject(e); {
                            console.log("Password resets are protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the password reset flow.");
                            const e = await ye(i, o, "getOobCode", !0);
                            n && pt(i, e, n), await De(i, e)
                        }
                    }))
                }, t.sendSignInLinkToEmail =
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                async function(e, t, n) {
                    var r;
                    const i = Ee(e),
                        o = {
                            requestType: "EMAIL_SIGNIN",
                            email: t,
                            clientType: "CLIENT_TYPE_WEB"
                        };

                    function s(e, t) {
                        y(t.handleCodeInApp, i, "argument-error"), t && pt(i, e, t)
                    }
                    if (null === (r = i._getRecaptchaConfig()) || void 0 === r ? void 0 : r.emailPasswordEnabled) {
                        const e = await ye(i, o, "getOobCode", !0);
                        s(e, n), await Me(i, e)
                    } else s(o, n), await Me(i, o).catch((async e => {
                        if ("auth/missing-recaptcha-token" !== e.code) return Promise.reject(e); {
                            console.log("Email link sign-in is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.");
                            const e = await ye(i, o, "getOobCode", !0);
                            s(e, n), await Me(i, e)
                        }
                    }))
                }, t.setPersistence = function(e, t) {
                    return r.getModularInstance(e).setPersistence(t)
                }, t.signInAnonymously = async function(e) {
                    var t;
                    const n = Ee(e);
                    if (await n._initializationPromise, null === (t = n.currentUser) || void 0 === t ? void 0 : t.isAnonymous) return new Xe({
                        user: n.currentUser,
                        providerId: null,
                        operationType: "signIn"
                    });
                    const r = await Qe(n, {
                            returnSecureToken: !0
                        }),
                        i = await Xe._fromIdTokenResponse(n, "signIn", r, !0);
                    return await n._updateCurrentUser(i.user), i
                }, t.signInWithCredential = at, t.signInWithCustomToken =
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                async function(e, t) {
                    const n = Ee(e),
                        r = await async function(e, t) {
                            return D(e, "POST", "/v1/accounts:signInWithCustomToken", O(e, t))
                        }(n, {
                            token: t,
                            returnSecureToken: !0
                        }),
                        i = await Xe._fromIdTokenResponse(n, "signIn", r);
                    return await n._updateCurrentUser(i.user), i
                }, t.signInWithEmailAndPassword = function(e, t, n) {
                    return at(r.getModularInstance(e), He.credential(t, n))
                }, t.signInWithEmailLink = async function(e, t, n) {
                    const i = r.getModularInstance(e),
                        o = He.credentialWithLink(t, n || E());
                    return y(o._tenantId === (i.tenantId || null), i, "tenant-id-mismatch"), at(i, o)
                }, t.signInWithPhoneNumber = async function(e, t, n) {
                    const i = Ee(e),
                        o = await sn(i, t, r.getModularInstance(n));
                    return new on(o, (e => at(i, e)))
                }, t.signInWithPopup = async function(e, t, n) {
                    const r = Ee(e);
                    _(e, t, We);
                    const i = cn(r, n);
                    return new mn(r, "signInViaPopup", t, i).executeNotNull()
                }, t.signInWithRedirect = function(e, t, n) {
                    return async function(e, t, n) {
                        const r = Ee(e);
                        _(e, t, We), await r._initializationPromise;
                        const i = cn(r, n);
                        return await yn(i, r), i._openRedirect(r, t, "signInViaRedirect")
                    }(e, t, n)
                }, t.signOut = function(e) {
                    return r.getModularInstance(e).signOut()
                }, t.unlink = async function(e, t) {
                    const n = r.getModularInstance(e);
                    await it(!0, n, t);
                    const {
                        providerUserInfo: i
                    } = await async function(e, t) {
                        return k(e, "POST", "/v1/accounts:update", t)
                    }(n.auth, {
                        idToken: await n.getIdToken(),
                        deleteProvider: [t]
                    }), o = nt(i || []);
                    return n.providerData = n.providerData.filter((e => o.has(e.providerId))), o.has("phone") || (n.phoneNumber = null), await n.auth._persistUserIfCurrent(n), n
                }, t.updateCurrentUser = function(e, t) {
                    return r.getModularInstance(e).updateCurrentUser(t)
                }, t.updateEmail = function(e, t) {
                    return mt(r.getModularInstance(e), t, null)
                }, t.updatePassword = function(e, t) {
                    return mt(r.getModularInstance(e), null, t)
                }, t.updatePhoneNumber = async function(e, t) {
                    await rt(r.getModularInstance(e), t)
                }, t.updateProfile =
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                async function(e, {
                    displayName: t,
                    photoURL: n
                }) {
                    if (void 0 === t && void 0 === n) return;
                    const i = r.getModularInstance(e),
                        o = {
                            idToken: await i.getIdToken(),
                            displayName: t,
                            photoUrl: n,
                            returnSecureToken: !0
                        },
                        s = await H(i,
                            /**
                             * @license
                             * Copyright 2020 Google LLC
                             *
                             * Licensed under the Apache License, Version 2.0 (the "License");
                             * you may not use this file except in compliance with the License.
                             * You may obtain a copy of the License at
                             *
                             *   http://www.apache.org/licenses/LICENSE-2.0
                             *
                             * Unless required by applicable law or agreed to in writing, software
                             * distributed under the License is distributed on an "AS IS" BASIS,
                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                             * See the License for the specific language governing permissions and
                             * limitations under the License.
                             */
                            async function(e, t) {
                                return k(e, "POST", "/v1/accounts:update", t)
                            }(i.auth, o));
                    i.displayName = s.displayName || null, i.photoURL = s.photoUrl || null;
                    const a = i.providerData.find((({
                        providerId: e
                    }) => "password" === e));
                    a && (a.displayName = i.displayName, a.photoURL = i.photoURL), await i._updateTokensIfNecessary(s)
                }, t.useDeviceLanguage = function(e) {
                    r.getModularInstance(e).useDeviceLanguage()
                }, t.verifyBeforeUpdateEmail = async function(e, t, n) {
                    const i = r.getModularInstance(e),
                        o = {
                            requestType: "VERIFY_AND_CHANGE_EMAIL",
                            idToken: await e.getIdToken(),
                            newEmail: t
                        };
                    n && pt(i.auth, o, n);
                    const {
                        email: s
                    } = await async function(e, t) {
                        return Ne(e, t)
                    }(i.auth, o);
                    s !== e.email && await e.reload()
                }, t.verifyPasswordResetCode = async function(e, t) {
                    const {
                        data: n
                    } = await ft(r.getModularInstance(e), t);
                    return n.email
                }
        },
        13058: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            var r = n(48660),
                i = n(6789);
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function o() {
                return window
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            n(36022), n(92712), n(35129), n(51656);
            async function s(e, t, n) {
                var i;
                const {
                    BuildInfo: s
                } = o();
                r.debugAssert(t.sessionId, "AuthEvent did not contain a session ID");
                const a = await async function(e) {
                        const t = function(e) {
                            if (r.debugAssert(/[0-9a-zA-Z]+/.test(e), "Can only convert alpha-numeric strings"), "undefined" != typeof TextEncoder) return (new TextEncoder).encode(e);
                            const t = new ArrayBuffer(e.length),
                                n = new Uint8Array(t);
                            for (let t = 0; t < e.length; t++) n[t] = e.charCodeAt(t);
                            return n
                        }
                        /**
                         * @license
                         * Copyright 2020 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        (e), n = await crypto.subtle.digest("SHA-256", t);
                        return Array.from(new Uint8Array(n)).map((e => e.toString(16).padStart(2, "0"))).join("")
                    }(t.sessionId),
                    c = {};
                return r._isIOS() ? c.ibi = s.packageName : r._isAndroid() ? c.apn = s.packageName : r._fail(e, "operation-not-supported-in-this-environment"), s.displayName && (c.appDisplayName = s.displayName), c.sessionId = a, r._getRedirectUrl(e, n, t.type, void 0, null !== (i = t.eventId) && void 0 !== i ? i : void 0, c)
            }
            const a = 20;
            class c extends r.AuthEventManager {
                constructor() {
                    super(...arguments), this.passiveListeners = new Set, this.initPromise = new Promise((e => {
                        this.resolveInialized = e
                    }))
                }
                addPassiveListener(e) {
                    this.passiveListeners.add(e)
                }
                removePassiveListener(e) {
                    this.passiveListeners.delete(e)
                }
                resetRedirect() {
                    this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1
                }
                onEvent(e) {
                    return this.resolveInialized(), this.passiveListeners.forEach((t => t(e))), super.onEvent(e)
                }
                async initialized() {
                    await this.initPromise
                }
            }
            async function u(e) {
                const t = await h()._get(p(e));
                return t && await h()._remove(p(e)), t
            }

            function l(e, t) {
                var n, i;
                const o = function(e) {
                    const t = f(e),
                        n = t.link ? decodeURIComponent(t.link) : void 0,
                        r = f(n).link,
                        i = t.deep_link_id ? decodeURIComponent(t.deep_link_id) : void 0;
                    return f(i).link || i || r || n || e
                }(t);
                if (o.includes("/__/auth/callback")) {
                    const t = f(o),
                        s = t.firebaseError ? function(e) {
                            try {
                                return JSON.parse(e)
                            } catch (e) {
                                return null
                            }
                        }(decodeURIComponent(t.firebaseError)) : null,
                        a = null === (i = null === (n = null == s ? void 0 : s.code) || void 0 === n ? void 0 : n.split("auth/")) || void 0 === i ? void 0 : i[1],
                        c = a ? r._createError(a) : null;
                    return c ? {
                        type: e.type,
                        eventId: e.eventId,
                        tenantId: e.tenantId,
                        error: c,
                        urlResponse: null,
                        sessionId: null,
                        postBody: null
                    } : {
                        type: e.type,
                        eventId: e.eventId,
                        tenantId: e.tenantId,
                        sessionId: e.sessionId,
                        urlResponse: o,
                        postBody: null
                    }
                }
                return null
            }

            function d() {
                const e = [],
                    t = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
                for (let n = 0; n < a; n++) {
                    const n = Math.floor(62 * Math.random());
                    e.push(t.charAt(n))
                }
                return e.join("")
            }

            function h() {
                return r._getInstance(r.browserLocalPersistence)
            }

            function p(e) {
                return r._persistenceKeyName("authEvent", e.config.apiKey, e.name)
            }

            function f(e) {
                if (!(null == e ? void 0 : e.includes("?"))) return {};
                const [t, ...n] = e.split("?");
                return i.querystringDecode(n.join("?"))
            }
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const m = class {
                constructor() {
                    this._redirectPersistence = r.browserSessionPersistence, this._shouldInitProactively = !0, this.eventManagers = new Map, this.originValidationPromises = {}, this._completeRedirectFn = r._getRedirectResult, this._overrideRedirectResult = r._overrideRedirectResult
                }
                async _initialize(e) {
                    const t = e._key();
                    let n = this.eventManagers.get(t);
                    return n || (n = new c(e), this.eventManagers.set(t, n), this.attachCallbackListeners(e, n)), n
                }
                _openPopup(e) {
                    r._fail(e, "operation-not-supported-in-this-environment")
                }
                async _openRedirect(e, t, n, i) {
                    ! function(e) {
                        var t, n, i, s, a, c, u, l, d, h;
                        const p = o();
                        r._assert("function" == typeof(null === (t = null == p ? void 0 : p.universalLinks) || void 0 === t ? void 0 : t.subscribe), e, "invalid-cordova-configuration", {
                            missingPlugin: "cordova-universal-links-plugin-fix"
                        }), r._assert(void 0 !== (null === (n = null == p ? void 0 : p.BuildInfo) || void 0 === n ? void 0 : n.packageName), e, "invalid-cordova-configuration", {
                            missingPlugin: "cordova-plugin-buildInfo"
                        }), r._assert("function" == typeof(null === (a = null === (s = null === (i = null == p ? void 0 : p.cordova) || void 0 === i ? void 0 : i.plugins) || void 0 === s ? void 0 : s.browsertab) || void 0 === a ? void 0 : a.openUrl), e, "invalid-cordova-configuration", {
                            missingPlugin: "cordova-plugin-browsertab"
                        }), r._assert("function" == typeof(null === (l = null === (u = null === (c = null == p ? void 0 : p.cordova) || void 0 === c ? void 0 : c.plugins) || void 0 === u ? void 0 : u.browsertab) || void 0 === l ? void 0 : l.isAvailable), e, "invalid-cordova-configuration", {
                            missingPlugin: "cordova-plugin-browsertab"
                        }), r._assert("function" == typeof(null === (h = null === (d = null == p ? void 0 : p.cordova) || void 0 === d ? void 0 : d.InAppBrowser) || void 0 === h ? void 0 : h.open), e, "invalid-cordova-configuration", {
                            missingPlugin: "cordova-plugin-inappbrowser"
                        })
                    }(e);
                    const a = await this._initialize(e);
                    await a.initialized(), a.resetRedirect(), r._clearRedirectOutcomes(), await this._originValidation(e);
                    const c = function(e, t, n = null) {
                        return {
                            type: t,
                            eventId: n,
                            urlResponse: null,
                            sessionId: d(),
                            postBody: null,
                            tenantId: e.tenantId,
                            error: r._createError(e, "no-auth-event")
                        }
                    }(e, n, i);
                    await
                    function(e, t) {
                        return h()._set(p(e), t)
                    }(e, c);
                    const u = await s(e, c, t);
                    return async function(e, t, n) {
                        const {
                            cordova: i
                        } = o();
                        let s = () => {};
                        try {
                            await new Promise(((o, a) => {
                                let c = null;

                                function u() {
                                    var e;
                                    o();
                                    const t = null === (e = i.plugins.browsertab) || void 0 === e ? void 0 : e.close;
                                    "function" == typeof t && t(), "function" == typeof(null == n ? void 0 : n.close) && n.close()
                                }

                                function l() {
                                    c || (c = window.setTimeout((() => {
                                        a(r._createError(e, "redirect-cancelled-by-user"))
                                    }), 2e3))
                                }

                                function d() {
                                    "visible" === (null === document || void 0 === document ? void 0 : document.visibilityState) && l()
                                }
                                t.addPassiveListener(u), document.addEventListener("resume", l, !1), r._isAndroid() && document.addEventListener("visibilitychange", d, !1), s = () => {
                                    t.removePassiveListener(u), document.removeEventListener("resume", l, !1), document.removeEventListener("visibilitychange", d, !1), c && window.clearTimeout(c)
                                }
                            }))
                        } finally {
                            s()
                        }
                    }(e, a, await
                        function(e) {
                            const {
                                cordova: t
                            } = o();
                            return new Promise((n => {
                                t.plugins.browsertab.isAvailable((i => {
                                    let o = null;
                                    i ? t.plugins.browsertab.openUrl(e) : o = t.InAppBrowser.open(e, r._isIOS7Or8() ? "_blank" : "_system", "location=yes"), n(o)
                                }))
                            }))
                        }(u))
                }
                _isIframeWebStorageSupported(e, t) {
                    throw new Error("Method not implemented.")
                }
                _originValidation(e) {
                    const t = e._key();
                    return this.originValidationPromises[t] || (this.originValidationPromises[t] = async function(e) {
                        const {
                            BuildInfo: t
                        } = o(), n = {};
                        r._isIOS() ? n.iosBundleId = t.packageName : r._isAndroid() ? n.androidPackageName = t.packageName : r._fail(e, "operation-not-supported-in-this-environment"), await r._getProjectConfig(e, n)
                    }(e)), this.originValidationPromises[t]
                }
                attachCallbackListeners(e, t) {
                    const {
                        universalLinks: n,
                        handleOpenURL: r,
                        BuildInfo: i
                    } = o(), s = setTimeout((async () => {
                        await u(e), t.onEvent(g())
                    }), 500), a = async n => {
                        clearTimeout(s);
                        const r = await u(e);
                        let i = null;
                        r && (null == n ? void 0 : n.url) && (i = l(r, n.url)), t.onEvent(i || g())
                    };
                    void 0 !== n && "function" == typeof n.subscribe && n.subscribe(null, a);
                    const c = r,
                        d = `${i.packageName.toLowerCase()}://`;
                    o().handleOpenURL = async e => {
                        if (e.toLowerCase().startsWith(d) && a({
                                url: e
                            }), "function" == typeof c) try {
                            c(e)
                        } catch (e) {
                            console.error(e)
                        }
                    }
                }
            };

            function g() {
                return {
                    type: "unknown",
                    eventId: null,
                    sessionId: null,
                    urlResponse: null,
                    postBody: null,
                    tenantId: null,
                    error: r._createError("no-auth-event")
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            t.ActionCodeOperation = r.ActionCodeOperation, t.ActionCodeURL = r.ActionCodeURL, t.AuthCredential = r.AuthCredential, t.AuthErrorCodes = r.AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY, t.AuthImpl = r.AuthImpl, t.AuthPopup = r.AuthPopup, t.EmailAuthCredential = r.EmailAuthCredential, t.EmailAuthProvider = r.EmailAuthProvider, t.FacebookAuthProvider = r.FacebookAuthProvider, t.FactorId = r.FactorId, t.FetchProvider = r.FetchProvider, t.GithubAuthProvider = r.GithubAuthProvider, t.GoogleAuthProvider = r.GoogleAuthProvider, t.OAuthCredential = r.OAuthCredential, t.OAuthProvider = r.OAuthProvider, t.OperationType = r.OperationType, t.PhoneAuthCredential = r.PhoneAuthCredential, t.PhoneAuthProvider = r.PhoneAuthProvider, t.PhoneMultiFactorGenerator = r.PhoneMultiFactorGenerator, t.ProviderId = r.ProviderId, t.RecaptchaVerifier = r.RecaptchaVerifier, t.SAMLAuthCredential = r.SAMLAuthCredential, t.SAMLAuthProvider = r.SAMLAuthProvider, t.SignInMethod = r.SignInMethod, t.TotpMultiFactorGenerator = r.TotpMultiFactorGenerator, t.TotpSecret = r.TotpSecret, t.TwitterAuthProvider = r.TwitterAuthProvider, t.UserImpl = r.UserImpl, t._assert = r._assert, t._castAuth = r._castAuth, t._fail = r._fail, t._generateEventId = r._generateEventId, t._getClientVersion = r._getClientVersion, t._getInstance = r._getInstance, t._getRedirectResult = r._getRedirectResult, t._overrideRedirectResult = r._overrideRedirectResult, t._persistenceKeyName = r._persistenceKeyName, t.applyActionCode = r.applyActionCode, t.beforeAuthStateChanged = r.beforeAuthStateChanged, t.browserLocalPersistence = r.browserLocalPersistence, t.browserPopupRedirectResolver = r.browserPopupRedirectResolver, t.browserSessionPersistence = r.browserSessionPersistence, t.checkActionCode = r.checkActionCode, t.confirmPasswordReset = r.confirmPasswordReset, t.connectAuthEmulator = r.connectAuthEmulator, t.createUserWithEmailAndPassword = r.createUserWithEmailAndPassword, t.debugErrorMap = r.debugErrorMap, t.deleteUser = r.deleteUser, t.fetchSignInMethodsForEmail = r.fetchSignInMethodsForEmail, t.getAdditionalUserInfo = r.getAdditionalUserInfo, t.getAuth = r.getAuth, t.getIdToken = r.getIdToken, t.getIdTokenResult = r.getIdTokenResult, t.getMultiFactorResolver = r.getMultiFactorResolver, t.getRedirectResult = r.getRedirectResult, t.inMemoryPersistence = r.inMemoryPersistence, t.indexedDBLocalPersistence = r.indexedDBLocalPersistence, t.initializeAuth = r.initializeAuth, t.initializeRecaptchaConfig = r.initializeRecaptchaConfig, t.isSignInWithEmailLink = r.isSignInWithEmailLink, t.linkWithCredential = r.linkWithCredential, t.linkWithPhoneNumber = r.linkWithPhoneNumber, t.linkWithPopup = r.linkWithPopup, t.linkWithRedirect = r.linkWithRedirect, t.multiFactor = r.multiFactor, t.onAuthStateChanged = r.onAuthStateChanged, t.onIdTokenChanged = r.onIdTokenChanged, t.parseActionCodeURL = r.parseActionCodeURL, t.prodErrorMap = r.prodErrorMap, t.reauthenticateWithCredential = r.reauthenticateWithCredential, t.reauthenticateWithPhoneNumber = r.reauthenticateWithPhoneNumber, t.reauthenticateWithPopup = r.reauthenticateWithPopup, t.reauthenticateWithRedirect = r.reauthenticateWithRedirect, t.reload = r.reload, t.sendEmailVerification = r.sendEmailVerification, t.sendPasswordResetEmail = r.sendPasswordResetEmail, t.sendSignInLinkToEmail = r.sendSignInLinkToEmail, t.setPersistence = r.setPersistence, t.signInAnonymously = r.signInAnonymously, t.signInWithCredential = r.signInWithCredential, t.signInWithCustomToken = r.signInWithCustomToken, t.signInWithEmailAndPassword = r.signInWithEmailAndPassword, t.signInWithEmailLink = r.signInWithEmailLink, t.signInWithPhoneNumber = r.signInWithPhoneNumber, t.signInWithPopup = r.signInWithPopup, t.signInWithRedirect = r.signInWithRedirect, t.signOut = r.signOut, t.unlink = r.unlink, t.updateCurrentUser = r.updateCurrentUser, t.updateEmail = r.updateEmail, t.updatePassword = r.updatePassword, t.updatePhoneNumber = r.updatePhoneNumber, t.updateProfile = r.updateProfile, t.useDeviceLanguage = r.useDeviceLanguage, t.verifyBeforeUpdateEmail = r.verifyBeforeUpdateEmail, t.verifyPasswordResetCode = r.verifyPasswordResetCode, t.addFrameworkForLogging = function(e, t) {
                r._castAuth(e)._logFramework(t)
            }, t.cordovaPopupRedirectResolver = m
        },
        51656: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            var r = n(92712),
                i = n(6789),
                o = function() {
                    function e(e, t, n) {
                        this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
                    }
                    return e.prototype.setInstantiationMode = function(e) {
                        return this.instantiationMode = e, this
                    }, e.prototype.setMultipleInstances = function(e) {
                        return this.multipleInstances = e, this
                    }, e.prototype.setServiceProps = function(e) {
                        return this.serviceProps = e, this
                    }, e.prototype.setInstanceCreatedCallback = function(e) {
                        return this.onInstanceCreated = e, this
                    }, e
                }(),
                s = "[DEFAULT]",
                a = function() {
                    function e(e, t) {
                        this.name = e, this.container = t, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
                    }
                    return e.prototype.get = function(e) {
                        var t = this.normalizeInstanceIdentifier(e);
                        if (!this.instancesDeferred.has(t)) {
                            var n = new i.Deferred;
                            if (this.instancesDeferred.set(t, n), this.isInitialized(t) || this.shouldAutoInitialize()) try {
                                var r = this.getOrInitializeService({
                                    instanceIdentifier: t
                                });
                                r && n.resolve(r)
                            } catch (e) {}
                        }
                        return this.instancesDeferred.get(t).promise
                    }, e.prototype.getImmediate = function(e) {
                        var t, n = this.normalizeInstanceIdentifier(null == e ? void 0 : e.identifier),
                            r = null !== (t = null == e ? void 0 : e.optional) && void 0 !== t && t;
                        if (!this.isInitialized(n) && !this.shouldAutoInitialize()) {
                            if (r) return null;
                            throw Error("Service ".concat(this.name, " is not available"))
                        }
                        try {
                            return this.getOrInitializeService({
                                instanceIdentifier: n
                            })
                        } catch (e) {
                            if (r) return null;
                            throw e
                        }
                    }, e.prototype.getComponent = function() {
                        return this.component
                    }, e.prototype.setComponent = function(e) {
                        var t, n;
                        if (e.name !== this.name) throw Error("Mismatching Component ".concat(e.name, " for Provider ").concat(this.name, "."));
                        if (this.component) throw Error("Component for ".concat(this.name, " has already been provided"));
                        if (this.component = e, this.shouldAutoInitialize()) {
                            if (function(e) {
                                    return "EAGER" === e.instantiationMode
                                }
                                /**
                                 * @license
                                 * Copyright 2019 Google LLC
                                 *
                                 * Licensed under the Apache License, Version 2.0 (the "License");
                                 * you may not use this file except in compliance with the License.
                                 * You may obtain a copy of the License at
                                 *
                                 *   http://www.apache.org/licenses/LICENSE-2.0
                                 *
                                 * Unless required by applicable law or agreed to in writing, software
                                 * distributed under the License is distributed on an "AS IS" BASIS,
                                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                 * See the License for the specific language governing permissions and
                                 * limitations under the License.
                                 */
                                (e)) try {
                                this.getOrInitializeService({
                                    instanceIdentifier: s
                                })
                            } catch (e) {}
                            try {
                                for (var i = r.__values(this.instancesDeferred.entries()), o = i.next(); !o.done; o = i.next()) {
                                    var a = r.__read(o.value, 2),
                                        c = a[0],
                                        u = a[1],
                                        l = this.normalizeInstanceIdentifier(c);
                                    try {
                                        var d = this.getOrInitializeService({
                                            instanceIdentifier: l
                                        });
                                        u.resolve(d)
                                    } catch (e) {}
                                }
                            } catch (e) {
                                t = {
                                    error: e
                                }
                            } finally {
                                try {
                                    o && !o.done && (n = i.return) && n.call(i)
                                } finally {
                                    if (t) throw t.error
                                }
                            }
                        }
                    }, e.prototype.clearInstance = function(e) {
                        void 0 === e && (e = s), this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
                    }, e.prototype.delete = function() {
                        return r.__awaiter(this, void 0, void 0, (function() {
                            var e;
                            return r.__generator(this, (function(t) {
                                switch (t.label) {
                                    case 0:
                                        return e = Array.from(this.instances.values()), [4, Promise.all(r.__spreadArray(r.__spreadArray([], r.__read(e.filter((function(e) {
                                            return "INTERNAL" in e
                                        })).map((function(e) {
                                            return e.INTERNAL.delete()
                                        }))), !1), r.__read(e.filter((function(e) {
                                            return "_delete" in e
                                        })).map((function(e) {
                                            return e._delete()
                                        }))), !1))];
                                    case 1:
                                        return t.sent(), [2]
                                }
                            }))
                        }))
                    }, e.prototype.isComponentSet = function() {
                        return null != this.component
                    }, e.prototype.isInitialized = function(e) {
                        return void 0 === e && (e = s), this.instances.has(e)
                    }, e.prototype.getOptions = function(e) {
                        return void 0 === e && (e = s), this.instancesOptions.get(e) || {}
                    }, e.prototype.initialize = function(e) {
                        var t, n;
                        void 0 === e && (e = {});
                        var i = e.options,
                            o = void 0 === i ? {} : i,
                            s = this.normalizeInstanceIdentifier(e.instanceIdentifier);
                        if (this.isInitialized(s)) throw Error("".concat(this.name, "(").concat(s, ") has already been initialized"));
                        if (!this.isComponentSet()) throw Error("Component ".concat(this.name, " has not been registered yet"));
                        var a = this.getOrInitializeService({
                            instanceIdentifier: s,
                            options: o
                        });
                        try {
                            for (var c = r.__values(this.instancesDeferred.entries()), u = c.next(); !u.done; u = c.next()) {
                                var l = r.__read(u.value, 2),
                                    d = l[0],
                                    h = l[1];
                                s === this.normalizeInstanceIdentifier(d) && h.resolve(a)
                            }
                        } catch (e) {
                            t = {
                                error: e
                            }
                        } finally {
                            try {
                                u && !u.done && (n = c.return) && n.call(c)
                            } finally {
                                if (t) throw t.error
                            }
                        }
                        return a
                    }, e.prototype.onInit = function(e, t) {
                        var n, r = this.normalizeInstanceIdentifier(t),
                            i = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set;
                        i.add(e), this.onInitCallbacks.set(r, i);
                        var o = this.instances.get(r);
                        return o && e(o, r),
                            function() {
                                i.delete(e)
                            }
                    }, e.prototype.invokeOnInitCallbacks = function(e, t) {
                        var n, i, o = this.onInitCallbacks.get(t);
                        if (o) try {
                            for (var s = r.__values(o), a = s.next(); !a.done; a = s.next()) {
                                var c = a.value;
                                try {
                                    c(e, t)
                                } catch (e) {}
                            }
                        } catch (e) {
                            n = {
                                error: e
                            }
                        } finally {
                            try {
                                a && !a.done && (i = s.return) && i.call(s)
                            } finally {
                                if (n) throw n.error
                            }
                        }
                    }, e.prototype.getOrInitializeService = function(e) {
                        var t, n = e.instanceIdentifier,
                            r = e.options,
                            i = void 0 === r ? {} : r,
                            o = this.instances.get(n);
                        if (!o && this.component && (o = this.component.instanceFactory(this.container, {
                                instanceIdentifier: (t = n, t === s ? void 0 : t),
                                options: i
                            }), this.instances.set(n, o), this.instancesOptions.set(n, i), this.invokeOnInitCallbacks(o, n), this.component.onInstanceCreated)) try {
                            this.component.onInstanceCreated(this.container, n, o)
                        } catch (e) {}
                        return o || null
                    }, e.prototype.normalizeInstanceIdentifier = function(e) {
                        return void 0 === e && (e = s), this.component ? this.component.multipleInstances ? e : s : e
                    }, e.prototype.shouldAutoInitialize = function() {
                        return !!this.component && "EXPLICIT" !== this.component.instantiationMode
                    }, e
                }();
            var c = function() {
                function e(e) {
                    this.name = e, this.providers = new Map
                }
                return e.prototype.addComponent = function(e) {
                    var t = this.getProvider(e.name);
                    if (t.isComponentSet()) throw new Error("Component ".concat(e.name, " has already been registered with ").concat(this.name));
                    t.setComponent(e)
                }, e.prototype.addOrOverwriteComponent = function(e) {
                    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
                }, e.prototype.getProvider = function(e) {
                    if (this.providers.has(e)) return this.providers.get(e);
                    var t = new a(e, this);
                    return this.providers.set(e, t), t
                }, e.prototype.getProviders = function() {
                    return Array.from(this.providers.values())
                }, e
            }();
            t.Component = o, t.ComponentContainer = c, t.Provider = a
        },
        62961: function(e, t, n) {
            "use strict";
            var r = n(20179),
                i = n(51656),
                o = n(50374),
                s = n(6789),
                a = n(92712),
                c = n(35129);

            function u(e) {
                return e && "object" == typeof e && "default" in e ? e : {
                    default: e
                }
            }
            var l = u(r),
                d = new c.Logger("@firebase/database-compat"),
                h = function(e) {
                    var t = "FIREBASE WARNING: " + e;
                    d.warn(t)
                },
                p = function() {
                    function e(e) {
                        this._delegate = e
                    }
                    return e.prototype.cancel = function(e) {
                        s.validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length), s.validateCallback("OnDisconnect.cancel", "onComplete", e, !0);
                        var t = this._delegate.cancel();
                        return e && t.then((function() {
                            return e(null)
                        }), (function(t) {
                            return e(t)
                        })), t
                    }, e.prototype.remove = function(e) {
                        s.validateArgCount("OnDisconnect.remove", 0, 1, arguments.length), s.validateCallback("OnDisconnect.remove", "onComplete", e, !0);
                        var t = this._delegate.remove();
                        return e && t.then((function() {
                            return e(null)
                        }), (function(t) {
                            return e(t)
                        })), t
                    }, e.prototype.set = function(e, t) {
                        s.validateArgCount("OnDisconnect.set", 1, 2, arguments.length), s.validateCallback("OnDisconnect.set", "onComplete", t, !0);
                        var n = this._delegate.set(e);
                        return t && n.then((function() {
                            return t(null)
                        }), (function(e) {
                            return t(e)
                        })), n
                    }, e.prototype.setWithPriority = function(e, t, n) {
                        s.validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length), s.validateCallback("OnDisconnect.setWithPriority", "onComplete", n, !0);
                        var r = this._delegate.setWithPriority(e, t);
                        return n && r.then((function() {
                            return n(null)
                        }), (function(e) {
                            return n(e)
                        })), r
                    }, e.prototype.update = function(e, t) {
                        if (s.validateArgCount("OnDisconnect.update", 1, 2, arguments.length), Array.isArray(e)) {
                            for (var n = {}, r = 0; r < e.length; ++r) n["" + r] = e[r];
                            e = n, h("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")
                        }
                        s.validateCallback("OnDisconnect.update", "onComplete", t, !0);
                        var i = this._delegate.update(e);
                        return t && i.then((function() {
                            return t(null)
                        }), (function(e) {
                            return t(e)
                        })), i
                    }, e
                }(),
                f = function() {
                    function e(e, t) {
                        this.committed = e, this.snapshot = t
                    }
                    return e.prototype.toJSON = function() {
                        return s.validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length), {
                            committed: this.committed,
                            snapshot: this.snapshot.toJSON()
                        }
                    }, e
                }(),
                m = function() {
                    function e(e, t) {
                        this._database = e, this._delegate = t
                    }
                    return e.prototype.val = function() {
                        return s.validateArgCount("DataSnapshot.val", 0, 0, arguments.length), this._delegate.val()
                    }, e.prototype.exportVal = function() {
                        return s.validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length), this._delegate.exportVal()
                    }, e.prototype.toJSON = function() {
                        return s.validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length), this._delegate.toJSON()
                    }, e.prototype.exists = function() {
                        return s.validateArgCount("DataSnapshot.exists", 0, 0, arguments.length), this._delegate.exists()
                    }, e.prototype.child = function(t) {
                        return s.validateArgCount("DataSnapshot.child", 0, 1, arguments.length), t = String(t), o._validatePathString("DataSnapshot.child", "path", t, !1), new e(this._database, this._delegate.child(t))
                    }, e.prototype.hasChild = function(e) {
                        return s.validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length), o._validatePathString("DataSnapshot.hasChild", "path", e, !1), this._delegate.hasChild(e)
                    }, e.prototype.getPriority = function() {
                        return s.validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length), this._delegate.priority
                    }, e.prototype.forEach = function(t) {
                        var n = this;
                        return s.validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length), s.validateCallback("DataSnapshot.forEach", "action", t, !1), this._delegate.forEach((function(r) {
                            return t(new e(n._database, r))
                        }))
                    }, e.prototype.hasChildren = function() {
                        return s.validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length), this._delegate.hasChildren()
                    }, Object.defineProperty(e.prototype, "key", {
                        get: function() {
                            return this._delegate.key
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.numChildren = function() {
                        return s.validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length), this._delegate.size
                    }, e.prototype.getRef = function() {
                        return s.validateArgCount("DataSnapshot.ref", 0, 0, arguments.length), new _(this._database, this._delegate.ref)
                    }, Object.defineProperty(e.prototype, "ref", {
                        get: function() {
                            return this.getRef()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(),
                g = function() {
                    function e(e, t) {
                        this.database = e, this._delegate = t
                    }
                    return e.prototype.on = function(t, n, r, i) {
                        var a, c = this;
                        s.validateArgCount("Query.on", 2, 4, arguments.length), s.validateCallback("Query.on", "callback", n, !1);
                        var u = e.getCancelAndContextArgs_("Query.on", r, i),
                            l = function(e, t) {
                                n.call(u.context, new m(c.database, e), t)
                            };
                        l.userCallback = n, l.context = u.context;
                        var d = null === (a = u.cancel) || void 0 === a ? void 0 : a.bind(u.context);
                        switch (t) {
                            case "value":
                                return o.onValue(this._delegate, l, d), n;
                            case "child_added":
                                return o.onChildAdded(this._delegate, l, d), n;
                            case "child_removed":
                                return o.onChildRemoved(this._delegate, l, d), n;
                            case "child_changed":
                                return o.onChildChanged(this._delegate, l, d), n;
                            case "child_moved":
                                return o.onChildMoved(this._delegate, l, d), n;
                            default:
                                throw new Error(s.errorPrefix("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".')
                        }
                    }, e.prototype.off = function(e, t, n) {
                        if (s.validateArgCount("Query.off", 0, 3, arguments.length), function(e, t, n) {
                                if (!n || void 0 !== t) switch (t) {
                                    case "value":
                                    case "child_added":
                                    case "child_removed":
                                    case "child_changed":
                                    case "child_moved":
                                        break;
                                    default:
                                        throw new Error(s.errorPrefix(e, "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".')
                                }
                            }("Query.off", e, !0), s.validateCallback("Query.off", "callback", t, !0), s.validateContextObject("Query.off", "context", n, !0), t) {
                            var r = function() {};
                            r.userCallback = t, r.context = n, o.off(this._delegate, e, r)
                        } else o.off(this._delegate, e)
                    }, e.prototype.get = function() {
                        var e = this;
                        return o.get(this._delegate).then((function(t) {
                            return new m(e.database, t)
                        }))
                    }, e.prototype.once = function(t, n, r, i) {
                        var a = this;
                        s.validateArgCount("Query.once", 1, 4, arguments.length), s.validateCallback("Query.once", "callback", n, !0);
                        var c = e.getCancelAndContextArgs_("Query.once", r, i),
                            u = new s.Deferred,
                            l = function(e, t) {
                                var r = new m(a.database, e);
                                n && n.call(c.context, r, t), u.resolve(r)
                            };
                        l.userCallback = n, l.context = c.context;
                        var d = function(e) {
                            c.cancel && c.cancel.call(c.context, e), u.reject(e)
                        };
                        switch (t) {
                            case "value":
                                o.onValue(this._delegate, l, d, {
                                    onlyOnce: !0
                                });
                                break;
                            case "child_added":
                                o.onChildAdded(this._delegate, l, d, {
                                    onlyOnce: !0
                                });
                                break;
                            case "child_removed":
                                o.onChildRemoved(this._delegate, l, d, {
                                    onlyOnce: !0
                                });
                                break;
                            case "child_changed":
                                o.onChildChanged(this._delegate, l, d, {
                                    onlyOnce: !0
                                });
                                break;
                            case "child_moved":
                                o.onChildMoved(this._delegate, l, d, {
                                    onlyOnce: !0
                                });
                                break;
                            default:
                                throw new Error(s.errorPrefix("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".')
                        }
                        return u.promise
                    }, e.prototype.limitToFirst = function(t) {
                        return s.validateArgCount("Query.limitToFirst", 1, 1, arguments.length), new e(this.database, o.query(this._delegate, o.limitToFirst(t)))
                    }, e.prototype.limitToLast = function(t) {
                        return s.validateArgCount("Query.limitToLast", 1, 1, arguments.length), new e(this.database, o.query(this._delegate, o.limitToLast(t)))
                    }, e.prototype.orderByChild = function(t) {
                        return s.validateArgCount("Query.orderByChild", 1, 1, arguments.length), new e(this.database, o.query(this._delegate, o.orderByChild(t)))
                    }, e.prototype.orderByKey = function() {
                        return s.validateArgCount("Query.orderByKey", 0, 0, arguments.length), new e(this.database, o.query(this._delegate, o.orderByKey()))
                    }, e.prototype.orderByPriority = function() {
                        return s.validateArgCount("Query.orderByPriority", 0, 0, arguments.length), new e(this.database, o.query(this._delegate, o.orderByPriority()))
                    }, e.prototype.orderByValue = function() {
                        return s.validateArgCount("Query.orderByValue", 0, 0, arguments.length), new e(this.database, o.query(this._delegate, o.orderByValue()))
                    }, e.prototype.startAt = function(t, n) {
                        return void 0 === t && (t = null), s.validateArgCount("Query.startAt", 0, 2, arguments.length), new e(this.database, o.query(this._delegate, o.startAt(t, n)))
                    }, e.prototype.startAfter = function(t, n) {
                        return void 0 === t && (t = null), s.validateArgCount("Query.startAfter", 0, 2, arguments.length), new e(this.database, o.query(this._delegate, o.startAfter(t, n)))
                    }, e.prototype.endAt = function(t, n) {
                        return void 0 === t && (t = null), s.validateArgCount("Query.endAt", 0, 2, arguments.length), new e(this.database, o.query(this._delegate, o.endAt(t, n)))
                    }, e.prototype.endBefore = function(t, n) {
                        return void 0 === t && (t = null), s.validateArgCount("Query.endBefore", 0, 2, arguments.length), new e(this.database, o.query(this._delegate, o.endBefore(t, n)))
                    }, e.prototype.equalTo = function(t, n) {
                        return s.validateArgCount("Query.equalTo", 1, 2, arguments.length), new e(this.database, o.query(this._delegate, o.equalTo(t, n)))
                    }, e.prototype.toString = function() {
                        return s.validateArgCount("Query.toString", 0, 0, arguments.length), this._delegate.toString()
                    }, e.prototype.toJSON = function() {
                        return s.validateArgCount("Query.toJSON", 0, 1, arguments.length), this._delegate.toJSON()
                    }, e.prototype.isEqual = function(t) {
                        if (s.validateArgCount("Query.isEqual", 1, 1, arguments.length), !(t instanceof e)) {
                            throw new Error("Query.isEqual failed: First argument must be an instance of firebase.database.Query.")
                        }
                        return this._delegate.isEqual(t._delegate)
                    }, e.getCancelAndContextArgs_ = function(e, t, n) {
                        var r = {
                            cancel: void 0,
                            context: void 0
                        };
                        if (t && n) r.cancel = t, s.validateCallback(e, "cancel", r.cancel, !0), r.context = n, s.validateContextObject(e, "context", r.context, !0);
                        else if (t)
                            if ("object" == typeof t && null !== t) r.context = t;
                            else {
                                if ("function" != typeof t) throw new Error(s.errorPrefix(e, "cancelOrContext") + " must either be a cancel callback or a context object.");
                                r.cancel = t
                            }
                        return r
                    }, Object.defineProperty(e.prototype, "ref", {
                        get: function() {
                            return new _(this.database, new o._ReferenceImpl(this._delegate._repo, this._delegate._path))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(),
                _ = function(e) {
                    function t(t, n) {
                        var r = e.call(this, t, new o._QueryImpl(n._repo, n._path, new o._QueryParams, !1)) || this;
                        return r.database = t, r._delegate = n, r
                    }
                    return a.__extends(t, e), t.prototype.getKey = function() {
                        return s.validateArgCount("Reference.key", 0, 0, arguments.length), this._delegate.key
                    }, t.prototype.child = function(e) {
                        return s.validateArgCount("Reference.child", 1, 1, arguments.length), "number" == typeof e && (e = String(e)), new t(this.database, o.child(this._delegate, e))
                    }, t.prototype.getParent = function() {
                        s.validateArgCount("Reference.parent", 0, 0, arguments.length);
                        var e = this._delegate.parent;
                        return e ? new t(this.database, e) : null
                    }, t.prototype.getRoot = function() {
                        return s.validateArgCount("Reference.root", 0, 0, arguments.length), new t(this.database, this._delegate.root)
                    }, t.prototype.set = function(e, t) {
                        s.validateArgCount("Reference.set", 1, 2, arguments.length), s.validateCallback("Reference.set", "onComplete", t, !0);
                        var n = o.set(this._delegate, e);
                        return t && n.then((function() {
                            return t(null)
                        }), (function(e) {
                            return t(e)
                        })), n
                    }, t.prototype.update = function(e, t) {
                        if (s.validateArgCount("Reference.update", 1, 2, arguments.length), Array.isArray(e)) {
                            for (var n = {}, r = 0; r < e.length; ++r) n["" + r] = e[r];
                            e = n, h("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.")
                        }
                        o._validateWritablePath("Reference.update", this._delegate._path), s.validateCallback("Reference.update", "onComplete", t, !0);
                        var i = o.update(this._delegate, e);
                        return t && i.then((function() {
                            return t(null)
                        }), (function(e) {
                            return t(e)
                        })), i
                    }, t.prototype.setWithPriority = function(e, t, n) {
                        s.validateArgCount("Reference.setWithPriority", 2, 3, arguments.length), s.validateCallback("Reference.setWithPriority", "onComplete", n, !0);
                        var r = o.setWithPriority(this._delegate, e, t);
                        return n && r.then((function() {
                            return n(null)
                        }), (function(e) {
                            return n(e)
                        })), r
                    }, t.prototype.remove = function(e) {
                        s.validateArgCount("Reference.remove", 0, 1, arguments.length), s.validateCallback("Reference.remove", "onComplete", e, !0);
                        var t = o.remove(this._delegate);
                        return e && t.then((function() {
                            return e(null)
                        }), (function(t) {
                            return e(t)
                        })), t
                    }, t.prototype.transaction = function(e, t, n) {
                        var r = this;
                        s.validateArgCount("Reference.transaction", 1, 3, arguments.length), s.validateCallback("Reference.transaction", "transactionUpdate", e, !1), s.validateCallback("Reference.transaction", "onComplete", t, !0),
                            function(e, t, n, r) {
                                if ((!r || void 0 !== n) && "boolean" != typeof n) throw new Error(s.errorPrefix(e, t) + "must be a boolean.")
                            }("Reference.transaction", "applyLocally", n, !0);
                        var i = o.runTransaction(this._delegate, e, {
                            applyLocally: n
                        }).then((function(e) {
                            return new f(e.committed, new m(r.database, e.snapshot))
                        }));
                        return t && i.then((function(e) {
                            return t(null, e.committed, e.snapshot)
                        }), (function(e) {
                            return t(e, !1, null)
                        })), i
                    }, t.prototype.setPriority = function(e, t) {
                        s.validateArgCount("Reference.setPriority", 1, 2, arguments.length), s.validateCallback("Reference.setPriority", "onComplete", t, !0);
                        var n = o.setPriority(this._delegate, e);
                        return t && n.then((function() {
                            return t(null)
                        }), (function(e) {
                            return t(e)
                        })), n
                    }, t.prototype.push = function(e, n) {
                        var r = this;
                        s.validateArgCount("Reference.push", 0, 2, arguments.length), s.validateCallback("Reference.push", "onComplete", n, !0);
                        var i = o.push(this._delegate, e),
                            a = i.then((function(e) {
                                return new t(r.database, e)
                            }));
                        n && a.then((function() {
                            return n(null)
                        }), (function(e) {
                            return n(e)
                        }));
                        var c = new t(this.database, i);
                        return c.then = a.then.bind(a), c.catch = a.catch.bind(a, void 0), c
                    }, t.prototype.onDisconnect = function() {
                        return o._validateWritablePath("Reference.onDisconnect", this._delegate._path), new p(new o.OnDisconnect(this._delegate._repo, this._delegate._path))
                    }, Object.defineProperty(t.prototype, "key", {
                        get: function() {
                            return this.getKey()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "parent", {
                        get: function() {
                            return this.getParent()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "root", {
                        get: function() {
                            return this.getRoot()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(g),
                v = function() {
                    function e(e, t) {
                        var n = this;
                        this._delegate = e, this.app = t, this.INTERNAL = {
                            delete: function() {
                                return n._delegate._delete()
                            },
                            forceWebSockets: o.forceWebSockets,
                            forceLongPolling: o.forceLongPolling
                        }
                    }
                    return e.prototype.useEmulator = function(e, t, n) {
                        void 0 === n && (n = {}), o.connectDatabaseEmulator(this._delegate, e, t, n)
                    }, e.prototype.ref = function(e) {
                        if (s.validateArgCount("database.ref", 0, 1, arguments.length), e instanceof _) {
                            var t = o.refFromURL(this._delegate, e.toString());
                            return new _(this, t)
                        }
                        t = o.ref(this._delegate, e);
                        return new _(this, t)
                    }, e.prototype.refFromURL = function(e) {
                        s.validateArgCount("database.refFromURL", 1, 1, arguments.length);
                        var t = o.refFromURL(this._delegate, e);
                        return new _(this, t)
                    }, e.prototype.goOffline = function() {
                        return s.validateArgCount("database.goOffline", 0, 0, arguments.length), o.goOffline(this._delegate)
                    }, e.prototype.goOnline = function() {
                        return s.validateArgCount("database.goOnline", 0, 0, arguments.length), o.goOnline(this._delegate)
                    }, e.ServerValue = {
                        TIMESTAMP: o.serverTimestamp(),
                        increment: function(e) {
                            return o.increment(e)
                        }
                    }, e
                }();
            var y, b = Object.freeze({
                    __proto__: null,
                    initStandalone:
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        function(e) {
                            var t = e.app,
                                n = e.url,
                                r = e.version,
                                s = e.customAuthImpl,
                                a = e.namespace,
                                c = e.nodeAdmin,
                                u = void 0 !== c && c;
                            o._setSDKVersion(r);
                            var l = new i.Provider("auth-internal", new i.ComponentContainer("database-standalone"));
                            return l.setComponent(new i.Component("auth-internal", (function() {
                                return s
                            }), "PRIVATE")), {
                                instance: new v(o._repoManagerDatabaseFromApp(t, l, void 0, n, u), t),
                                namespace: a
                            }
                        }
                }),
                I = v.ServerValue;
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            (y = l.default).INTERNAL.registerComponent(new i.Component("database-compat", (function(e, t) {
                var n = t.instanceIdentifier,
                    r = e.getProvider("app-compat").getImmediate(),
                    i = e.getProvider("database").getImmediate({
                        identifier: n
                    });
                return new v(i, r)
            }), "PUBLIC").setServiceProps({
                Reference: _,
                Query: g,
                Database: v,
                DataSnapshot: m,
                enableLogging: o.enableLogging,
                INTERNAL: b,
                ServerValue: I
            }).setMultipleInstances(!0)), y.registerVersion("@firebase/database-compat", "0.3.4", "node")
        },
        50374: function(e, t, n) {
            "use strict";
            var r = n(13158);
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            var i = n(36022),
                o = n(51656),
                s = n(6789),
                a = n(35129);
            const c = "@firebase/database",
                u = "0.14.4";
            /**
             * @license
             * Copyright 2019 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let l = "";

            function d(e) {
                l = e
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class h {
                constructor(e) {
                    this.domStorage_ = e, this.prefix_ = "firebase:"
                }
                set(e, t) {
                    null == t ? this.domStorage_.removeItem(this.prefixedName_(e)) : this.domStorage_.setItem(this.prefixedName_(e), s.stringify(t))
                }
                get(e) {
                    const t = this.domStorage_.getItem(this.prefixedName_(e));
                    return null == t ? null : s.jsonEval(t)
                }
                remove(e) {
                    this.domStorage_.removeItem(this.prefixedName_(e))
                }
                prefixedName_(e) {
                    return this.prefix_ + e
                }
                toString() {
                    return this.domStorage_.toString()
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class p {
                constructor() {
                    this.cache_ = {}, this.isInMemoryStorage = !0
                }
                set(e, t) {
                    null == t ? delete this.cache_[e] : this.cache_[e] = t
                }
                get(e) {
                    return s.contains(this.cache_, e) ? this.cache_[e] : null
                }
                remove(e) {
                    delete this.cache_[e]
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const f = function(e) {
                    try {
                        if ("undefined" != typeof window && void 0 !== window[e]) {
                            const t = window[e];
                            return t.setItem("firebase:sentinel", "cache"), t.removeItem("firebase:sentinel"), new h(t)
                        }
                    } catch (e) {}
                    return new p
                },
                m = f("localStorage"),
                g = f("sessionStorage"),
                _ = new a.Logger("@firebase/database"),
                v = function() {
                    let e = 1;
                    return function() {
                        return e++
                    }
                }(),
                y = function(e) {
                    const t = s.stringToByteArray(e),
                        n = new s.Sha1;
                    n.update(t);
                    const r = n.digest();
                    return s.base64.encodeByteArray(r)
                },
                b = function(...e) {
                    let t = "";
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n];
                        Array.isArray(r) || r && "object" == typeof r && "number" == typeof r.length ? t += b.apply(null, r) : t += "object" == typeof r ? s.stringify(r) : r, t += " "
                    }
                    return t
                };
            let I = null,
                E = !0;
            const S = function(e, t) {
                    s.assert(!t || !0 === e || !1 === e, "Can't turn on custom loggers persistently."), !0 === e ? (_.logLevel = a.LogLevel.VERBOSE, I = _.log.bind(_), t && g.set("logging_enabled", !0)) : "function" == typeof e ? I = e : (I = null, g.remove("logging_enabled"))
                },
                w = function(...e) {
                    if (!0 === E && (E = !1, null === I && !0 === g.get("logging_enabled") && S(!0)), I) {
                        const t = b.apply(null, e);
                        I(t)
                    }
                },
                C = function(e) {
                    return function(...t) {
                        w(e, ...t)
                    }
                },
                T = function(...e) {
                    const t = "FIREBASE INTERNAL ERROR: " + b(...e);
                    _.error(t)
                },
                A = function(...e) {
                    const t = `FIREBASE FATAL ERROR: ${b(...e)}`;
                    throw _.error(t), new Error(t)
                },
                R = function(...e) {
                    const t = "FIREBASE WARNING: " + b(...e);
                    _.warn(t)
                },
                P = function(e) {
                    return "number" == typeof e && (e != e || e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY)
                },
                O = "[MIN_NAME]",
                k = "[MAX_NAME]",
                N = function(e, t) {
                    if (e === t) return 0;
                    if (e === O || t === k) return -1;
                    if (t === O || e === k) return 1; {
                        const n = q(e),
                            r = q(t);
                        return null !== n ? null !== r ? n - r == 0 ? e.length - t.length : n - r : -1 : null !== r ? 1 : e < t ? -1 : 1
                    }
                },
                D = function(e, t) {
                    return e === t ? 0 : e < t ? -1 : 1
                },
                M = function(e, t) {
                    if (t && e in t) return t[e];
                    throw new Error("Missing required key (" + e + ") in object: " + s.stringify(t))
                },
                x = function(e) {
                    if ("object" != typeof e || null === e) return s.stringify(e);
                    const t = [];
                    for (const n in e) t.push(n);
                    t.sort();
                    let n = "{";
                    for (let r = 0; r < t.length; r++) 0 !== r && (n += ","), n += s.stringify(t[r]), n += ":", n += x(e[t[r]]);
                    return n += "}", n
                },
                L = function(e, t) {
                    const n = e.length;
                    if (n <= t) return [e];
                    const r = [];
                    for (let i = 0; i < n; i += t) i + t > n ? r.push(e.substring(i, n)) : r.push(e.substring(i, i + t));
                    return r
                };

            function U(e, t) {
                for (const n in e) e.hasOwnProperty(n) && t(n, e[n])
            }
            const F = function(e) {
                s.assert(!P(e), "Invalid JSON number");
                const t = 1023;
                let n, r, i, o, a;
                0 === e ? (r = 0, i = 0, n = 1 / e == -1 / 0 ? 1 : 0) : (n = e < 0, (e = Math.abs(e)) >= Math.pow(2, -1022) ? (o = Math.min(Math.floor(Math.log(e) / Math.LN2), t), r = o + t, i = Math.round(e * Math.pow(2, 52 - o) - Math.pow(2, 52))) : (r = 0, i = Math.round(e / Math.pow(2, -1074))));
                const c = [];
                for (a = 52; a; a -= 1) c.push(i % 2 ? 1 : 0), i = Math.floor(i / 2);
                for (a = 11; a; a -= 1) c.push(r % 2 ? 1 : 0), r = Math.floor(r / 2);
                c.push(n ? 1 : 0), c.reverse();
                const u = c.join("");
                let l = "";
                for (a = 0; a < 64; a += 8) {
                    let e = parseInt(u.substr(a, 8), 2).toString(16);
                    1 === e.length && (e = "0" + e), l += e
                }
                return l.toLowerCase()
            };
            const j = new RegExp("^-?(0*)\\d{1,10}$"),
                q = function(e) {
                    if (j.test(e)) {
                        const t = Number(e);
                        if (t >= -2147483648 && t <= 2147483647) return t
                    }
                    return null
                },
                H = function(e) {
                    try {
                        e()
                    } catch (e) {
                        setTimeout((() => {
                            const t = e.stack || "";
                            throw R("Exception was thrown by user callback.", t), e
                        }), Math.floor(0))
                    }
                },
                W = function(e, t) {
                    const n = setTimeout(e, t);
                    return "number" == typeof n && "undefined" != typeof Deno && Deno.unrefTimer ? Deno.unrefTimer(n) : "object" == typeof n && n.unref && n.unref(), n
                };
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class B {
                constructor(e, t) {
                    this.appName_ = e, this.appCheckProvider = t, this.appCheck = null == t ? void 0 : t.getImmediate({
                        optional: !0
                    }), this.appCheck || null == t || t.get().then((e => this.appCheck = e))
                }
                getToken(e) {
                    return this.appCheck ? this.appCheck.getToken(e) : new Promise(((t, n) => {
                        setTimeout((() => {
                            this.appCheck ? this.getToken(e).then(t, n) : t(null)
                        }), 0)
                    }))
                }
                addTokenChangeListener(e) {
                    var t;
                    null === (t = this.appCheckProvider) || void 0 === t || t.get().then((t => t.addTokenListener(e)))
                }
                notifyForInvalidToken() {
                    R(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class V {
                constructor(e, t, n) {
                    this.appName_ = e, this.firebaseOptions_ = t, this.authProvider_ = n, this.auth_ = null, this.auth_ = n.getImmediate({
                        optional: !0
                    }), this.auth_ || n.onInit((e => this.auth_ = e))
                }
                getToken(e) {
                    return this.auth_ ? this.auth_.getToken(e).catch((e => e && "auth/token-not-initialized" === e.code ? (w("Got auth/token-not-initialized error.  Treating as null token."), null) : Promise.reject(e))) : new Promise(((t, n) => {
                        setTimeout((() => {
                            this.auth_ ? this.getToken(e).then(t, n) : t(null)
                        }), 0)
                    }))
                }
                addTokenChangeListener(e) {
                    this.auth_ ? this.auth_.addAuthTokenListener(e) : this.authProvider_.get().then((t => t.addAuthTokenListener(e)))
                }
                removeTokenChangeListener(e) {
                    this.authProvider_.get().then((t => t.removeAuthTokenListener(e)))
                }
                notifyForInvalidToken() {
                    let e = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
                    "credential" in this.firebaseOptions_ ? e += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : "serviceAccount" in this.firebaseOptions_ ? e += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.' : e += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.', R(e)
                }
            }
            class G {
                constructor(e) {
                    this.accessToken = e
                }
                getToken(e) {
                    return Promise.resolve({
                        accessToken: this.accessToken
                    })
                }
                addTokenChangeListener(e) {
                    e(this.accessToken)
                }
                removeTokenChangeListener(e) {}
                notifyForInvalidToken() {}
            }
            G.OWNER = "owner";
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const z = "5",
                $ = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/,
                K = "ac",
                Y = "websocket",
                J = "long_polling";
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Q {
                constructor(e, t, n, r, i = !1, o = "", s = !1, a = !1) {
                    this.secure = t, this.namespace = n, this.webSocketOnly = r, this.nodeAdmin = i, this.persistenceKey = o, this.includeNamespaceInQueryParams = s, this.isUsingEmulator = a, this._host = e.toLowerCase(), this._domain = this._host.substr(this._host.indexOf(".") + 1), this.internalHost = m.get("host:" + e) || this._host
                }
                isCacheableHost() {
                    return "s-" === this.internalHost.substr(0, 2)
                }
                isCustomHost() {
                    return "firebaseio.com" !== this._domain && "firebaseio-demo.com" !== this._domain
                }
                get host() {
                    return this._host
                }
                set host(e) {
                    e !== this.internalHost && (this.internalHost = e, this.isCacheableHost() && m.set("host:" + this._host, this.internalHost))
                }
                toString() {
                    let e = this.toURLString();
                    return this.persistenceKey && (e += "<" + this.persistenceKey + ">"), e
                }
                toURLString() {
                    const e = this.secure ? "https://" : "http://",
                        t = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
                    return `${e}${this.host}/${t}`
                }
            }

            function X(e, t, n) {
                let r;
                if (s.assert("string" == typeof t, "typeof type must == string"), s.assert("object" == typeof n, "typeof params must == object"), t === Y) r = (e.secure ? "wss://" : "ws://") + e.internalHost + "/.ws?";
                else {
                    if (t !== J) throw new Error("Unknown connection type: " + t);
                    r = (e.secure ? "https://" : "http://") + e.internalHost + "/.lp?"
                }(function(e) {
                    return e.host !== e.internalHost || e.isCustomHost() || e.includeNamespaceInQueryParams
                })(e) && (n.ns = e.namespace);
                const i = [];
                return U(n, ((e, t) => {
                    i.push(e + "=" + t)
                })), r + i.join("&")
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Z {
                constructor() {
                    this.counters_ = {}
                }
                incrementCounter(e, t = 1) {
                    s.contains(this.counters_, e) || (this.counters_[e] = 0), this.counters_[e] += t
                }
                get() {
                    return s.deepCopy(this.counters_)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const ee = {},
                te = {};

            function ne(e) {
                const t = e.toString();
                return ee[t] || (ee[t] = new Z), ee[t]
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class re {
                constructor(e) {
                    this.onMessage_ = e, this.pendingResponses = [], this.currentResponseNum = 0, this.closeAfterResponse = -1, this.onClose = null
                }
                closeAfter(e, t) {
                    this.closeAfterResponse = e, this.onClose = t, this.closeAfterResponse < this.currentResponseNum && (this.onClose(), this.onClose = null)
                }
                handleResponse(e, t) {
                    for (this.pendingResponses[e] = t; this.pendingResponses[this.currentResponseNum];) {
                        const e = this.pendingResponses[this.currentResponseNum];
                        delete this.pendingResponses[this.currentResponseNum];
                        for (let t = 0; t < e.length; ++t) e[t] && H((() => {
                            this.onMessage_(e[t])
                        }));
                        if (this.currentResponseNum === this.closeAfterResponse) {
                            this.onClose && (this.onClose(), this.onClose = null);
                            break
                        }
                        this.currentResponseNum++
                    }
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const ie = "start";
            class oe {
                constructor(e, t, n, r, i, o, s) {
                    this.connId = e, this.repoInfo = t, this.applicationId = n, this.appCheckToken = r, this.authToken = i, this.transportSessionId = o, this.lastSessionId = s, this.bytesSent = 0, this.bytesReceived = 0, this.everConnected_ = !1, this.log_ = C(e), this.stats_ = ne(t), this.urlFn = e => (this.appCheckToken && (e[K] = this.appCheckToken), X(t, J, e))
                }
                open(e, t) {
                    this.curSegmentNum = 0, this.onDisconnect_ = t, this.myPacketOrderer = new re(e), this.isClosed_ = !1, this.connectTimeoutTimer_ = setTimeout((() => {
                            this.log_("Timed out trying to connect."), this.onClosed_(), this.connectTimeoutTimer_ = null
                        }), Math.floor(3e4)),
                        function(e) {
                            if (s.isNodeSdk() || "complete" === document.readyState) e();
                            else {
                                let t = !1;
                                const n = function() {
                                    document.body ? t || (t = !0, e()) : setTimeout(n, Math.floor(10))
                                };
                                document.addEventListener ? (document.addEventListener("DOMContentLoaded", n, !1), window.addEventListener("load", n, !1)) : document.attachEvent && (document.attachEvent("onreadystatechange", (() => {
                                    "complete" === document.readyState && n()
                                })), window.attachEvent("onload", n))
                            }
                        }((() => {
                            if (this.isClosed_) return;
                            this.scriptTagHolder = new se(((...e) => {
                                const [t, n, r, i, o] = e;
                                if (this.incrementIncomingBytes_(e), this.scriptTagHolder)
                                    if (this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null), this.everConnected_ = !0, t === ie) this.id = n, this.password = r;
                                    else {
                                        if ("close" !== t) throw new Error("Unrecognized command received: " + t);
                                        n ? (this.scriptTagHolder.sendNewPolls = !1, this.myPacketOrderer.closeAfter(n, (() => {
                                            this.onClosed_()
                                        }))) : this.onClosed_()
                                    }
                            }), ((...e) => {
                                const [t, n] = e;
                                this.incrementIncomingBytes_(e), this.myPacketOrderer.handleResponse(t, n)
                            }), (() => {
                                this.onClosed_()
                            }), this.urlFn);
                            const e = {};
                            e[ie] = "t", e.ser = Math.floor(1e8 * Math.random()), this.scriptTagHolder.uniqueCallbackIdentifier && (e.cb = this.scriptTagHolder.uniqueCallbackIdentifier), e.v = z, this.transportSessionId && (e.s = this.transportSessionId), this.lastSessionId && (e.ls = this.lastSessionId), this.applicationId && (e.p = this.applicationId), this.appCheckToken && (e[K] = this.appCheckToken), "undefined" != typeof location && location.hostname && $.test(location.hostname) && (e.r = "f");
                            const t = this.urlFn(e);
                            this.log_("Connecting via long-poll to " + t), this.scriptTagHolder.addTag(t, (() => {}))
                        }))
                }
                start() {
                    this.scriptTagHolder.startLongPoll(this.id, this.password), this.addDisconnectPingFrame(this.id, this.password)
                }
                static forceAllow() {
                    oe.forceAllow_ = !0
                }
                static forceDisallow() {
                    oe.forceDisallow_ = !0
                }
                static isAvailable() {
                    return !s.isNodeSdk() && (!!oe.forceAllow_ || !(oe.forceDisallow_ || "undefined" == typeof document || null == document.createElement || "object" == typeof window && window.chrome && window.chrome.extension && !/^chrome/.test(window.location.href) || "object" == typeof Windows && "object" == typeof Windows.UI))
                }
                markConnectionHealthy() {}
                shutdown_() {
                    this.isClosed_ = !0, this.scriptTagHolder && (this.scriptTagHolder.close(), this.scriptTagHolder = null), this.myDisconnFrame && (document.body.removeChild(this.myDisconnFrame), this.myDisconnFrame = null), this.connectTimeoutTimer_ && (clearTimeout(this.connectTimeoutTimer_), this.connectTimeoutTimer_ = null)
                }
                onClosed_() {
                    this.isClosed_ || (this.log_("Longpoll is closing itself"), this.shutdown_(), this.onDisconnect_ && (this.onDisconnect_(this.everConnected_), this.onDisconnect_ = null))
                }
                close() {
                    this.isClosed_ || (this.log_("Longpoll is being closed."), this.shutdown_())
                }
                send(e) {
                    const t = s.stringify(e);
                    this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length);
                    const n = s.base64Encode(t),
                        r = L(n, 1840);
                    for (let e = 0; e < r.length; e++) this.scriptTagHolder.enqueueSegment(this.curSegmentNum, r.length, r[e]), this.curSegmentNum++
                }
                addDisconnectPingFrame(e, t) {
                    if (s.isNodeSdk()) return;
                    this.myDisconnFrame = document.createElement("iframe");
                    const n = {
                        dframe: "t"
                    };
                    n.id = e, n.pw = t, this.myDisconnFrame.src = this.urlFn(n), this.myDisconnFrame.style.display = "none", document.body.appendChild(this.myDisconnFrame)
                }
                incrementIncomingBytes_(e) {
                    const t = s.stringify(e).length;
                    this.bytesReceived += t, this.stats_.incrementCounter("bytes_received", t)
                }
            }
            class se {
                constructor(e, t, n, r) {
                    if (this.onDisconnect = n, this.urlFn = r, this.outstandingRequests = new Set, this.pendingSegs = [], this.currentSerial = Math.floor(1e8 * Math.random()), this.sendNewPolls = !0, s.isNodeSdk()) this.commandCB = e, this.onMessageCB = t;
                    else {
                        this.uniqueCallbackIdentifier = v(), window["pLPCommand" + this.uniqueCallbackIdentifier] = e, window["pRTLPCB" + this.uniqueCallbackIdentifier] = t, this.myIFrame = se.createIFrame_();
                        let n = "";
                        if (this.myIFrame.src && "javascript:" === this.myIFrame.src.substr(0, 11)) {
                            n = '<script>document.domain="' + document.domain + '";<\/script>'
                        }
                        const r = "<html><body>" + n + "</body></html>";
                        try {
                            this.myIFrame.doc.open(), this.myIFrame.doc.write(r), this.myIFrame.doc.close()
                        } catch (e) {
                            w("frame writing exception"), e.stack && w(e.stack), w(e)
                        }
                    }
                }
                static createIFrame_() {
                    const e = document.createElement("iframe");
                    if (e.style.display = "none", !document.body) throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
                    document.body.appendChild(e);
                    try {
                        e.contentWindow.document || w("No IE domain setting required")
                    } catch (t) {
                        const n = document.domain;
                        e.src = "javascript:void((function(){document.open();document.domain='" + n + "';document.close();})())"
                    }
                    return e.contentDocument ? e.doc = e.contentDocument : e.contentWindow ? e.doc = e.contentWindow.document : e.document && (e.doc = e.document), e
                }
                close() {
                    this.alive = !1, this.myIFrame && (this.myIFrame.doc.body.textContent = "", setTimeout((() => {
                        null !== this.myIFrame && (document.body.removeChild(this.myIFrame), this.myIFrame = null)
                    }), Math.floor(0)));
                    const e = this.onDisconnect;
                    e && (this.onDisconnect = null, e())
                }
                startLongPoll(e, t) {
                    for (this.myID = e, this.myPW = t, this.alive = !0; this.newRequest_(););
                }
                newRequest_() {
                    if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
                        this.currentSerial++;
                        const e = {};
                        e.id = this.myID, e.pw = this.myPW, e.ser = this.currentSerial;
                        let t = this.urlFn(e),
                            n = "",
                            r = 0;
                        for (; this.pendingSegs.length > 0;) {
                            if (!(this.pendingSegs[0].d.length + 30 + n.length <= 1870)) break; {
                                const e = this.pendingSegs.shift();
                                n = n + "&seg" + r + "=" + e.seg + "&ts" + r + "=" + e.ts + "&d" + r + "=" + e.d, r++
                            }
                        }
                        return t += n, this.addLongPollTag_(t, this.currentSerial), !0
                    }
                    return !1
                }
                enqueueSegment(e, t, n) {
                    this.pendingSegs.push({
                        seg: e,
                        ts: t,
                        d: n
                    }), this.alive && this.newRequest_()
                }
                addLongPollTag_(e, t) {
                    this.outstandingRequests.add(t);
                    const n = () => {
                            this.outstandingRequests.delete(t), this.newRequest_()
                        },
                        r = setTimeout(n, Math.floor(25e3));
                    this.addTag(e, (() => {
                        clearTimeout(r), n()
                    }))
                }
                addTag(e, t) {
                    s.isNodeSdk() ? this.doNodeLongPoll(e, t) : setTimeout((() => {
                        try {
                            if (!this.sendNewPolls) return;
                            const n = this.myIFrame.doc.createElement("script");
                            n.type = "text/javascript", n.async = !0, n.src = e, n.onload = n.onreadystatechange = function() {
                                const e = n.readyState;
                                e && "loaded" !== e && "complete" !== e || (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), t())
                            }, n.onerror = () => {
                                w("Long-poll script failed to load: " + e), this.sendNewPolls = !1, this.close()
                            }, this.myIFrame.doc.body.appendChild(n)
                        } catch (e) {}
                    }), Math.floor(1))
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let ae = null;
            "undefined" != typeof MozWebSocket ? ae = MozWebSocket : "undefined" != typeof WebSocket && (ae = WebSocket);
            class ce {
                constructor(e, t, n, r, i, o, s) {
                    this.connId = e, this.applicationId = n, this.appCheckToken = r, this.authToken = i, this.keepaliveTimer = null, this.frames = null, this.totalFrames = 0, this.bytesSent = 0, this.bytesReceived = 0, this.log_ = C(this.connId), this.stats_ = ne(t), this.connURL = ce.connectionURL_(t, o, s, r, n), this.nodeAdmin = t.nodeAdmin
                }
                static connectionURL_(e, t, n, r, i) {
                    const o = {};
                    return o.v = z, !s.isNodeSdk() && "undefined" != typeof location && location.hostname && $.test(location.hostname) && (o.r = "f"), t && (o.s = t), n && (o.ls = n), r && (o[K] = r), i && (o.p = i), X(e, Y, o)
                }
                open(e, t) {
                    this.onDisconnect = t, this.onMessage = e, this.log_("Websocket connecting to " + this.connURL), this.everConnected_ = !1, m.set("previous_websocket_failure", !0);
                    try {
                        let e;
                        if (s.isNodeSdk()) {
                            const t = this.nodeAdmin ? "AdminNode" : "Node";
                            e = {
                                headers: {
                                    "User-Agent": `Firebase/${z}/${l}/${r.platform}/${t}`,
                                    "X-Firebase-GMPID": this.applicationId || ""
                                }
                            }, this.authToken && (e.headers.Authorization = `Bearer ${this.authToken}`), this.appCheckToken && (e.headers["X-Firebase-AppCheck"] = this.appCheckToken);
                            const n = r.env,
                                i = 0 === this.connURL.indexOf("wss://") ? n.HTTPS_PROXY || n.https_proxy : n.HTTP_PROXY || n.http_proxy;
                            i && (e.proxy = {
                                origin: i
                            })
                        }
                        this.mySock = new ae(this.connURL, [], e)
                    } catch (e) {
                        this.log_("Error instantiating WebSocket.");
                        const t = e.message || e.data;
                        return t && this.log_(t), void this.onClosed_()
                    }
                    this.mySock.onopen = () => {
                        this.log_("Websocket connected."), this.everConnected_ = !0
                    }, this.mySock.onclose = () => {
                        this.log_("Websocket connection was disconnected."), this.mySock = null, this.onClosed_()
                    }, this.mySock.onmessage = e => {
                        this.handleIncomingFrame(e)
                    }, this.mySock.onerror = e => {
                        this.log_("WebSocket error.  Closing connection.");
                        const t = e.message || e.data;
                        t && this.log_(t), this.onClosed_()
                    }
                }
                start() {}
                static forceDisallow() {
                    ce.forceDisallow_ = !0
                }
                static isAvailable() {
                    let e = !1;
                    if ("undefined" != typeof navigator && navigator.userAgent) {
                        const t = /Android ([0-9]{0,}\.[0-9]{0,})/,
                            n = navigator.userAgent.match(t);
                        n && n.length > 1 && parseFloat(n[1]) < 4.4 && (e = !0)
                    }
                    return !e && null !== ae && !ce.forceDisallow_
                }
                static previouslyFailed() {
                    return m.isInMemoryStorage || !0 === m.get("previous_websocket_failure")
                }
                markConnectionHealthy() {
                    m.remove("previous_websocket_failure")
                }
                appendFrame_(e) {
                    if (this.frames.push(e), this.frames.length === this.totalFrames) {
                        const e = this.frames.join("");
                        this.frames = null;
                        const t = s.jsonEval(e);
                        this.onMessage(t)
                    }
                }
                handleNewFrameCount_(e) {
                    this.totalFrames = e, this.frames = []
                }
                extractFrameCount_(e) {
                    if (s.assert(null === this.frames, "We already have a frame buffer"), e.length <= 6) {
                        const t = Number(e);
                        if (!isNaN(t)) return this.handleNewFrameCount_(t), null
                    }
                    return this.handleNewFrameCount_(1), e
                }
                handleIncomingFrame(e) {
                    if (null === this.mySock) return;
                    const t = e.data;
                    if (this.bytesReceived += t.length, this.stats_.incrementCounter("bytes_received", t.length), this.resetKeepAlive(), null !== this.frames) this.appendFrame_(t);
                    else {
                        const e = this.extractFrameCount_(t);
                        null !== e && this.appendFrame_(e)
                    }
                }
                send(e) {
                    this.resetKeepAlive();
                    const t = s.stringify(e);
                    this.bytesSent += t.length, this.stats_.incrementCounter("bytes_sent", t.length);
                    const n = L(t, 16384);
                    n.length > 1 && this.sendString_(String(n.length));
                    for (let e = 0; e < n.length; e++) this.sendString_(n[e])
                }
                shutdown_() {
                    this.isClosed_ = !0, this.keepaliveTimer && (clearInterval(this.keepaliveTimer), this.keepaliveTimer = null), this.mySock && (this.mySock.close(), this.mySock = null)
                }
                onClosed_() {
                    this.isClosed_ || (this.log_("WebSocket is closing itself"), this.shutdown_(), this.onDisconnect && (this.onDisconnect(this.everConnected_), this.onDisconnect = null))
                }
                close() {
                    this.isClosed_ || (this.log_("WebSocket is being closed"), this.shutdown_())
                }
                resetKeepAlive() {
                    clearInterval(this.keepaliveTimer), this.keepaliveTimer = setInterval((() => {
                        this.mySock && this.sendString_("0"), this.resetKeepAlive()
                    }), Math.floor(45e3))
                }
                sendString_(e) {
                    try {
                        this.mySock.send(e)
                    } catch (e) {
                        this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection."), setTimeout(this.onClosed_.bind(this), 0)
                    }
                }
            }
            ce.responsesRequiredToBeHealthy = 2, ce.healthyTimeout = 3e4;
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class ue {
                constructor(e) {
                    this.initTransports_(e)
                }
                static get ALL_TRANSPORTS() {
                    return [oe, ce]
                }
                static get IS_TRANSPORT_INITIALIZED() {
                    return this.globalTransportInitialized_
                }
                initTransports_(e) {
                    const t = ce && ce.isAvailable();
                    let n = t && !ce.previouslyFailed();
                    if (e.webSocketOnly && (t || R("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."), n = !0), n) this.transports_ = [ce];
                    else {
                        const e = this.transports_ = [];
                        for (const t of ue.ALL_TRANSPORTS) t && t.isAvailable() && e.push(t);
                        ue.globalTransportInitialized_ = !0
                    }
                }
                initialTransport() {
                    if (this.transports_.length > 0) return this.transports_[0];
                    throw new Error("No transports available")
                }
                upgradeTransport() {
                    return this.transports_.length > 1 ? this.transports_[1] : null
                }
            }
            ue.globalTransportInitialized_ = !1;
            class le {
                constructor(e, t, n, r, i, o, s, a, c, u) {
                    this.id = e, this.repoInfo_ = t, this.applicationId_ = n, this.appCheckToken_ = r, this.authToken_ = i, this.onMessage_ = o, this.onReady_ = s, this.onDisconnect_ = a, this.onKill_ = c, this.lastSessionId = u, this.connectionCount = 0, this.pendingDataMessages = [], this.state_ = 0, this.log_ = C("c:" + this.id + ":"), this.transportManager_ = new ue(t), this.log_("Connection created"), this.start_()
                }
                start_() {
                    const e = this.transportManager_.initialTransport();
                    this.conn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId), this.primaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0;
                    const t = this.connReceiver_(this.conn_),
                        n = this.disconnReceiver_(this.conn_);
                    this.tx_ = this.conn_, this.rx_ = this.conn_, this.secondaryConn_ = null, this.isHealthy_ = !1, setTimeout((() => {
                        this.conn_ && this.conn_.open(t, n)
                    }), Math.floor(0));
                    const r = e.healthyTimeout || 0;
                    r > 0 && (this.healthyTimeout_ = W((() => {
                        this.healthyTimeout_ = null, this.isHealthy_ || (this.conn_ && this.conn_.bytesReceived > 102400 ? (this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()) : this.conn_ && this.conn_.bytesSent > 10240 ? this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.") : (this.log_("Closing unhealthy connection after timeout."), this.close()))
                    }), Math.floor(r)))
                }
                nextTransportId_() {
                    return "c:" + this.id + ":" + this.connectionCount++
                }
                disconnReceiver_(e) {
                    return t => {
                        e === this.conn_ ? this.onConnectionLost_(t) : e === this.secondaryConn_ ? (this.log_("Secondary connection lost."), this.onSecondaryConnectionLost_()) : this.log_("closing an old connection")
                    }
                }
                connReceiver_(e) {
                    return t => {
                        2 !== this.state_ && (e === this.rx_ ? this.onPrimaryMessageReceived_(t) : e === this.secondaryConn_ ? this.onSecondaryMessageReceived_(t) : this.log_("message on old connection"))
                    }
                }
                sendRequest(e) {
                    const t = {
                        t: "d",
                        d: e
                    };
                    this.sendData_(t)
                }
                tryCleanupConnection() {
                    this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_ && (this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId), this.conn_ = this.secondaryConn_, this.secondaryConn_ = null)
                }
                onSecondaryControl_(e) {
                    if ("t" in e) {
                        const t = e.t;
                        "a" === t ? this.upgradeIfSecondaryHealthy_() : "r" === t ? (this.log_("Got a reset on secondary, closing it"), this.secondaryConn_.close(), this.tx_ !== this.secondaryConn_ && this.rx_ !== this.secondaryConn_ || this.close()) : "o" === t && (this.log_("got pong on secondary."), this.secondaryResponsesRequired_--, this.upgradeIfSecondaryHealthy_())
                    }
                }
                onSecondaryMessageReceived_(e) {
                    const t = M("t", e),
                        n = M("d", e);
                    if ("c" === t) this.onSecondaryControl_(n);
                    else {
                        if ("d" !== t) throw new Error("Unknown protocol layer: " + t);
                        this.pendingDataMessages.push(n)
                    }
                }
                upgradeIfSecondaryHealthy_() {
                    this.secondaryResponsesRequired_ <= 0 ? (this.log_("Secondary connection is healthy."), this.isHealthy_ = !0, this.secondaryConn_.markConnectionHealthy(), this.proceedWithUpgrade_()) : (this.log_("sending ping on secondary."), this.secondaryConn_.send({
                        t: "c",
                        d: {
                            t: "p",
                            d: {}
                        }
                    }))
                }
                proceedWithUpgrade_() {
                    this.secondaryConn_.start(), this.log_("sending client ack on secondary"), this.secondaryConn_.send({
                        t: "c",
                        d: {
                            t: "a",
                            d: {}
                        }
                    }), this.log_("Ending transmission on primary"), this.conn_.send({
                        t: "c",
                        d: {
                            t: "n",
                            d: {}
                        }
                    }), this.tx_ = this.secondaryConn_, this.tryCleanupConnection()
                }
                onPrimaryMessageReceived_(e) {
                    const t = M("t", e),
                        n = M("d", e);
                    "c" === t ? this.onControl_(n) : "d" === t && this.onDataMessage_(n)
                }
                onDataMessage_(e) {
                    this.onPrimaryResponse_(), this.onMessage_(e)
                }
                onPrimaryResponse_() {
                    this.isHealthy_ || (this.primaryResponsesRequired_--, this.primaryResponsesRequired_ <= 0 && (this.log_("Primary connection is healthy."), this.isHealthy_ = !0, this.conn_.markConnectionHealthy()))
                }
                onControl_(e) {
                    const t = M("t", e);
                    if ("d" in e) {
                        const n = e.d;
                        if ("h" === t) {
                            const e = Object.assign({}, n);
                            this.repoInfo_.isUsingEmulator && (e.h = this.repoInfo_.host), this.onHandshake_(e)
                        } else if ("n" === t) {
                            this.log_("recvd end transmission on primary"), this.rx_ = this.secondaryConn_;
                            for (let e = 0; e < this.pendingDataMessages.length; ++e) this.onDataMessage_(this.pendingDataMessages[e]);
                            this.pendingDataMessages = [], this.tryCleanupConnection()
                        } else "s" === t ? this.onConnectionShutdown_(n) : "r" === t ? this.onReset_(n) : "e" === t ? T("Server Error: " + n) : "o" === t ? (this.log_("got pong on primary."), this.onPrimaryResponse_(), this.sendPingOnPrimaryIfNecessary_()) : T("Unknown control packet command: " + t)
                    }
                }
                onHandshake_(e) {
                    const t = e.ts,
                        n = e.v,
                        r = e.h;
                    this.sessionId = e.s, this.repoInfo_.host = r, 0 === this.state_ && (this.conn_.start(), this.onConnectionEstablished_(this.conn_, t), z !== n && R("Protocol version mismatch detected"), this.tryStartUpgrade_())
                }
                tryStartUpgrade_() {
                    const e = this.transportManager_.upgradeTransport();
                    e && this.startUpgrade_(e)
                }
                startUpgrade_(e) {
                    this.secondaryConn_ = new e(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId), this.secondaryResponsesRequired_ = e.responsesRequiredToBeHealthy || 0;
                    const t = this.connReceiver_(this.secondaryConn_),
                        n = this.disconnReceiver_(this.secondaryConn_);
                    this.secondaryConn_.open(t, n), W((() => {
                        this.secondaryConn_ && (this.log_("Timed out trying to upgrade."), this.secondaryConn_.close())
                    }), Math.floor(6e4))
                }
                onReset_(e) {
                    this.log_("Reset packet received.  New host: " + e), this.repoInfo_.host = e, 1 === this.state_ ? this.close() : (this.closeConnections_(), this.start_())
                }
                onConnectionEstablished_(e, t) {
                    this.log_("Realtime connection established."), this.conn_ = e, this.state_ = 1, this.onReady_ && (this.onReady_(t, this.sessionId), this.onReady_ = null), 0 === this.primaryResponsesRequired_ ? (this.log_("Primary connection is healthy."), this.isHealthy_ = !0) : W((() => {
                        this.sendPingOnPrimaryIfNecessary_()
                    }), Math.floor(5e3))
                }
                sendPingOnPrimaryIfNecessary_() {
                    this.isHealthy_ || 1 !== this.state_ || (this.log_("sending ping on primary."), this.sendData_({
                        t: "c",
                        d: {
                            t: "p",
                            d: {}
                        }
                    }))
                }
                onSecondaryConnectionLost_() {
                    const e = this.secondaryConn_;
                    this.secondaryConn_ = null, this.tx_ !== e && this.rx_ !== e || this.close()
                }
                onConnectionLost_(e) {
                    this.conn_ = null, e || 0 !== this.state_ ? 1 === this.state_ && this.log_("Realtime connection lost.") : (this.log_("Realtime connection failed."), this.repoInfo_.isCacheableHost() && (m.remove("host:" + this.repoInfo_.host), this.repoInfo_.internalHost = this.repoInfo_.host)), this.close()
                }
                onConnectionShutdown_(e) {
                    this.log_("Connection shutdown command received. Shutting down..."), this.onKill_ && (this.onKill_(e), this.onKill_ = null), this.onDisconnect_ = null, this.close()
                }
                sendData_(e) {
                    if (1 !== this.state_) throw "Connection is not connected";
                    this.tx_.send(e)
                }
                close() {
                    2 !== this.state_ && (this.log_("Closing realtime connection."), this.state_ = 2, this.closeConnections_(), this.onDisconnect_ && (this.onDisconnect_(), this.onDisconnect_ = null))
                }
                closeConnections_() {
                    this.log_("Shutting down all connections"), this.conn_ && (this.conn_.close(), this.conn_ = null), this.secondaryConn_ && (this.secondaryConn_.close(), this.secondaryConn_ = null), this.healthyTimeout_ && (clearTimeout(this.healthyTimeout_), this.healthyTimeout_ = null)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class de {
                put(e, t, n, r) {}
                merge(e, t, n, r) {}
                refreshAuthToken(e) {}
                refreshAppCheckToken(e) {}
                onDisconnectPut(e, t, n) {}
                onDisconnectMerge(e, t, n) {}
                onDisconnectCancel(e, t) {}
                reportStats(e) {}
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class he {
                constructor(e) {
                    this.allowedEvents_ = e, this.listeners_ = {}, s.assert(Array.isArray(e) && e.length > 0, "Requires a non-empty array")
                }
                trigger(e, ...t) {
                    if (Array.isArray(this.listeners_[e])) {
                        const n = [...this.listeners_[e]];
                        for (let e = 0; e < n.length; e++) n[e].callback.apply(n[e].context, t)
                    }
                }
                on(e, t, n) {
                    this.validateEventType_(e), this.listeners_[e] = this.listeners_[e] || [], this.listeners_[e].push({
                        callback: t,
                        context: n
                    });
                    const r = this.getInitialEvent(e);
                    r && t.apply(n, r)
                }
                off(e, t, n) {
                    this.validateEventType_(e);
                    const r = this.listeners_[e] || [];
                    for (let e = 0; e < r.length; e++)
                        if (r[e].callback === t && (!n || n === r[e].context)) return void r.splice(e, 1)
                }
                validateEventType_(e) {
                    s.assert(this.allowedEvents_.find((t => t === e)), "Unknown event: " + e)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class pe extends he {
                constructor() {
                    super(["online"]), this.online_ = !0, "undefined" == typeof window || void 0 === window.addEventListener || s.isMobileCordova() || (window.addEventListener("online", (() => {
                        this.online_ || (this.online_ = !0, this.trigger("online", !0))
                    }), !1), window.addEventListener("offline", (() => {
                        this.online_ && (this.online_ = !1, this.trigger("online", !1))
                    }), !1))
                }
                static getInstance() {
                    return new pe
                }
                getInitialEvent(e) {
                    return s.assert("online" === e, "Unknown event type: " + e), [this.online_]
                }
                currentlyOnline() {
                    return this.online_
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const fe = 32,
                me = 768;
            class ge {
                constructor(e, t) {
                    if (void 0 === t) {
                        this.pieces_ = e.split("/");
                        let t = 0;
                        for (let e = 0; e < this.pieces_.length; e++) this.pieces_[e].length > 0 && (this.pieces_[t] = this.pieces_[e], t++);
                        this.pieces_.length = t, this.pieceNum_ = 0
                    } else this.pieces_ = e, this.pieceNum_ = t
                }
                toString() {
                    let e = "";
                    for (let t = this.pieceNum_; t < this.pieces_.length; t++) "" !== this.pieces_[t] && (e += "/" + this.pieces_[t]);
                    return e || "/"
                }
            }

            function _e() {
                return new ge("")
            }

            function ve(e) {
                return e.pieceNum_ >= e.pieces_.length ? null : e.pieces_[e.pieceNum_]
            }

            function ye(e) {
                return e.pieces_.length - e.pieceNum_
            }

            function be(e) {
                let t = e.pieceNum_;
                return t < e.pieces_.length && t++, new ge(e.pieces_, t)
            }

            function Ie(e) {
                return e.pieceNum_ < e.pieces_.length ? e.pieces_[e.pieces_.length - 1] : null
            }

            function Ee(e, t = 0) {
                return e.pieces_.slice(e.pieceNum_ + t)
            }

            function Se(e) {
                if (e.pieceNum_ >= e.pieces_.length) return null;
                const t = [];
                for (let n = e.pieceNum_; n < e.pieces_.length - 1; n++) t.push(e.pieces_[n]);
                return new ge(t, 0)
            }

            function we(e, t) {
                const n = [];
                for (let t = e.pieceNum_; t < e.pieces_.length; t++) n.push(e.pieces_[t]);
                if (t instanceof ge)
                    for (let e = t.pieceNum_; e < t.pieces_.length; e++) n.push(t.pieces_[e]);
                else {
                    const e = t.split("/");
                    for (let t = 0; t < e.length; t++) e[t].length > 0 && n.push(e[t])
                }
                return new ge(n, 0)
            }

            function Ce(e) {
                return e.pieceNum_ >= e.pieces_.length
            }

            function Te(e, t) {
                const n = ve(e),
                    r = ve(t);
                if (null === n) return t;
                if (n === r) return Te(be(e), be(t));
                throw new Error("INTERNAL ERROR: innerPath (" + t + ") is not within outerPath (" + e + ")")
            }

            function Ae(e, t) {
                const n = Ee(e, 0),
                    r = Ee(t, 0);
                for (let e = 0; e < n.length && e < r.length; e++) {
                    const t = N(n[e], r[e]);
                    if (0 !== t) return t
                }
                return n.length === r.length ? 0 : n.length < r.length ? -1 : 1
            }

            function Re(e, t) {
                if (ye(e) !== ye(t)) return !1;
                for (let n = e.pieceNum_, r = t.pieceNum_; n <= e.pieces_.length; n++, r++)
                    if (e.pieces_[n] !== t.pieces_[r]) return !1;
                return !0
            }

            function Pe(e, t) {
                let n = e.pieceNum_,
                    r = t.pieceNum_;
                if (ye(e) > ye(t)) return !1;
                for (; n < e.pieces_.length;) {
                    if (e.pieces_[n] !== t.pieces_[r]) return !1;
                    ++n, ++r
                }
                return !0
            }
            class Oe {
                constructor(e, t) {
                    this.errorPrefix_ = t, this.parts_ = Ee(e, 0), this.byteLength_ = Math.max(1, this.parts_.length);
                    for (let e = 0; e < this.parts_.length; e++) this.byteLength_ += s.stringLength(this.parts_[e]);
                    ke(this)
                }
            }

            function ke(e) {
                if (e.byteLength_ > me) throw new Error(e.errorPrefix_ + "has a key path longer than " + me + " bytes (" + e.byteLength_ + ").");
                if (e.parts_.length > fe) throw new Error(e.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + fe + ") or object contains a cycle " + Ne(e))
            }

            function Ne(e) {
                return 0 === e.parts_.length ? "" : "in property '" + e.parts_.join(".") + "'"
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class De extends he {
                constructor() {
                    let e, t;
                    super(["visible"]), "undefined" != typeof document && void 0 !== document.addEventListener && (void 0 !== document.hidden ? (t = "visibilitychange", e = "hidden") : void 0 !== document.mozHidden ? (t = "mozvisibilitychange", e = "mozHidden") : void 0 !== document.msHidden ? (t = "msvisibilitychange", e = "msHidden") : void 0 !== document.webkitHidden && (t = "webkitvisibilitychange", e = "webkitHidden")), this.visible_ = !0, t && document.addEventListener(t, (() => {
                        const t = !document[e];
                        t !== this.visible_ && (this.visible_ = t, this.trigger("visible", t))
                    }), !1)
                }
                static getInstance() {
                    return new De
                }
                getInitialEvent(e) {
                    return s.assert("visible" === e, "Unknown event type: " + e), [this.visible_]
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Me = 1e3;
            class xe extends de {
                constructor(e, t, n, r, i, o, a, c) {
                    if (super(), this.repoInfo_ = e, this.applicationId_ = t, this.onDataUpdate_ = n, this.onConnectStatus_ = r, this.onServerInfoUpdate_ = i, this.authTokenProvider_ = o, this.appCheckTokenProvider_ = a, this.authOverride_ = c, this.id = xe.nextPersistentConnectionId_++, this.log_ = C("p:" + this.id + ":"), this.interruptReasons_ = {}, this.listens = new Map, this.outstandingPuts_ = [], this.outstandingGets_ = [], this.outstandingPutCount_ = 0, this.outstandingGetCount_ = 0, this.onDisconnectRequestQueue_ = [], this.connected_ = !1, this.reconnectDelay_ = Me, this.maxReconnectDelay_ = 3e5, this.securityDebugCallback_ = null, this.lastSessionId = null, this.establishConnectionTimer_ = null, this.visible_ = !1, this.requestCBHash_ = {}, this.requestNumber_ = 0, this.realtime_ = null, this.authToken_ = null, this.appCheckToken_ = null, this.forceTokenRefresh_ = !1, this.invalidAuthTokenCount_ = 0, this.invalidAppCheckTokenCount_ = 0, this.firstConnection_ = !0, this.lastConnectionAttemptTime_ = null, this.lastConnectionEstablishedTime_ = null, c && !s.isNodeSdk()) throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
                    De.getInstance().on("visible", this.onVisible_, this), -1 === e.host.indexOf("fblocal") && pe.getInstance().on("online", this.onOnline_, this)
                }
                sendRequest(e, t, n) {
                    const r = ++this.requestNumber_,
                        i = {
                            r: r,
                            a: e,
                            b: t
                        };
                    this.log_(s.stringify(i)), s.assert(this.connected_, "sendRequest call when we're not connected not allowed."), this.realtime_.sendRequest(i), n && (this.requestCBHash_[r] = n)
                }
                get(e) {
                    this.initConnection_();
                    const t = new s.Deferred,
                        n = {
                            action: "g",
                            request: {
                                p: e._path.toString(),
                                q: e._queryObject
                            },
                            onComplete: e => {
                                const n = e.d;
                                "ok" === e.s ? t.resolve(n) : t.reject(n)
                            }
                        };
                    this.outstandingGets_.push(n), this.outstandingGetCount_++;
                    const r = this.outstandingGets_.length - 1;
                    return this.connected_ && this.sendGet_(r), t.promise
                }
                listen(e, t, n, r) {
                    this.initConnection_();
                    const i = e._queryIdentifier,
                        o = e._path.toString();
                    this.log_("Listen called for " + o + " " + i), this.listens.has(o) || this.listens.set(o, new Map), s.assert(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "listen() called for non-default but complete query"), s.assert(!this.listens.get(o).has(i), "listen() called twice for same path/queryId.");
                    const a = {
                        onComplete: r,
                        hashFn: t,
                        query: e,
                        tag: n
                    };
                    this.listens.get(o).set(i, a), this.connected_ && this.sendListen_(a)
                }
                sendGet_(e) {
                    const t = this.outstandingGets_[e];
                    this.sendRequest("g", t.request, (n => {
                        delete this.outstandingGets_[e], this.outstandingGetCount_--, 0 === this.outstandingGetCount_ && (this.outstandingGets_ = []), t.onComplete && t.onComplete(n)
                    }))
                }
                sendListen_(e) {
                    const t = e.query,
                        n = t._path.toString(),
                        r = t._queryIdentifier;
                    this.log_("Listen on " + n + " for " + r);
                    const i = {
                        p: n
                    };
                    e.tag && (i.q = t._queryObject, i.t = e.tag), i.h = e.hashFn(), this.sendRequest("q", i, (i => {
                        const o = i.d,
                            s = i.s;
                        xe.warnOnListenWarnings_(o, t);
                        (this.listens.get(n) && this.listens.get(n).get(r)) === e && (this.log_("listen response", i), "ok" !== s && this.removeListen_(n, r), e.onComplete && e.onComplete(s, o))
                    }))
                }
                static warnOnListenWarnings_(e, t) {
                    if (e && "object" == typeof e && s.contains(e, "w")) {
                        const n = s.safeGet(e, "w");
                        if (Array.isArray(n) && ~n.indexOf("no_index")) {
                            const e = '".indexOn": "' + t._queryParams.getIndex().toString() + '"',
                                n = t._path.toString();
                            R(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${e} at ${n} to your security rules for better performance.`)
                        }
                    }
                }
                refreshAuthToken(e) {
                    this.authToken_ = e, this.log_("Auth token refreshed"), this.authToken_ ? this.tryAuth() : this.connected_ && this.sendRequest("unauth", {}, (() => {})), this.reduceReconnectDelayIfAdminCredential_(e)
                }
                reduceReconnectDelayIfAdminCredential_(e) {
                    (e && 40 === e.length || s.isAdmin(e)) && (this.log_("Admin auth credential detected.  Reducing max reconnect time."), this.maxReconnectDelay_ = 3e4)
                }
                refreshAppCheckToken(e) {
                    this.appCheckToken_ = e, this.log_("App check token refreshed"), this.appCheckToken_ ? this.tryAppCheck() : this.connected_ && this.sendRequest("unappeck", {}, (() => {}))
                }
                tryAuth() {
                    if (this.connected_ && this.authToken_) {
                        const e = this.authToken_,
                            t = s.isValidFormat(e) ? "auth" : "gauth",
                            n = {
                                cred: e
                            };
                        null === this.authOverride_ ? n.noauth = !0 : "object" == typeof this.authOverride_ && (n.authvar = this.authOverride_), this.sendRequest(t, n, (t => {
                            const n = t.s,
                                r = t.d || "error";
                            this.authToken_ === e && ("ok" === n ? this.invalidAuthTokenCount_ = 0 : this.onAuthRevoked_(n, r))
                        }))
                    }
                }
                tryAppCheck() {
                    this.connected_ && this.appCheckToken_ && this.sendRequest("appcheck", {
                        token: this.appCheckToken_
                    }, (e => {
                        const t = e.s,
                            n = e.d || "error";
                        "ok" === t ? this.invalidAppCheckTokenCount_ = 0 : this.onAppCheckRevoked_(t, n)
                    }))
                }
                unlisten(e, t) {
                    const n = e._path.toString(),
                        r = e._queryIdentifier;
                    this.log_("Unlisten called for " + n + " " + r), s.assert(e._queryParams.isDefault() || !e._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
                    this.removeListen_(n, r) && this.connected_ && this.sendUnlisten_(n, r, e._queryObject, t)
                }
                sendUnlisten_(e, t, n, r) {
                    this.log_("Unlisten on " + e + " for " + t);
                    const i = {
                        p: e
                    };
                    r && (i.q = n, i.t = r), this.sendRequest("n", i)
                }
                onDisconnectPut(e, t, n) {
                    this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("o", e, t, n) : this.onDisconnectRequestQueue_.push({
                        pathString: e,
                        action: "o",
                        data: t,
                        onComplete: n
                    })
                }
                onDisconnectMerge(e, t, n) {
                    this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("om", e, t, n) : this.onDisconnectRequestQueue_.push({
                        pathString: e,
                        action: "om",
                        data: t,
                        onComplete: n
                    })
                }
                onDisconnectCancel(e, t) {
                    this.initConnection_(), this.connected_ ? this.sendOnDisconnect_("oc", e, null, t) : this.onDisconnectRequestQueue_.push({
                        pathString: e,
                        action: "oc",
                        data: null,
                        onComplete: t
                    })
                }
                sendOnDisconnect_(e, t, n, r) {
                    const i = {
                        p: t,
                        d: n
                    };
                    this.log_("onDisconnect " + e, i), this.sendRequest(e, i, (e => {
                        r && setTimeout((() => {
                            r(e.s, e.d)
                        }), Math.floor(0))
                    }))
                }
                put(e, t, n, r) {
                    this.putInternal("p", e, t, n, r)
                }
                merge(e, t, n, r) {
                    this.putInternal("m", e, t, n, r)
                }
                putInternal(e, t, n, r, i) {
                    this.initConnection_();
                    const o = {
                        p: t,
                        d: n
                    };
                    void 0 !== i && (o.h = i), this.outstandingPuts_.push({
                        action: e,
                        request: o,
                        onComplete: r
                    }), this.outstandingPutCount_++;
                    const s = this.outstandingPuts_.length - 1;
                    this.connected_ ? this.sendPut_(s) : this.log_("Buffering put: " + t)
                }
                sendPut_(e) {
                    const t = this.outstandingPuts_[e].action,
                        n = this.outstandingPuts_[e].request,
                        r = this.outstandingPuts_[e].onComplete;
                    this.outstandingPuts_[e].queued = this.connected_, this.sendRequest(t, n, (n => {
                        this.log_(t + " response", n), delete this.outstandingPuts_[e], this.outstandingPutCount_--, 0 === this.outstandingPutCount_ && (this.outstandingPuts_ = []), r && r(n.s, n.d)
                    }))
                }
                reportStats(e) {
                    if (this.connected_) {
                        const t = {
                            c: e
                        };
                        this.log_("reportStats", t), this.sendRequest("s", t, (e => {
                            if ("ok" !== e.s) {
                                const t = e.d;
                                this.log_("reportStats", "Error sending stats: " + t)
                            }
                        }))
                    }
                }
                onDataMessage_(e) {
                    if ("r" in e) {
                        this.log_("from server: " + s.stringify(e));
                        const t = e.r,
                            n = this.requestCBHash_[t];
                        n && (delete this.requestCBHash_[t], n(e.b))
                    } else {
                        if ("error" in e) throw "A server-side error has occurred: " + e.error;
                        "a" in e && this.onDataPush_(e.a, e.b)
                    }
                }
                onDataPush_(e, t) {
                    this.log_("handleServerMessage", e, t), "d" === e ? this.onDataUpdate_(t.p, t.d, !1, t.t) : "m" === e ? this.onDataUpdate_(t.p, t.d, !0, t.t) : "c" === e ? this.onListenRevoked_(t.p, t.q) : "ac" === e ? this.onAuthRevoked_(t.s, t.d) : "apc" === e ? this.onAppCheckRevoked_(t.s, t.d) : "sd" === e ? this.onSecurityDebugPacket_(t) : T("Unrecognized action received from server: " + s.stringify(e) + "\nAre you using the latest client?")
                }
                onReady_(e, t) {
                    this.log_("connection ready"), this.connected_ = !0, this.lastConnectionEstablishedTime_ = (new Date).getTime(), this.handleTimestamp_(e), this.lastSessionId = t, this.firstConnection_ && this.sendConnectStats_(), this.restoreState_(), this.firstConnection_ = !1, this.onConnectStatus_(!0)
                }
                scheduleConnect_(e) {
                    s.assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?"), this.establishConnectionTimer_ && clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = setTimeout((() => {
                        this.establishConnectionTimer_ = null, this.establishConnection_()
                    }), Math.floor(e))
                }
                initConnection_() {
                    !this.realtime_ && this.firstConnection_ && this.scheduleConnect_(0)
                }
                onVisible_(e) {
                    e && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_ && (this.log_("Window became visible.  Reducing delay."), this.reconnectDelay_ = Me, this.realtime_ || this.scheduleConnect_(0)), this.visible_ = e
                }
                onOnline_(e) {
                    e ? (this.log_("Browser went online."), this.reconnectDelay_ = Me, this.realtime_ || this.scheduleConnect_(0)) : (this.log_("Browser went offline.  Killing connection."), this.realtime_ && this.realtime_.close())
                }
                onRealtimeDisconnect_() {
                    if (this.log_("data client disconnected"), this.connected_ = !1, this.realtime_ = null, this.cancelSentTransactions_(), this.requestCBHash_ = {}, this.shouldReconnect_()) {
                        if (this.visible_) {
                            if (this.lastConnectionEstablishedTime_) {
                                (new Date).getTime() - this.lastConnectionEstablishedTime_ > 3e4 && (this.reconnectDelay_ = Me), this.lastConnectionEstablishedTime_ = null
                            }
                        } else this.log_("Window isn't visible.  Delaying reconnect."), this.reconnectDelay_ = this.maxReconnectDelay_, this.lastConnectionAttemptTime_ = (new Date).getTime();
                        const e = (new Date).getTime() - this.lastConnectionAttemptTime_;
                        let t = Math.max(0, this.reconnectDelay_ - e);
                        t = Math.random() * t, this.log_("Trying to reconnect in " + t + "ms"), this.scheduleConnect_(t), this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, 1.3 * this.reconnectDelay_)
                    }
                    this.onConnectStatus_(!1)
                }
                async establishConnection_() {
                    if (this.shouldReconnect_()) {
                        this.log_("Making a connection attempt"), this.lastConnectionAttemptTime_ = (new Date).getTime(), this.lastConnectionEstablishedTime_ = null;
                        const e = this.onDataMessage_.bind(this),
                            t = this.onReady_.bind(this),
                            n = this.onRealtimeDisconnect_.bind(this),
                            r = this.id + ":" + xe.nextConnectionId_++,
                            i = this.lastSessionId;
                        let o = !1,
                            a = null;
                        const c = function() {
                                a ? a.close() : (o = !0, n())
                            },
                            u = function(e) {
                                s.assert(a, "sendRequest call when we're not connected not allowed."), a.sendRequest(e)
                            };
                        this.realtime_ = {
                            close: c,
                            sendRequest: u
                        };
                        const l = this.forceTokenRefresh_;
                        this.forceTokenRefresh_ = !1;
                        try {
                            const [s, c] = await Promise.all([this.authTokenProvider_.getToken(l), this.appCheckTokenProvider_.getToken(l)]);
                            o ? w("getToken() completed but was canceled") : (w("getToken() completed. Creating connection."), this.authToken_ = s && s.accessToken, this.appCheckToken_ = c && c.token, a = new le(r, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, e, t, n, (e => {
                                R(e + " (" + this.repoInfo_.toString() + ")"), this.interrupt("server_kill")
                            }), i))
                        } catch (e) {
                            this.log_("Failed to get token: " + e), o || (this.repoInfo_.nodeAdmin && R(e), c())
                        }
                    }
                }
                interrupt(e) {
                    w("Interrupting connection for reason: " + e), this.interruptReasons_[e] = !0, this.realtime_ ? this.realtime_.close() : (this.establishConnectionTimer_ && (clearTimeout(this.establishConnectionTimer_), this.establishConnectionTimer_ = null), this.connected_ && this.onRealtimeDisconnect_())
                }
                resume(e) {
                    w("Resuming connection for reason: " + e), delete this.interruptReasons_[e], s.isEmpty(this.interruptReasons_) && (this.reconnectDelay_ = Me, this.realtime_ || this.scheduleConnect_(0))
                }
                handleTimestamp_(e) {
                    const t = e - (new Date).getTime();
                    this.onServerInfoUpdate_({
                        serverTimeOffset: t
                    })
                }
                cancelSentTransactions_() {
                    for (let e = 0; e < this.outstandingPuts_.length; e++) {
                        const t = this.outstandingPuts_[e];
                        t && "h" in t.request && t.queued && (t.onComplete && t.onComplete("disconnect"), delete this.outstandingPuts_[e], this.outstandingPutCount_--)
                    }
                    0 === this.outstandingPutCount_ && (this.outstandingPuts_ = [])
                }
                onListenRevoked_(e, t) {
                    let n;
                    n = t ? t.map((e => x(e))).join("$") : "default";
                    const r = this.removeListen_(e, n);
                    r && r.onComplete && r.onComplete("permission_denied")
                }
                removeListen_(e, t) {
                    const n = new ge(e).toString();
                    let r;
                    if (this.listens.has(n)) {
                        const e = this.listens.get(n);
                        r = e.get(t), e.delete(t), 0 === e.size && this.listens.delete(n)
                    } else r = void 0;
                    return r
                }
                onAuthRevoked_(e, t) {
                    w("Auth token revoked: " + e + "/" + t), this.authToken_ = null, this.forceTokenRefresh_ = !0, this.realtime_.close(), "invalid_token" !== e && "permission_denied" !== e || (this.invalidAuthTokenCount_++, this.invalidAuthTokenCount_ >= 3 && (this.reconnectDelay_ = 3e4, this.authTokenProvider_.notifyForInvalidToken()))
                }
                onAppCheckRevoked_(e, t) {
                    w("App check token revoked: " + e + "/" + t), this.appCheckToken_ = null, this.forceTokenRefresh_ = !0, "invalid_token" !== e && "permission_denied" !== e || (this.invalidAppCheckTokenCount_++, this.invalidAppCheckTokenCount_ >= 3 && this.appCheckTokenProvider_.notifyForInvalidToken())
                }
                onSecurityDebugPacket_(e) {
                    this.securityDebugCallback_ ? this.securityDebugCallback_(e) : "msg" in e && console.log("FIREBASE: " + e.msg.replace("\n", "\nFIREBASE: "))
                }
                restoreState_() {
                    this.tryAuth(), this.tryAppCheck();
                    for (const e of this.listens.values())
                        for (const t of e.values()) this.sendListen_(t);
                    for (let e = 0; e < this.outstandingPuts_.length; e++) this.outstandingPuts_[e] && this.sendPut_(e);
                    for (; this.onDisconnectRequestQueue_.length;) {
                        const e = this.onDisconnectRequestQueue_.shift();
                        this.sendOnDisconnect_(e.action, e.pathString, e.data, e.onComplete)
                    }
                    for (let e = 0; e < this.outstandingGets_.length; e++) this.outstandingGets_[e] && this.sendGet_(e)
                }
                sendConnectStats_() {
                    const e = {};
                    let t = "js";
                    s.isNodeSdk() && (t = this.repoInfo_.nodeAdmin ? "admin_node" : "node"), e["sdk." + t + "." + l.replace(/\./g, "-")] = 1, s.isMobileCordova() ? e["framework.cordova"] = 1 : s.isReactNative() && (e["framework.reactnative"] = 1), this.reportStats(e)
                }
                shouldReconnect_() {
                    const e = pe.getInstance().currentlyOnline();
                    return s.isEmpty(this.interruptReasons_) && e
                }
            }
            xe.nextPersistentConnectionId_ = 0, xe.nextConnectionId_ = 0;
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Le {
                constructor(e, t) {
                    this.name = e, this.node = t
                }
                static Wrap(e, t) {
                    return new Le(e, t)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ue {
                getCompare() {
                    return this.compare.bind(this)
                }
                indexedValueChanged(e, t) {
                    const n = new Le(O, e),
                        r = new Le(O, t);
                    return 0 !== this.compare(n, r)
                }
                minPost() {
                    return Le.MIN
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let Fe;
            class je extends Ue {
                static get __EMPTY_NODE() {
                    return Fe
                }
                static set __EMPTY_NODE(e) {
                    Fe = e
                }
                compare(e, t) {
                    return N(e.name, t.name)
                }
                isDefinedOn(e) {
                    throw s.assertionError("KeyIndex.isDefinedOn not expected to be called.")
                }
                indexedValueChanged(e, t) {
                    return !1
                }
                minPost() {
                    return Le.MIN
                }
                maxPost() {
                    return new Le(k, Fe)
                }
                makePost(e, t) {
                    return s.assert("string" == typeof e, "KeyIndex indexValue must always be a string."), new Le(e, Fe)
                }
                toString() {
                    return ".key"
                }
            }
            const qe = new je;
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class He {
                constructor(e, t, n, r, i = null) {
                    this.isReverse_ = r, this.resultGenerator_ = i, this.nodeStack_ = [];
                    let o = 1;
                    for (; !e.isEmpty();)
                        if (o = t ? n(e.key, t) : 1, r && (o *= -1), o < 0) e = this.isReverse_ ? e.left : e.right;
                        else {
                            if (0 === o) {
                                this.nodeStack_.push(e);
                                break
                            }
                            this.nodeStack_.push(e), e = this.isReverse_ ? e.right : e.left
                        }
                }
                getNext() {
                    if (0 === this.nodeStack_.length) return null;
                    let e, t = this.nodeStack_.pop();
                    if (e = this.resultGenerator_ ? this.resultGenerator_(t.key, t.value) : {
                            key: t.key,
                            value: t.value
                        }, this.isReverse_)
                        for (t = t.left; !t.isEmpty();) this.nodeStack_.push(t), t = t.right;
                    else
                        for (t = t.right; !t.isEmpty();) this.nodeStack_.push(t), t = t.left;
                    return e
                }
                hasNext() {
                    return this.nodeStack_.length > 0
                }
                peek() {
                    if (0 === this.nodeStack_.length) return null;
                    const e = this.nodeStack_[this.nodeStack_.length - 1];
                    return this.resultGenerator_ ? this.resultGenerator_(e.key, e.value) : {
                        key: e.key,
                        value: e.value
                    }
                }
            }
            class We {
                constructor(e, t, n, r, i) {
                    this.key = e, this.value = t, this.color = null != n ? n : We.RED, this.left = null != r ? r : Be.EMPTY_NODE, this.right = null != i ? i : Be.EMPTY_NODE
                }
                copy(e, t, n, r, i) {
                    return new We(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right)
                }
                count() {
                    return this.left.count() + 1 + this.right.count()
                }
                isEmpty() {
                    return !1
                }
                inorderTraversal(e) {
                    return this.left.inorderTraversal(e) || !!e(this.key, this.value) || this.right.inorderTraversal(e)
                }
                reverseTraversal(e) {
                    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e)
                }
                min_() {
                    return this.left.isEmpty() ? this : this.left.min_()
                }
                minKey() {
                    return this.min_().key
                }
                maxKey() {
                    return this.right.isEmpty() ? this.key : this.right.maxKey()
                }
                insert(e, t, n) {
                    let r = this;
                    const i = n(e, r.key);
                    return r = i < 0 ? r.copy(null, null, null, r.left.insert(e, t, n), null) : 0 === i ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, n)), r.fixUp_()
                }
                removeMin_() {
                    if (this.left.isEmpty()) return Be.EMPTY_NODE;
                    let e = this;
                    return e.left.isRed_() || e.left.left.isRed_() || (e = e.moveRedLeft_()), e = e.copy(null, null, null, e.left.removeMin_(), null), e.fixUp_()
                }
                remove(e, t) {
                    let n, r;
                    if (n = this, t(e, n.key) < 0) n.left.isEmpty() || n.left.isRed_() || n.left.left.isRed_() || (n = n.moveRedLeft_()), n = n.copy(null, null, null, n.left.remove(e, t), null);
                    else {
                        if (n.left.isRed_() && (n = n.rotateRight_()), n.right.isEmpty() || n.right.isRed_() || n.right.left.isRed_() || (n = n.moveRedRight_()), 0 === t(e, n.key)) {
                            if (n.right.isEmpty()) return Be.EMPTY_NODE;
                            r = n.right.min_(), n = n.copy(r.key, r.value, null, null, n.right.removeMin_())
                        }
                        n = n.copy(null, null, null, null, n.right.remove(e, t))
                    }
                    return n.fixUp_()
                }
                isRed_() {
                    return this.color
                }
                fixUp_() {
                    let e = this;
                    return e.right.isRed_() && !e.left.isRed_() && (e = e.rotateLeft_()), e.left.isRed_() && e.left.left.isRed_() && (e = e.rotateRight_()), e.left.isRed_() && e.right.isRed_() && (e = e.colorFlip_()), e
                }
                moveRedLeft_() {
                    let e = this.colorFlip_();
                    return e.right.left.isRed_() && (e = e.copy(null, null, null, null, e.right.rotateRight_()), e = e.rotateLeft_(), e = e.colorFlip_()), e
                }
                moveRedRight_() {
                    let e = this.colorFlip_();
                    return e.left.left.isRed_() && (e = e.rotateRight_(), e = e.colorFlip_()), e
                }
                rotateLeft_() {
                    const e = this.copy(null, null, We.RED, null, this.right.left);
                    return this.right.copy(null, null, this.color, e, null)
                }
                rotateRight_() {
                    const e = this.copy(null, null, We.RED, this.left.right, null);
                    return this.left.copy(null, null, this.color, null, e)
                }
                colorFlip_() {
                    const e = this.left.copy(null, null, !this.left.color, null, null),
                        t = this.right.copy(null, null, !this.right.color, null, null);
                    return this.copy(null, null, !this.color, e, t)
                }
                checkMaxDepth_() {
                    const e = this.check_();
                    return Math.pow(2, e) <= this.count() + 1
                }
                check_() {
                    if (this.isRed_() && this.left.isRed_()) throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
                    if (this.right.isRed_()) throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
                    const e = this.left.check_();
                    if (e !== this.right.check_()) throw new Error("Black depths differ");
                    return e + (this.isRed_() ? 0 : 1)
                }
            }
            We.RED = !0, We.BLACK = !1;
            class Be {
                constructor(e, t = Be.EMPTY_NODE) {
                    this.comparator_ = e, this.root_ = t
                }
                insert(e, t) {
                    return new Be(this.comparator_, this.root_.insert(e, t, this.comparator_).copy(null, null, We.BLACK, null, null))
                }
                remove(e) {
                    return new Be(this.comparator_, this.root_.remove(e, this.comparator_).copy(null, null, We.BLACK, null, null))
                }
                get(e) {
                    let t, n = this.root_;
                    for (; !n.isEmpty();) {
                        if (t = this.comparator_(e, n.key), 0 === t) return n.value;
                        t < 0 ? n = n.left : t > 0 && (n = n.right)
                    }
                    return null
                }
                getPredecessorKey(e) {
                    let t, n = this.root_,
                        r = null;
                    for (; !n.isEmpty();) {
                        if (t = this.comparator_(e, n.key), 0 === t) {
                            if (n.left.isEmpty()) return r ? r.key : null;
                            for (n = n.left; !n.right.isEmpty();) n = n.right;
                            return n.key
                        }
                        t < 0 ? n = n.left : t > 0 && (r = n, n = n.right)
                    }
                    throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?")
                }
                isEmpty() {
                    return this.root_.isEmpty()
                }
                count() {
                    return this.root_.count()
                }
                minKey() {
                    return this.root_.minKey()
                }
                maxKey() {
                    return this.root_.maxKey()
                }
                inorderTraversal(e) {
                    return this.root_.inorderTraversal(e)
                }
                reverseTraversal(e) {
                    return this.root_.reverseTraversal(e)
                }
                getIterator(e) {
                    return new He(this.root_, null, this.comparator_, !1, e)
                }
                getIteratorFrom(e, t) {
                    return new He(this.root_, e, this.comparator_, !1, t)
                }
                getReverseIteratorFrom(e, t) {
                    return new He(this.root_, e, this.comparator_, !0, t)
                }
                getReverseIterator(e) {
                    return new He(this.root_, null, this.comparator_, !0, e)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function Ve(e, t) {
                return N(e.name, t.name)
            }

            function Ge(e, t) {
                return N(e, t)
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let ze;
            Be.EMPTY_NODE = new class {
                copy(e, t, n, r, i) {
                    return this
                }
                insert(e, t, n) {
                    return new We(e, t, null)
                }
                remove(e, t) {
                    return this
                }
                count() {
                    return 0
                }
                isEmpty() {
                    return !0
                }
                inorderTraversal(e) {
                    return !1
                }
                reverseTraversal(e) {
                    return !1
                }
                minKey() {
                    return null
                }
                maxKey() {
                    return null
                }
                check_() {
                    return 0
                }
                isRed_() {
                    return !1
                }
            };
            const $e = function(e) {
                    return "number" == typeof e ? "number:" + F(e) : "string:" + e
                },
                Ke = function(e) {
                    if (e.isLeafNode()) {
                        const t = e.val();
                        s.assert("string" == typeof t || "number" == typeof t || "object" == typeof t && s.contains(t, ".sv"), "Priority must be a string or number.")
                    } else s.assert(e === ze || e.isEmpty(), "priority of unexpected type.");
                    s.assert(e === ze || e.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.")
                };
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let Ye, Je, Qe;
            class Xe {
                constructor(e, t = Xe.__childrenNodeConstructor.EMPTY_NODE) {
                    this.value_ = e, this.priorityNode_ = t, this.lazyHash_ = null, s.assert(void 0 !== this.value_ && null !== this.value_, "LeafNode shouldn't be created with null/undefined value."), Ke(this.priorityNode_)
                }
                static set __childrenNodeConstructor(e) {
                    Ye = e
                }
                static get __childrenNodeConstructor() {
                    return Ye
                }
                isLeafNode() {
                    return !0
                }
                getPriority() {
                    return this.priorityNode_
                }
                updatePriority(e) {
                    return new Xe(this.value_, e)
                }
                getImmediateChild(e) {
                    return ".priority" === e ? this.priorityNode_ : Xe.__childrenNodeConstructor.EMPTY_NODE
                }
                getChild(e) {
                    return Ce(e) ? this : ".priority" === ve(e) ? this.priorityNode_ : Xe.__childrenNodeConstructor.EMPTY_NODE
                }
                hasChild() {
                    return !1
                }
                getPredecessorChildName(e, t) {
                    return null
                }
                updateImmediateChild(e, t) {
                    return ".priority" === e ? this.updatePriority(t) : t.isEmpty() && ".priority" !== e ? this : Xe.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(e, t).updatePriority(this.priorityNode_)
                }
                updateChild(e, t) {
                    const n = ve(e);
                    return null === n ? t : t.isEmpty() && ".priority" !== n ? this : (s.assert(".priority" !== n || 1 === ye(e), ".priority must be the last token in a path"), this.updateImmediateChild(n, Xe.__childrenNodeConstructor.EMPTY_NODE.updateChild(be(e), t)))
                }
                isEmpty() {
                    return !1
                }
                numChildren() {
                    return 0
                }
                forEachChild(e, t) {
                    return !1
                }
                val(e) {
                    return e && !this.getPriority().isEmpty() ? {
                        ".value": this.getValue(),
                        ".priority": this.getPriority().val()
                    } : this.getValue()
                }
                hash() {
                    if (null === this.lazyHash_) {
                        let e = "";
                        this.priorityNode_.isEmpty() || (e += "priority:" + $e(this.priorityNode_.val()) + ":");
                        const t = typeof this.value_;
                        e += t + ":", e += "number" === t ? F(this.value_) : this.value_, this.lazyHash_ = y(e)
                    }
                    return this.lazyHash_
                }
                getValue() {
                    return this.value_
                }
                compareTo(e) {
                    return e === Xe.__childrenNodeConstructor.EMPTY_NODE ? 1 : e instanceof Xe.__childrenNodeConstructor ? -1 : (s.assert(e.isLeafNode(), "Unknown node type"), this.compareToLeafNode_(e))
                }
                compareToLeafNode_(e) {
                    const t = typeof e.value_,
                        n = typeof this.value_,
                        r = Xe.VALUE_TYPE_ORDER.indexOf(t),
                        i = Xe.VALUE_TYPE_ORDER.indexOf(n);
                    return s.assert(r >= 0, "Unknown leaf type: " + t), s.assert(i >= 0, "Unknown leaf type: " + n), r === i ? "object" === n ? 0 : this.value_ < e.value_ ? -1 : this.value_ === e.value_ ? 0 : 1 : i - r
                }
                withIndex() {
                    return this
                }
                isIndexed() {
                    return !0
                }
                equals(e) {
                    if (e === this) return !0;
                    if (e.isLeafNode()) {
                        const t = e;
                        return this.value_ === t.value_ && this.priorityNode_.equals(t.priorityNode_)
                    }
                    return !1
                }
            }
            Xe.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
            const Ze = new class extends Ue {
                    compare(e, t) {
                        const n = e.node.getPriority(),
                            r = t.node.getPriority(),
                            i = n.compareTo(r);
                        return 0 === i ? N(e.name, t.name) : i
                    }
                    isDefinedOn(e) {
                        return !e.getPriority().isEmpty()
                    }
                    indexedValueChanged(e, t) {
                        return !e.getPriority().equals(t.getPriority())
                    }
                    minPost() {
                        return Le.MIN
                    }
                    maxPost() {
                        return new Le(k, new Xe("[PRIORITY-POST]", Qe))
                    }
                    makePost(e, t) {
                        const n = Je(e);
                        return new Le(t, new Xe("[PRIORITY-POST]", n))
                    }
                    toString() {
                        return ".priority"
                    }
                },
                et = Math.log(2);
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class tt {
                constructor(e) {
                    var t;
                    this.count = (t = e + 1, parseInt(Math.log(t) / et, 10)), this.current_ = this.count - 1;
                    const n = (r = this.count, parseInt(Array(r + 1).join("1"), 2));
                    var r;
                    this.bits_ = e + 1 & n
                }
                nextBitIsOne() {
                    const e = !(this.bits_ & 1 << this.current_);
                    return this.current_--, e
                }
            }
            const nt = function(e, t, n, r) {
                e.sort(t);
                const i = function(t, r) {
                        const o = r - t;
                        let s, a;
                        if (0 === o) return null;
                        if (1 === o) return s = e[t], a = n ? n(s) : s, new We(a, s.node, We.BLACK, null, null); {
                            const c = parseInt(o / 2, 10) + t,
                                u = i(t, c),
                                l = i(c + 1, r);
                            return s = e[c], a = n ? n(s) : s, new We(a, s.node, We.BLACK, u, l)
                        }
                    },
                    o = function(t) {
                        let r = null,
                            o = null,
                            s = e.length;
                        const a = function(t, r) {
                                const o = s - t,
                                    a = s;
                                s -= t;
                                const u = i(o + 1, a),
                                    l = e[o],
                                    d = n ? n(l) : l;
                                c(new We(d, l.node, r, null, u))
                            },
                            c = function(e) {
                                r ? (r.left = e, r = e) : (o = e, r = e)
                            };
                        for (let e = 0; e < t.count; ++e) {
                            const n = t.nextBitIsOne(),
                                r = Math.pow(2, t.count - (e + 1));
                            n ? a(r, We.BLACK) : (a(r, We.BLACK), a(r, We.RED))
                        }
                        return o
                    }(new tt(e.length));
                return new Be(r || t, o)
            };
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let rt;
            const it = {};
            class ot {
                constructor(e, t) {
                    this.indexes_ = e, this.indexSet_ = t
                }
                static get Default() {
                    return s.assert(it && Ze, "ChildrenNode.ts has not been loaded"), rt = rt || new ot({
                        ".priority": it
                    }, {
                        ".priority": Ze
                    }), rt
                }
                get(e) {
                    const t = s.safeGet(this.indexes_, e);
                    if (!t) throw new Error("No index defined for " + e);
                    return t instanceof Be ? t : null
                }
                hasIndex(e) {
                    return s.contains(this.indexSet_, e.toString())
                }
                addIndex(e, t) {
                    s.assert(e !== qe, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
                    const n = [];
                    let r = !1;
                    const i = t.getIterator(Le.Wrap);
                    let o, a = i.getNext();
                    for (; a;) r = r || e.isDefinedOn(a.node), n.push(a), a = i.getNext();
                    o = r ? nt(n, e.getCompare()) : it;
                    const c = e.toString(),
                        u = Object.assign({}, this.indexSet_);
                    u[c] = e;
                    const l = Object.assign({}, this.indexes_);
                    return l[c] = o, new ot(l, u)
                }
                addToIndexes(e, t) {
                    const n = s.map(this.indexes_, ((n, r) => {
                        const i = s.safeGet(this.indexSet_, r);
                        if (s.assert(i, "Missing index implementation for " + r), n === it) {
                            if (i.isDefinedOn(e.node)) {
                                const n = [],
                                    r = t.getIterator(Le.Wrap);
                                let o = r.getNext();
                                for (; o;) o.name !== e.name && n.push(o), o = r.getNext();
                                return n.push(e), nt(n, i.getCompare())
                            }
                            return it
                        } {
                            const r = t.get(e.name);
                            let i = n;
                            return r && (i = i.remove(new Le(e.name, r))), i.insert(e, e.node)
                        }
                    }));
                    return new ot(n, this.indexSet_)
                }
                removeFromIndexes(e, t) {
                    const n = s.map(this.indexes_, (n => {
                        if (n === it) return n; {
                            const r = t.get(e.name);
                            return r ? n.remove(new Le(e.name, r)) : n
                        }
                    }));
                    return new ot(n, this.indexSet_)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let st;
            class at {
                constructor(e, t, n) {
                    this.children_ = e, this.priorityNode_ = t, this.indexMap_ = n, this.lazyHash_ = null, this.priorityNode_ && Ke(this.priorityNode_), this.children_.isEmpty() && s.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority")
                }
                static get EMPTY_NODE() {
                    return st || (st = new at(new Be(Ge), null, ot.Default))
                }
                isLeafNode() {
                    return !1
                }
                getPriority() {
                    return this.priorityNode_ || st
                }
                updatePriority(e) {
                    return this.children_.isEmpty() ? this : new at(this.children_, e, this.indexMap_)
                }
                getImmediateChild(e) {
                    if (".priority" === e) return this.getPriority(); {
                        const t = this.children_.get(e);
                        return null === t ? st : t
                    }
                }
                getChild(e) {
                    const t = ve(e);
                    return null === t ? this : this.getImmediateChild(t).getChild(be(e))
                }
                hasChild(e) {
                    return null !== this.children_.get(e)
                }
                updateImmediateChild(e, t) {
                    if (s.assert(t, "We should always be passing snapshot nodes"), ".priority" === e) return this.updatePriority(t); {
                        const n = new Le(e, t);
                        let r, i;
                        t.isEmpty() ? (r = this.children_.remove(e), i = this.indexMap_.removeFromIndexes(n, this.children_)) : (r = this.children_.insert(e, t), i = this.indexMap_.addToIndexes(n, this.children_));
                        const o = r.isEmpty() ? st : this.priorityNode_;
                        return new at(r, o, i)
                    }
                }
                updateChild(e, t) {
                    const n = ve(e);
                    if (null === n) return t; {
                        s.assert(".priority" !== ve(e) || 1 === ye(e), ".priority must be the last token in a path");
                        const r = this.getImmediateChild(n).updateChild(be(e), t);
                        return this.updateImmediateChild(n, r)
                    }
                }
                isEmpty() {
                    return this.children_.isEmpty()
                }
                numChildren() {
                    return this.children_.count()
                }
                val(e) {
                    if (this.isEmpty()) return null;
                    const t = {};
                    let n = 0,
                        r = 0,
                        i = !0;
                    if (this.forEachChild(Ze, ((o, s) => {
                            t[o] = s.val(e), n++, i && at.INTEGER_REGEXP_.test(o) ? r = Math.max(r, Number(o)) : i = !1
                        })), !e && i && r < 2 * n) {
                        const e = [];
                        for (const n in t) e[n] = t[n];
                        return e
                    }
                    return e && !this.getPriority().isEmpty() && (t[".priority"] = this.getPriority().val()), t
                }
                hash() {
                    if (null === this.lazyHash_) {
                        let e = "";
                        this.getPriority().isEmpty() || (e += "priority:" + $e(this.getPriority().val()) + ":"), this.forEachChild(Ze, ((t, n) => {
                            const r = n.hash();
                            "" !== r && (e += ":" + t + ":" + r)
                        })), this.lazyHash_ = "" === e ? "" : y(e)
                    }
                    return this.lazyHash_
                }
                getPredecessorChildName(e, t, n) {
                    const r = this.resolveIndex_(n);
                    if (r) {
                        const n = r.getPredecessorKey(new Le(e, t));
                        return n ? n.name : null
                    }
                    return this.children_.getPredecessorKey(e)
                }
                getFirstChildName(e) {
                    const t = this.resolveIndex_(e);
                    if (t) {
                        const e = t.minKey();
                        return e && e.name
                    }
                    return this.children_.minKey()
                }
                getFirstChild(e) {
                    const t = this.getFirstChildName(e);
                    return t ? new Le(t, this.children_.get(t)) : null
                }
                getLastChildName(e) {
                    const t = this.resolveIndex_(e);
                    if (t) {
                        const e = t.maxKey();
                        return e && e.name
                    }
                    return this.children_.maxKey()
                }
                getLastChild(e) {
                    const t = this.getLastChildName(e);
                    return t ? new Le(t, this.children_.get(t)) : null
                }
                forEachChild(e, t) {
                    const n = this.resolveIndex_(e);
                    return n ? n.inorderTraversal((e => t(e.name, e.node))) : this.children_.inorderTraversal(t)
                }
                getIterator(e) {
                    return this.getIteratorFrom(e.minPost(), e)
                }
                getIteratorFrom(e, t) {
                    const n = this.resolveIndex_(t);
                    if (n) return n.getIteratorFrom(e, (e => e)); {
                        const n = this.children_.getIteratorFrom(e.name, Le.Wrap);
                        let r = n.peek();
                        for (; null != r && t.compare(r, e) < 0;) n.getNext(), r = n.peek();
                        return n
                    }
                }
                getReverseIterator(e) {
                    return this.getReverseIteratorFrom(e.maxPost(), e)
                }
                getReverseIteratorFrom(e, t) {
                    const n = this.resolveIndex_(t);
                    if (n) return n.getReverseIteratorFrom(e, (e => e)); {
                        const n = this.children_.getReverseIteratorFrom(e.name, Le.Wrap);
                        let r = n.peek();
                        for (; null != r && t.compare(r, e) > 0;) n.getNext(), r = n.peek();
                        return n
                    }
                }
                compareTo(e) {
                    return this.isEmpty() ? e.isEmpty() ? 0 : -1 : e.isLeafNode() || e.isEmpty() ? 1 : e === ct ? -1 : 0
                }
                withIndex(e) {
                    if (e === qe || this.indexMap_.hasIndex(e)) return this; {
                        const t = this.indexMap_.addIndex(e, this.children_);
                        return new at(this.children_, this.priorityNode_, t)
                    }
                }
                isIndexed(e) {
                    return e === qe || this.indexMap_.hasIndex(e)
                }
                equals(e) {
                    if (e === this) return !0;
                    if (e.isLeafNode()) return !1; {
                        const t = e;
                        if (this.getPriority().equals(t.getPriority())) {
                            if (this.children_.count() === t.children_.count()) {
                                const e = this.getIterator(Ze),
                                    n = t.getIterator(Ze);
                                let r = e.getNext(),
                                    i = n.getNext();
                                for (; r && i;) {
                                    if (r.name !== i.name || !r.node.equals(i.node)) return !1;
                                    r = e.getNext(), i = n.getNext()
                                }
                                return null === r && null === i
                            }
                            return !1
                        }
                        return !1
                    }
                }
                resolveIndex_(e) {
                    return e === qe ? null : this.indexMap_.get(e.toString())
                }
            }
            at.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
            const ct = new class extends at {
                constructor() {
                    super(new Be(Ge), at.EMPTY_NODE, ot.Default)
                }
                compareTo(e) {
                    return e === this ? 0 : 1
                }
                equals(e) {
                    return e === this
                }
                getPriority() {
                    return this
                }
                getImmediateChild(e) {
                    return at.EMPTY_NODE
                }
                isEmpty() {
                    return !1
                }
            };
            Object.defineProperties(Le, {
                    MIN: {
                        value: new Le(O, at.EMPTY_NODE)
                    },
                    MAX: {
                        value: new Le(k, ct)
                    }
                }), je.__EMPTY_NODE = at.EMPTY_NODE, Xe.__childrenNodeConstructor = at, ze = ct,
                function(e) {
                    Qe = e
                }(ct);
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const ut = !0;

            function lt(e, t = null) {
                if (null === e) return at.EMPTY_NODE;
                if ("object" == typeof e && ".priority" in e && (t = e[".priority"]), s.assert(null === t || "string" == typeof t || "number" == typeof t || "object" == typeof t && ".sv" in t, "Invalid priority type found: " + typeof t), "object" == typeof e && ".value" in e && null !== e[".value"] && (e = e[".value"]), "object" != typeof e || ".sv" in e) {
                    return new Xe(e, lt(t))
                }
                if (e instanceof Array || !ut) {
                    let n = at.EMPTY_NODE;
                    return U(e, ((t, r) => {
                        if (s.contains(e, t) && "." !== t.substring(0, 1)) {
                            const e = lt(r);
                            !e.isLeafNode() && e.isEmpty() || (n = n.updateImmediateChild(t, e))
                        }
                    })), n.updatePriority(lt(t))
                } {
                    const n = [];
                    let r = !1;
                    if (U(e, ((e, t) => {
                            if ("." !== e.substring(0, 1)) {
                                const i = lt(t);
                                i.isEmpty() || (r = r || !i.getPriority().isEmpty(), n.push(new Le(e, i)))
                            }
                        })), 0 === n.length) return at.EMPTY_NODE;
                    const i = nt(n, Ve, (e => e.name), Ge);
                    if (r) {
                        const e = nt(n, Ze.getCompare());
                        return new at(i, lt(t), new ot({
                            ".priority": e
                        }, {
                            ".priority": Ze
                        }))
                    }
                    return new at(i, lt(t), ot.Default)
                }
            }! function(e) {
                Je = e
            }(lt);
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class dt extends Ue {
                constructor(e) {
                    super(), this.indexPath_ = e, s.assert(!Ce(e) && ".priority" !== ve(e), "Can't create PathIndex with empty path or .priority key")
                }
                extractChild(e) {
                    return e.getChild(this.indexPath_)
                }
                isDefinedOn(e) {
                    return !e.getChild(this.indexPath_).isEmpty()
                }
                compare(e, t) {
                    const n = this.extractChild(e.node),
                        r = this.extractChild(t.node),
                        i = n.compareTo(r);
                    return 0 === i ? N(e.name, t.name) : i
                }
                makePost(e, t) {
                    const n = lt(e),
                        r = at.EMPTY_NODE.updateChild(this.indexPath_, n);
                    return new Le(t, r)
                }
                maxPost() {
                    const e = at.EMPTY_NODE.updateChild(this.indexPath_, ct);
                    return new Le(k, e)
                }
                toString() {
                    return Ee(this.indexPath_, 0).join("/")
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const ht = new class extends Ue {
                compare(e, t) {
                    const n = e.node.compareTo(t.node);
                    return 0 === n ? N(e.name, t.name) : n
                }
                isDefinedOn(e) {
                    return !0
                }
                indexedValueChanged(e, t) {
                    return !e.equals(t)
                }
                minPost() {
                    return Le.MIN
                }
                maxPost() {
                    return Le.MAX
                }
                makePost(e, t) {
                    const n = lt(e);
                    return new Le(t, n)
                }
                toString() {
                    return ".value"
                }
            };
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function pt(e) {
                return {
                    type: "value",
                    snapshotNode: e
                }
            }

            function ft(e, t) {
                return {
                    type: "child_added",
                    snapshotNode: t,
                    childName: e
                }
            }

            function mt(e, t) {
                return {
                    type: "child_removed",
                    snapshotNode: t,
                    childName: e
                }
            }

            function gt(e, t, n) {
                return {
                    type: "child_changed",
                    snapshotNode: t,
                    childName: e,
                    oldSnap: n
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class _t {
                constructor(e) {
                    this.index_ = e
                }
                updateChild(e, t, n, r, i, o) {
                    s.assert(e.isIndexed(this.index_), "A node must be indexed if only a child is updated");
                    const a = e.getImmediateChild(t);
                    return a.getChild(r).equals(n.getChild(r)) && a.isEmpty() === n.isEmpty() ? e : (null != o && (n.isEmpty() ? e.hasChild(t) ? o.trackChildChange(mt(t, a)) : s.assert(e.isLeafNode(), "A child remove without an old child only makes sense on a leaf node") : a.isEmpty() ? o.trackChildChange(ft(t, n)) : o.trackChildChange(gt(t, n, a))), e.isLeafNode() && n.isEmpty() ? e : e.updateImmediateChild(t, n).withIndex(this.index_))
                }
                updateFullNode(e, t, n) {
                    return null != n && (e.isLeafNode() || e.forEachChild(Ze, ((e, r) => {
                        t.hasChild(e) || n.trackChildChange(mt(e, r))
                    })), t.isLeafNode() || t.forEachChild(Ze, ((t, r) => {
                        if (e.hasChild(t)) {
                            const i = e.getImmediateChild(t);
                            i.equals(r) || n.trackChildChange(gt(t, r, i))
                        } else n.trackChildChange(ft(t, r))
                    }))), t.withIndex(this.index_)
                }
                updatePriority(e, t) {
                    return e.isEmpty() ? at.EMPTY_NODE : e.updatePriority(t)
                }
                filtersNodes() {
                    return !1
                }
                getIndexedFilter() {
                    return this
                }
                getIndex() {
                    return this.index_
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class vt {
                constructor(e) {
                    this.indexedFilter_ = new _t(e.getIndex()), this.index_ = e.getIndex(), this.startPost_ = vt.getStartPost_(e), this.endPost_ = vt.getEndPost_(e), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_
                }
                getStartPost() {
                    return this.startPost_
                }
                getEndPost() {
                    return this.endPost_
                }
                matches(e) {
                    const t = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), e) <= 0 : this.index_.compare(this.getStartPost(), e) < 0,
                        n = this.endIsInclusive_ ? this.index_.compare(e, this.getEndPost()) <= 0 : this.index_.compare(e, this.getEndPost()) < 0;
                    return t && n
                }
                updateChild(e, t, n, r, i, o) {
                    return this.matches(new Le(t, n)) || (n = at.EMPTY_NODE), this.indexedFilter_.updateChild(e, t, n, r, i, o)
                }
                updateFullNode(e, t, n) {
                    t.isLeafNode() && (t = at.EMPTY_NODE);
                    let r = t.withIndex(this.index_);
                    r = r.updatePriority(at.EMPTY_NODE);
                    const i = this;
                    return t.forEachChild(Ze, ((e, t) => {
                        i.matches(new Le(e, t)) || (r = r.updateImmediateChild(e, at.EMPTY_NODE))
                    })), this.indexedFilter_.updateFullNode(e, r, n)
                }
                updatePriority(e, t) {
                    return e
                }
                filtersNodes() {
                    return !0
                }
                getIndexedFilter() {
                    return this.indexedFilter_
                }
                getIndex() {
                    return this.index_
                }
                static getStartPost_(e) {
                    if (e.hasStart()) {
                        const t = e.getIndexStartName();
                        return e.getIndex().makePost(e.getIndexStartValue(), t)
                    }
                    return e.getIndex().minPost()
                }
                static getEndPost_(e) {
                    if (e.hasEnd()) {
                        const t = e.getIndexEndName();
                        return e.getIndex().makePost(e.getIndexEndValue(), t)
                    }
                    return e.getIndex().maxPost()
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class yt {
                constructor(e) {
                    this.withinDirectionalStart = e => this.reverse_ ? this.withinEndPost(e) : this.withinStartPost(e), this.withinDirectionalEnd = e => this.reverse_ ? this.withinStartPost(e) : this.withinEndPost(e), this.withinStartPost = e => {
                        const t = this.index_.compare(this.rangedFilter_.getStartPost(), e);
                        return this.startIsInclusive_ ? t <= 0 : t < 0
                    }, this.withinEndPost = e => {
                        const t = this.index_.compare(e, this.rangedFilter_.getEndPost());
                        return this.endIsInclusive_ ? t <= 0 : t < 0
                    }, this.rangedFilter_ = new vt(e), this.index_ = e.getIndex(), this.limit_ = e.getLimit(), this.reverse_ = !e.isViewFromLeft(), this.startIsInclusive_ = !e.startAfterSet_, this.endIsInclusive_ = !e.endBeforeSet_
                }
                updateChild(e, t, n, r, i, o) {
                    return this.rangedFilter_.matches(new Le(t, n)) || (n = at.EMPTY_NODE), e.getImmediateChild(t).equals(n) ? e : e.numChildren() < this.limit_ ? this.rangedFilter_.getIndexedFilter().updateChild(e, t, n, r, i, o) : this.fullLimitUpdateChild_(e, t, n, i, o)
                }
                updateFullNode(e, t, n) {
                    let r;
                    if (t.isLeafNode() || t.isEmpty()) r = at.EMPTY_NODE.withIndex(this.index_);
                    else if (2 * this.limit_ < t.numChildren() && t.isIndexed(this.index_)) {
                        let e;
                        r = at.EMPTY_NODE.withIndex(this.index_), e = this.reverse_ ? t.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_) : t.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                        let n = 0;
                        for (; e.hasNext() && n < this.limit_;) {
                            const t = e.getNext();
                            if (this.withinDirectionalStart(t)) {
                                if (!this.withinDirectionalEnd(t)) break;
                                r = r.updateImmediateChild(t.name, t.node), n++
                            }
                        }
                    } else {
                        let e;
                        r = t.withIndex(this.index_), r = r.updatePriority(at.EMPTY_NODE), e = this.reverse_ ? r.getReverseIterator(this.index_) : r.getIterator(this.index_);
                        let n = 0;
                        for (; e.hasNext();) {
                            const t = e.getNext();
                            n < this.limit_ && this.withinDirectionalStart(t) && this.withinDirectionalEnd(t) ? n++ : r = r.updateImmediateChild(t.name, at.EMPTY_NODE)
                        }
                    }
                    return this.rangedFilter_.getIndexedFilter().updateFullNode(e, r, n)
                }
                updatePriority(e, t) {
                    return e
                }
                filtersNodes() {
                    return !0
                }
                getIndexedFilter() {
                    return this.rangedFilter_.getIndexedFilter()
                }
                getIndex() {
                    return this.index_
                }
                fullLimitUpdateChild_(e, t, n, r, i) {
                    let o;
                    if (this.reverse_) {
                        const e = this.index_.getCompare();
                        o = (t, n) => e(n, t)
                    } else o = this.index_.getCompare();
                    const a = e;
                    s.assert(a.numChildren() === this.limit_, "");
                    const c = new Le(t, n),
                        u = this.reverse_ ? a.getFirstChild(this.index_) : a.getLastChild(this.index_),
                        l = this.rangedFilter_.matches(c);
                    if (a.hasChild(t)) {
                        const e = a.getImmediateChild(t);
                        let s = r.getChildAfterChild(this.index_, u, this.reverse_);
                        for (; null != s && (s.name === t || a.hasChild(s.name));) s = r.getChildAfterChild(this.index_, s, this.reverse_);
                        const d = null == s ? 1 : o(s, c);
                        if (l && !n.isEmpty() && d >= 0) return null != i && i.trackChildChange(gt(t, n, e)), a.updateImmediateChild(t, n); {
                            null != i && i.trackChildChange(mt(t, e));
                            const n = a.updateImmediateChild(t, at.EMPTY_NODE);
                            return null != s && this.rangedFilter_.matches(s) ? (null != i && i.trackChildChange(ft(s.name, s.node)), n.updateImmediateChild(s.name, s.node)) : n
                        }
                    }
                    return n.isEmpty() ? e : l && o(u, c) >= 0 ? (null != i && (i.trackChildChange(mt(u.name, u.node)), i.trackChildChange(ft(t, n))), a.updateImmediateChild(t, n).updateImmediateChild(u.name, at.EMPTY_NODE)) : e
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class bt {
                constructor() {
                    this.limitSet_ = !1, this.startSet_ = !1, this.startNameSet_ = !1, this.startAfterSet_ = !1, this.endSet_ = !1, this.endNameSet_ = !1, this.endBeforeSet_ = !1, this.limit_ = 0, this.viewFrom_ = "", this.indexStartValue_ = null, this.indexStartName_ = "", this.indexEndValue_ = null, this.indexEndName_ = "", this.index_ = Ze
                }
                hasStart() {
                    return this.startSet_
                }
                isViewFromLeft() {
                    return "" === this.viewFrom_ ? this.startSet_ : "l" === this.viewFrom_
                }
                getIndexStartValue() {
                    return s.assert(this.startSet_, "Only valid if start has been set"), this.indexStartValue_
                }
                getIndexStartName() {
                    return s.assert(this.startSet_, "Only valid if start has been set"), this.startNameSet_ ? this.indexStartName_ : O
                }
                hasEnd() {
                    return this.endSet_
                }
                getIndexEndValue() {
                    return s.assert(this.endSet_, "Only valid if end has been set"), this.indexEndValue_
                }
                getIndexEndName() {
                    return s.assert(this.endSet_, "Only valid if end has been set"), this.endNameSet_ ? this.indexEndName_ : k
                }
                hasLimit() {
                    return this.limitSet_
                }
                hasAnchoredLimit() {
                    return this.limitSet_ && "" !== this.viewFrom_
                }
                getLimit() {
                    return s.assert(this.limitSet_, "Only valid if limit has been set"), this.limit_
                }
                getIndex() {
                    return this.index_
                }
                loadsAllData() {
                    return !(this.startSet_ || this.endSet_ || this.limitSet_)
                }
                isDefault() {
                    return this.loadsAllData() && this.index_ === Ze
                }
                copy() {
                    const e = new bt;
                    return e.limitSet_ = this.limitSet_, e.limit_ = this.limit_, e.startSet_ = this.startSet_, e.startAfterSet_ = this.startAfterSet_, e.indexStartValue_ = this.indexStartValue_, e.startNameSet_ = this.startNameSet_, e.indexStartName_ = this.indexStartName_, e.endSet_ = this.endSet_, e.endBeforeSet_ = this.endBeforeSet_, e.indexEndValue_ = this.indexEndValue_, e.endNameSet_ = this.endNameSet_, e.indexEndName_ = this.indexEndName_, e.index_ = this.index_, e.viewFrom_ = this.viewFrom_, e
                }
            }

            function It(e, t, n) {
                const r = e.copy();
                return r.startSet_ = !0, void 0 === t && (t = null), r.indexStartValue_ = t, null != n ? (r.startNameSet_ = !0, r.indexStartName_ = n) : (r.startNameSet_ = !1, r.indexStartName_ = ""), r
            }

            function Et(e, t, n) {
                const r = e.copy();
                return r.endSet_ = !0, void 0 === t && (t = null), r.indexEndValue_ = t, void 0 !== n ? (r.endNameSet_ = !0, r.indexEndName_ = n) : (r.endNameSet_ = !1, r.indexEndName_ = ""), r
            }

            function St(e, t) {
                const n = e.copy();
                return n.index_ = t, n
            }

            function wt(e) {
                const t = {};
                if (e.isDefault()) return t;
                let n;
                if (e.index_ === Ze ? n = "$priority" : e.index_ === ht ? n = "$value" : e.index_ === qe ? n = "$key" : (s.assert(e.index_ instanceof dt, "Unrecognized index type!"), n = e.index_.toString()), t.orderBy = s.stringify(n), e.startSet_) {
                    const n = e.startAfterSet_ ? "startAfter" : "startAt";
                    t[n] = s.stringify(e.indexStartValue_), e.startNameSet_ && (t[n] += "," + s.stringify(e.indexStartName_))
                }
                if (e.endSet_) {
                    const n = e.endBeforeSet_ ? "endBefore" : "endAt";
                    t[n] = s.stringify(e.indexEndValue_), e.endNameSet_ && (t[n] += "," + s.stringify(e.indexEndName_))
                }
                return e.limitSet_ && (e.isViewFromLeft() ? t.limitToFirst = e.limit_ : t.limitToLast = e.limit_), t
            }

            function Ct(e) {
                const t = {};
                if (e.startSet_ && (t.sp = e.indexStartValue_, e.startNameSet_ && (t.sn = e.indexStartName_), t.sin = !e.startAfterSet_), e.endSet_ && (t.ep = e.indexEndValue_, e.endNameSet_ && (t.en = e.indexEndName_), t.ein = !e.endBeforeSet_), e.limitSet_) {
                    t.l = e.limit_;
                    let n = e.viewFrom_;
                    "" === n && (n = e.isViewFromLeft() ? "l" : "r"), t.vf = n
                }
                return e.index_ !== Ze && (t.i = e.index_.toString()), t
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Tt extends de {
                constructor(e, t, n, r) {
                    super(), this.repoInfo_ = e, this.onDataUpdate_ = t, this.authTokenProvider_ = n, this.appCheckTokenProvider_ = r, this.log_ = C("p:rest:"), this.listens_ = {}
                }
                reportStats(e) {
                    throw new Error("Method not implemented.")
                }
                static getListenId_(e, t) {
                    return void 0 !== t ? "tag$" + t : (s.assert(e._queryParams.isDefault(), "should have a tag if it's not a default query."), e._path.toString())
                }
                listen(e, t, n, r) {
                    const i = e._path.toString();
                    this.log_("Listen called for " + i + " " + e._queryIdentifier);
                    const o = Tt.getListenId_(e, n),
                        a = {};
                    this.listens_[o] = a;
                    const c = wt(e._queryParams);
                    this.restRequest_(i + ".json", c, ((e, t) => {
                        let c = t;
                        if (404 === e && (c = null, e = null), null === e && this.onDataUpdate_(i, c, !1, n), s.safeGet(this.listens_, o) === a) {
                            let t;
                            t = e ? 401 === e ? "permission_denied" : "rest_error:" + e : "ok", r(t, null)
                        }
                    }))
                }
                unlisten(e, t) {
                    const n = Tt.getListenId_(e, t);
                    delete this.listens_[n]
                }
                get(e) {
                    const t = wt(e._queryParams),
                        n = e._path.toString(),
                        r = new s.Deferred;
                    return this.restRequest_(n + ".json", t, ((e, t) => {
                        let i = t;
                        404 === e && (i = null, e = null), null === e ? (this.onDataUpdate_(n, i, !1, null), r.resolve(i)) : r.reject(new Error(i))
                    })), r.promise
                }
                refreshAuthToken(e) {}
                restRequest_(e, t = {}, n) {
                    return t.format = "export", Promise.all([this.authTokenProvider_.getToken(!1), this.appCheckTokenProvider_.getToken(!1)]).then((([r, i]) => {
                        r && r.accessToken && (t.auth = r.accessToken), i && i.token && (t.ac = i.token);
                        const o = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + e + "?ns=" + this.repoInfo_.namespace + s.querystring(t);
                        this.log_("Sending REST request for " + o);
                        const a = new XMLHttpRequest;
                        a.onreadystatechange = () => {
                            if (n && 4 === a.readyState) {
                                this.log_("REST Response for " + o + " received. status:", a.status, "response:", a.responseText);
                                let e = null;
                                if (a.status >= 200 && a.status < 300) {
                                    try {
                                        e = s.jsonEval(a.responseText)
                                    } catch (e) {
                                        R("Failed to parse JSON response for " + o + ": " + a.responseText)
                                    }
                                    n(null, e)
                                } else 401 !== a.status && 404 !== a.status && R("Got unsuccessful REST response for " + o + " Status: " + a.status), n(a.status);
                                n = null
                            }
                        }, a.open("GET", o, !0), a.send()
                    }))
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class At {
                constructor() {
                    this.rootNode_ = at.EMPTY_NODE
                }
                getNode(e) {
                    return this.rootNode_.getChild(e)
                }
                updateSnapshot(e, t) {
                    this.rootNode_ = this.rootNode_.updateChild(e, t)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function Rt() {
                return {
                    value: null,
                    children: new Map
                }
            }

            function Pt(e, t, n) {
                if (Ce(t)) e.value = n, e.children.clear();
                else if (null !== e.value) e.value = e.value.updateChild(t, n);
                else {
                    const r = ve(t);
                    e.children.has(r) || e.children.set(r, Rt());
                    Pt(e.children.get(r), t = be(t), n)
                }
            }

            function Ot(e, t) {
                if (Ce(t)) return e.value = null, e.children.clear(), !0;
                if (null !== e.value) {
                    if (e.value.isLeafNode()) return !1; {
                        const n = e.value;
                        return e.value = null, n.forEachChild(Ze, ((t, n) => {
                            Pt(e, new ge(t), n)
                        })), Ot(e, t)
                    }
                }
                if (e.children.size > 0) {
                    const n = ve(t);
                    if (t = be(t), e.children.has(n)) {
                        Ot(e.children.get(n), t) && e.children.delete(n)
                    }
                    return 0 === e.children.size
                }
                return !0
            }

            function kt(e, t, n) {
                null !== e.value ? n(t, e.value) : function(e, t) {
                    e.children.forEach(((e, n) => {
                        t(n, e)
                    }))
                }
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                (e, ((e, r) => {
                    kt(r, new ge(t.toString() + "/" + e), n)
                }))
            }
            class Nt {
                constructor(e) {
                    this.collection_ = e, this.last_ = null
                }
                get() {
                    const e = this.collection_.get(),
                        t = Object.assign({}, e);
                    return this.last_ && U(this.last_, ((e, n) => {
                        t[e] = t[e] - n
                    })), this.last_ = e, t
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Dt {
                constructor(e, t) {
                    this.server_ = t, this.statsToReport_ = {}, this.statsListener_ = new Nt(e);
                    const n = 1e4 + 2e4 * Math.random();
                    W(this.reportStats_.bind(this), Math.floor(n))
                }
                reportStats_() {
                    const e = this.statsListener_.get(),
                        t = {};
                    let n = !1;
                    U(e, ((e, r) => {
                        r > 0 && s.contains(this.statsToReport_, e) && (t[e] = r, n = !0)
                    })), n && this.server_.reportStats(t), W(this.reportStats_.bind(this), Math.floor(2 * Math.random() * 3e5))
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var Mt;

            function xt(e) {
                return {
                    fromUser: !1,
                    fromServer: !0,
                    queryId: e,
                    tagged: !0
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            ! function(e) {
                e[e.OVERWRITE = 0] = "OVERWRITE", e[e.MERGE = 1] = "MERGE", e[e.ACK_USER_WRITE = 2] = "ACK_USER_WRITE", e[e.LISTEN_COMPLETE = 3] = "LISTEN_COMPLETE"
            }(Mt || (Mt = {}));
            class Lt {
                constructor(e, t, n) {
                    this.path = e, this.affectedTree = t, this.revert = n, this.type = Mt.ACK_USER_WRITE, this.source = {
                        fromUser: !0,
                        fromServer: !1,
                        queryId: null,
                        tagged: !1
                    }
                }
                operationForChild(e) {
                    if (Ce(this.path)) {
                        if (null != this.affectedTree.value) return s.assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths."), this; {
                            const t = this.affectedTree.subtree(new ge(e));
                            return new Lt(_e(), t, this.revert)
                        }
                    }
                    return s.assert(ve(this.path) === e, "operationForChild called for unrelated child."), new Lt(be(this.path), this.affectedTree, this.revert)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ut {
                constructor(e, t) {
                    this.source = e, this.path = t, this.type = Mt.LISTEN_COMPLETE
                }
                operationForChild(e) {
                    return Ce(this.path) ? new Ut(this.source, _e()) : new Ut(this.source, be(this.path))
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ft {
                constructor(e, t, n) {
                    this.source = e, this.path = t, this.snap = n, this.type = Mt.OVERWRITE
                }
                operationForChild(e) {
                    return Ce(this.path) ? new Ft(this.source, _e(), this.snap.getImmediateChild(e)) : new Ft(this.source, be(this.path), this.snap)
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class jt {
                constructor(e, t, n) {
                    this.source = e, this.path = t, this.children = n, this.type = Mt.MERGE
                }
                operationForChild(e) {
                    if (Ce(this.path)) {
                        const t = this.children.subtree(new ge(e));
                        return t.isEmpty() ? null : t.value ? new Ft(this.source, _e(), t.value) : new jt(this.source, _e(), t)
                    }
                    return s.assert(ve(this.path) === e, "Can't get a merge for a child not on the path of the operation"), new jt(this.source, be(this.path), this.children)
                }
                toString() {
                    return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")"
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class qt {
                constructor(e, t, n) {
                    this.node_ = e, this.fullyInitialized_ = t, this.filtered_ = n
                }
                isFullyInitialized() {
                    return this.fullyInitialized_
                }
                isFiltered() {
                    return this.filtered_
                }
                isCompleteForPath(e) {
                    if (Ce(e)) return this.isFullyInitialized() && !this.filtered_;
                    const t = ve(e);
                    return this.isCompleteForChild(t)
                }
                isCompleteForChild(e) {
                    return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(e)
                }
                getNode() {
                    return this.node_
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ht {
                constructor(e) {
                    this.query_ = e, this.index_ = this.query_._queryParams.getIndex()
                }
            }

            function Wt(e, t, n, r, i, o) {
                const a = r.filter((e => e.type === n));
                a.sort(((t, n) => function(e, t, n) {
                        if (null == t.childName || null == n.childName) throw s.assertionError("Should only compare child_ events.");
                        const r = new Le(t.childName, t.snapshotNode),
                            i = new Le(n.childName, n.snapshotNode);
                        return e.index_.compare(r, i)
                    }
                    /**
                     * @license
                     * Copyright 2017 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                    (e, t, n))), a.forEach((n => {
                    const r = function(e, t, n) {
                        return "value" === t.type || "child_removed" === t.type || (t.prevName = n.getPredecessorChildName(t.childName, t.snapshotNode, e.index_)), t
                    }(e, n, o);
                    i.forEach((i => {
                        i.respondsTo(n.type) && t.push(i.createEvent(r, e.query_))
                    }))
                }))
            }

            function Bt(e, t) {
                return {
                    eventCache: e,
                    serverCache: t
                }
            }

            function Vt(e, t, n, r) {
                return Bt(new qt(t, n, r), e.serverCache)
            }

            function Gt(e, t, n, r) {
                return Bt(e.eventCache, new qt(t, n, r))
            }

            function zt(e) {
                return e.eventCache.isFullyInitialized() ? e.eventCache.getNode() : null
            }

            function $t(e) {
                return e.serverCache.isFullyInitialized() ? e.serverCache.getNode() : null
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let Kt;
            class Yt {
                constructor(e, t = (() => (Kt || (Kt = new Be(D)), Kt))()) {
                    this.value = e, this.children = t
                }
                static fromObject(e) {
                    let t = new Yt(null);
                    return U(e, ((e, n) => {
                        t = t.set(new ge(e), n)
                    })), t
                }
                isEmpty() {
                    return null === this.value && this.children.isEmpty()
                }
                findRootMostMatchingPathAndValue(e, t) {
                    if (null != this.value && t(this.value)) return {
                        path: _e(),
                        value: this.value
                    };
                    if (Ce(e)) return null; {
                        const n = ve(e),
                            r = this.children.get(n);
                        if (null !== r) {
                            const i = r.findRootMostMatchingPathAndValue(be(e), t);
                            if (null != i) {
                                return {
                                    path: we(new ge(n), i.path),
                                    value: i.value
                                }
                            }
                            return null
                        }
                        return null
                    }
                }
                findRootMostValueAndPath(e) {
                    return this.findRootMostMatchingPathAndValue(e, (() => !0))
                }
                subtree(e) {
                    if (Ce(e)) return this; {
                        const t = ve(e),
                            n = this.children.get(t);
                        return null !== n ? n.subtree(be(e)) : new Yt(null)
                    }
                }
                set(e, t) {
                    if (Ce(e)) return new Yt(t, this.children); {
                        const n = ve(e),
                            r = (this.children.get(n) || new Yt(null)).set(be(e), t),
                            i = this.children.insert(n, r);
                        return new Yt(this.value, i)
                    }
                }
                remove(e) {
                    if (Ce(e)) return this.children.isEmpty() ? new Yt(null) : new Yt(null, this.children); {
                        const t = ve(e),
                            n = this.children.get(t);
                        if (n) {
                            const r = n.remove(be(e));
                            let i;
                            return i = r.isEmpty() ? this.children.remove(t) : this.children.insert(t, r), null === this.value && i.isEmpty() ? new Yt(null) : new Yt(this.value, i)
                        }
                        return this
                    }
                }
                get(e) {
                    if (Ce(e)) return this.value; {
                        const t = ve(e),
                            n = this.children.get(t);
                        return n ? n.get(be(e)) : null
                    }
                }
                setTree(e, t) {
                    if (Ce(e)) return t; {
                        const n = ve(e),
                            r = (this.children.get(n) || new Yt(null)).setTree(be(e), t);
                        let i;
                        return i = r.isEmpty() ? this.children.remove(n) : this.children.insert(n, r), new Yt(this.value, i)
                    }
                }
                fold(e) {
                    return this.fold_(_e(), e)
                }
                fold_(e, t) {
                    const n = {};
                    return this.children.inorderTraversal(((r, i) => {
                        n[r] = i.fold_(we(e, r), t)
                    })), t(e, this.value, n)
                }
                findOnPath(e, t) {
                    return this.findOnPath_(e, _e(), t)
                }
                findOnPath_(e, t, n) {
                    const r = !!this.value && n(t, this.value);
                    if (r) return r;
                    if (Ce(e)) return null; {
                        const r = ve(e),
                            i = this.children.get(r);
                        return i ? i.findOnPath_(be(e), we(t, r), n) : null
                    }
                }
                foreachOnPath(e, t) {
                    return this.foreachOnPath_(e, _e(), t)
                }
                foreachOnPath_(e, t, n) {
                    if (Ce(e)) return this; {
                        this.value && n(t, this.value);
                        const r = ve(e),
                            i = this.children.get(r);
                        return i ? i.foreachOnPath_(be(e), we(t, r), n) : new Yt(null)
                    }
                }
                foreach(e) {
                    this.foreach_(_e(), e)
                }
                foreach_(e, t) {
                    this.children.inorderTraversal(((n, r) => {
                        r.foreach_(we(e, n), t)
                    })), this.value && t(e, this.value)
                }
                foreachChild(e) {
                    this.children.inorderTraversal(((t, n) => {
                        n.value && e(t, n.value)
                    }))
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Jt {
                constructor(e) {
                    this.writeTree_ = e
                }
                static empty() {
                    return new Jt(new Yt(null))
                }
            }

            function Qt(e, t, n) {
                if (Ce(t)) return new Jt(new Yt(n)); {
                    const r = e.writeTree_.findRootMostValueAndPath(t);
                    if (null != r) {
                        const i = r.path;
                        let o = r.value;
                        const s = Te(i, t);
                        return o = o.updateChild(s, n), new Jt(e.writeTree_.set(i, o))
                    } {
                        const r = new Yt(n),
                            i = e.writeTree_.setTree(t, r);
                        return new Jt(i)
                    }
                }
            }

            function Xt(e, t, n) {
                let r = e;
                return U(n, ((e, n) => {
                    r = Qt(r, we(t, e), n)
                })), r
            }

            function Zt(e, t) {
                if (Ce(t)) return Jt.empty(); {
                    const n = e.writeTree_.setTree(t, new Yt(null));
                    return new Jt(n)
                }
            }

            function en(e, t) {
                return null != tn(e, t)
            }

            function tn(e, t) {
                const n = e.writeTree_.findRootMostValueAndPath(t);
                return null != n ? e.writeTree_.get(n.path).getChild(Te(n.path, t)) : null
            }

            function nn(e) {
                const t = [],
                    n = e.writeTree_.value;
                return null != n ? n.isLeafNode() || n.forEachChild(Ze, ((e, n) => {
                    t.push(new Le(e, n))
                })) : e.writeTree_.children.inorderTraversal(((e, n) => {
                    null != n.value && t.push(new Le(e, n.value))
                })), t
            }

            function rn(e, t) {
                if (Ce(t)) return e; {
                    const n = tn(e, t);
                    return new Jt(null != n ? new Yt(n) : e.writeTree_.subtree(t))
                }
            }

            function on(e) {
                return e.writeTree_.isEmpty()
            }

            function sn(e, t) {
                return an(_e(), e.writeTree_, t)
            }

            function an(e, t, n) {
                if (null != t.value) return n.updateChild(e, t.value); {
                    let r = null;
                    return t.children.inorderTraversal(((t, i) => {
                        ".priority" === t ? (s.assert(null !== i.value, "Priority writes must always be leaf nodes"), r = i.value) : n = an(we(e, t), i, n)
                    })), n.getChild(e).isEmpty() || null === r || (n = n.updateChild(we(e, ".priority"), r)), n
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function cn(e, t) {
                return In(t, e)
            }

            function un(e, t) {
                const n = e.allWrites.findIndex((e => e.writeId === t));
                s.assert(n >= 0, "removeWrite called with nonexistent writeId.");
                const r = e.allWrites[n];
                e.allWrites.splice(n, 1);
                let i = r.visible,
                    o = !1,
                    a = e.allWrites.length - 1;
                for (; i && a >= 0;) {
                    const t = e.allWrites[a];
                    t.visible && (a >= n && ln(t, r.path) ? i = !1 : Pe(r.path, t.path) && (o = !0)), a--
                }
                if (i) {
                    if (o) return function(e) {
                        e.visibleWrites = hn(e.allWrites, dn, _e()), e.allWrites.length > 0 ? e.lastWriteId = e.allWrites[e.allWrites.length - 1].writeId : e.lastWriteId = -1
                    }(e), !0;
                    if (r.snap) e.visibleWrites = Zt(e.visibleWrites, r.path);
                    else {
                        U(r.children, (t => {
                            e.visibleWrites = Zt(e.visibleWrites, we(r.path, t))
                        }))
                    }
                    return !0
                }
                return !1
            }

            function ln(e, t) {
                if (e.snap) return Pe(e.path, t);
                for (const n in e.children)
                    if (e.children.hasOwnProperty(n) && Pe(we(e.path, n), t)) return !0;
                return !1
            }

            function dn(e) {
                return e.visible
            }

            function hn(e, t, n) {
                let r = Jt.empty();
                for (let i = 0; i < e.length; ++i) {
                    const o = e[i];
                    if (t(o)) {
                        const e = o.path;
                        let t;
                        if (o.snap) Pe(n, e) ? (t = Te(n, e), r = Qt(r, t, o.snap)) : Pe(e, n) && (t = Te(e, n), r = Qt(r, _e(), o.snap.getChild(t)));
                        else {
                            if (!o.children) throw s.assertionError("WriteRecord should have .snap or .children");
                            if (Pe(n, e)) t = Te(n, e), r = Xt(r, t, o.children);
                            else if (Pe(e, n))
                                if (t = Te(e, n), Ce(t)) r = Xt(r, _e(), o.children);
                                else {
                                    const e = s.safeGet(o.children, ve(t));
                                    if (e) {
                                        const n = e.getChild(be(t));
                                        r = Qt(r, _e(), n)
                                    }
                                }
                        }
                    }
                }
                return r
            }

            function pn(e, t, n, r, i) {
                if (r || i) {
                    const o = rn(e.visibleWrites, t);
                    if (!i && on(o)) return n;
                    if (i || null != n || en(o, _e())) {
                        const o = function(e) {
                            return (e.visible || i) && (!r || !~r.indexOf(e.writeId)) && (Pe(e.path, t) || Pe(t, e.path))
                        };
                        return sn(hn(e.allWrites, o, t), n || at.EMPTY_NODE)
                    }
                    return null
                } {
                    const r = tn(e.visibleWrites, t);
                    if (null != r) return r; {
                        const r = rn(e.visibleWrites, t);
                        if (on(r)) return n;
                        if (null != n || en(r, _e())) {
                            return sn(r, n || at.EMPTY_NODE)
                        }
                        return null
                    }
                }
            }

            function fn(e, t, n, r) {
                return pn(e.writeTree, e.treePath, t, n, r)
            }

            function mn(e, t) {
                return function(e, t, n) {
                    let r = at.EMPTY_NODE;
                    const i = tn(e.visibleWrites, t);
                    if (i) return i.isLeafNode() || i.forEachChild(Ze, ((e, t) => {
                        r = r.updateImmediateChild(e, t)
                    })), r;
                    if (n) {
                        const i = rn(e.visibleWrites, t);
                        return n.forEachChild(Ze, ((e, t) => {
                            const n = sn(rn(i, new ge(e)), t);
                            r = r.updateImmediateChild(e, n)
                        })), nn(i).forEach((e => {
                            r = r.updateImmediateChild(e.name, e.node)
                        })), r
                    }
                    return nn(rn(e.visibleWrites, t)).forEach((e => {
                        r = r.updateImmediateChild(e.name, e.node)
                    })), r
                }(e.writeTree, e.treePath, t)
            }

            function gn(e, t, n, r) {
                return function(e, t, n, r, i) {
                    s.assert(r || i, "Either existingEventSnap or existingServerSnap must exist");
                    const o = we(t, n);
                    if (en(e.visibleWrites, o)) return null; {
                        const t = rn(e.visibleWrites, o);
                        return on(t) ? i.getChild(n) : sn(t, i.getChild(n))
                    }
                }(e.writeTree, e.treePath, t, n, r)
            }

            function _n(e, t) {
                return function(e, t) {
                    return tn(e.visibleWrites, t)
                }(e.writeTree, we(e.treePath, t))
            }

            function vn(e, t, n, r, i, o) {
                return function(e, t, n, r, i, o, s) {
                    let a;
                    const c = rn(e.visibleWrites, t),
                        u = tn(c, _e());
                    if (null != u) a = u;
                    else {
                        if (null == n) return [];
                        a = sn(c, n)
                    }
                    if (a = a.withIndex(s), a.isEmpty() || a.isLeafNode()) return []; {
                        const e = [],
                            t = s.getCompare(),
                            n = o ? a.getReverseIteratorFrom(r, s) : a.getIteratorFrom(r, s);
                        let c = n.getNext();
                        for (; c && e.length < i;) 0 !== t(c, r) && e.push(c), c = n.getNext();
                        return e
                    }
                }(e.writeTree, e.treePath, t, n, r, i, o)
            }

            function yn(e, t, n) {
                return function(e, t, n, r) {
                    const i = we(t, n),
                        o = tn(e.visibleWrites, i);
                    if (null != o) return o;
                    if (r.isCompleteForChild(n)) return sn(rn(e.visibleWrites, i), r.getNode().getImmediateChild(n));
                    return null
                }(e.writeTree, e.treePath, t, n)
            }

            function bn(e, t) {
                return In(we(e.treePath, t), e.writeTree)
            }

            function In(e, t) {
                return {
                    treePath: e,
                    writeTree: t
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class En {
                constructor() {
                    this.changeMap = new Map
                }
                trackChildChange(e) {
                    const t = e.type,
                        n = e.childName;
                    s.assert("child_added" === t || "child_changed" === t || "child_removed" === t, "Only child changes supported for tracking"), s.assert(".priority" !== n, "Only non-priority child changes can be tracked.");
                    const r = this.changeMap.get(n);
                    if (r) {
                        const i = r.type;
                        if ("child_added" === t && "child_removed" === i) this.changeMap.set(n, gt(n, e.snapshotNode, r.snapshotNode));
                        else if ("child_removed" === t && "child_added" === i) this.changeMap.delete(n);
                        else if ("child_removed" === t && "child_changed" === i) this.changeMap.set(n, mt(n, r.oldSnap));
                        else if ("child_changed" === t && "child_added" === i) this.changeMap.set(n, ft(n, e.snapshotNode));
                        else {
                            if ("child_changed" !== t || "child_changed" !== i) throw s.assertionError("Illegal combination of changes: " + e + " occurred after " + r);
                            this.changeMap.set(n, gt(n, e.snapshotNode, r.oldSnap))
                        }
                    } else this.changeMap.set(n, e)
                }
                getChanges() {
                    return Array.from(this.changeMap.values())
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Sn = new class {
                getCompleteChild(e) {
                    return null
                }
                getChildAfterChild(e, t, n) {
                    return null
                }
            };
            class wn {
                constructor(e, t, n = null) {
                    this.writes_ = e, this.viewCache_ = t, this.optCompleteServerCache_ = n
                }
                getCompleteChild(e) {
                    const t = this.viewCache_.eventCache;
                    if (t.isCompleteForChild(e)) return t.getNode().getImmediateChild(e); {
                        const t = null != this.optCompleteServerCache_ ? new qt(this.optCompleteServerCache_, !0, !1) : this.viewCache_.serverCache;
                        return yn(this.writes_, e, t)
                    }
                }
                getChildAfterChild(e, t, n) {
                    const r = null != this.optCompleteServerCache_ ? this.optCompleteServerCache_ : $t(this.viewCache_),
                        i = vn(this.writes_, r, t, 1, n, e);
                    return 0 === i.length ? null : i[0]
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function Cn(e, t, n, r, i) {
                const o = new En;
                let a, c;
                if (n.type === Mt.OVERWRITE) {
                    const u = n;
                    u.source.fromUser ? a = Rn(e, t, u.path, u.snap, r, i, o) : (s.assert(u.source.fromServer, "Unknown source."), c = u.source.tagged || t.serverCache.isFiltered() && !Ce(u.path), a = An(e, t, u.path, u.snap, r, i, c, o))
                } else if (n.type === Mt.MERGE) {
                    const u = n;
                    u.source.fromUser ? a = function(e, t, n, r, i, o, s) {
                        let a = t;
                        return r.foreach(((r, c) => {
                            const u = we(n, r);
                            Pn(t, ve(u)) && (a = Rn(e, a, u, c, i, o, s))
                        })), r.foreach(((r, c) => {
                            const u = we(n, r);
                            Pn(t, ve(u)) || (a = Rn(e, a, u, c, i, o, s))
                        })), a
                    }(e, t, u.path, u.children, r, i, o) : (s.assert(u.source.fromServer, "Unknown source."), c = u.source.tagged || t.serverCache.isFiltered(), a = kn(e, t, u.path, u.children, r, i, c, o))
                } else if (n.type === Mt.ACK_USER_WRITE) {
                    const c = n;
                    a = c.revert ? function(e, t, n, r, i, o) {
                        let a;
                        if (null != _n(r, n)) return t; {
                            const c = new wn(r, t, i),
                                u = t.eventCache.getNode();
                            let l;
                            if (Ce(n) || ".priority" === ve(n)) {
                                let n;
                                if (t.serverCache.isFullyInitialized()) n = fn(r, $t(t));
                                else {
                                    const e = t.serverCache.getNode();
                                    s.assert(e instanceof at, "serverChildren would be complete if leaf node"), n = mn(r, e)
                                }
                                l = e.filter.updateFullNode(u, n, o)
                            } else {
                                const i = ve(n);
                                let s = yn(r, i, t.serverCache);
                                null == s && t.serverCache.isCompleteForChild(i) && (s = u.getImmediateChild(i)), l = null != s ? e.filter.updateChild(u, i, s, be(n), c, o) : t.eventCache.getNode().hasChild(i) ? e.filter.updateChild(u, i, at.EMPTY_NODE, be(n), c, o) : u, l.isEmpty() && t.serverCache.isFullyInitialized() && (a = fn(r, $t(t)), a.isLeafNode() && (l = e.filter.updateFullNode(l, a, o)))
                            }
                            return a = t.serverCache.isFullyInitialized() || null != _n(r, _e()), Vt(t, l, a, e.filter.filtersNodes())
                        }
                    }
                    /**
                     * @license
                     * Copyright 2017 Google LLC
                     *
                     * Licensed under the Apache License, Version 2.0 (the "License");
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *   http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an "AS IS" BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                    (e, t, c.path, r, i, o): function(e, t, n, r, i, o, s) {
                        if (null != _n(i, n)) return t;
                        const a = t.serverCache.isFiltered(),
                            c = t.serverCache;
                        if (null != r.value) {
                            if (Ce(n) && c.isFullyInitialized() || c.isCompleteForPath(n)) return An(e, t, n, c.getNode().getChild(n), i, o, a, s);
                            if (Ce(n)) {
                                let r = new Yt(null);
                                return c.getNode().forEachChild(qe, ((e, t) => {
                                    r = r.set(new ge(e), t)
                                })), kn(e, t, n, r, i, o, a, s)
                            }
                            return t
                        } {
                            let u = new Yt(null);
                            return r.foreach(((e, t) => {
                                const r = we(n, e);
                                c.isCompleteForPath(r) && (u = u.set(e, c.getNode().getChild(r)))
                            })), kn(e, t, n, u, i, o, a, s)
                        }
                    }(e, t, c.path, c.affectedTree, r, i, o)
                } else {
                    if (n.type !== Mt.LISTEN_COMPLETE) throw s.assertionError("Unknown operation type: " + n.type);
                    a = function(e, t, n, r, i) {
                        const o = t.serverCache,
                            s = Gt(t, o.getNode(), o.isFullyInitialized() || Ce(n), o.isFiltered());
                        return Tn(e, s, n, r, Sn, i)
                    }(e, t, n.path, r, o)
                }
                const u = o.getChanges();
                return function(e, t, n) {
                    const r = t.eventCache;
                    if (r.isFullyInitialized()) {
                        const i = r.getNode().isLeafNode() || r.getNode().isEmpty(),
                            o = zt(e);
                        (n.length > 0 || !e.eventCache.isFullyInitialized() || i && !r.getNode().equals(o) || !r.getNode().getPriority().equals(o.getPriority())) && n.push(pt(zt(t)))
                    }
                }(t, a, u), {
                    viewCache: a,
                    changes: u
                }
            }

            function Tn(e, t, n, r, i, o) {
                const a = t.eventCache;
                if (null != _n(r, n)) return t; {
                    let c, u;
                    if (Ce(n))
                        if (s.assert(t.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data"), t.serverCache.isFiltered()) {
                            const n = $t(t),
                                i = mn(r, n instanceof at ? n : at.EMPTY_NODE);
                            c = e.filter.updateFullNode(t.eventCache.getNode(), i, o)
                        } else {
                            const n = fn(r, $t(t));
                            c = e.filter.updateFullNode(t.eventCache.getNode(), n, o)
                        }
                    else {
                        const l = ve(n);
                        if (".priority" === l) {
                            s.assert(1 === ye(n), "Can't have a priority with additional path components");
                            const i = a.getNode();
                            u = t.serverCache.getNode();
                            const o = gn(r, n, i, u);
                            c = null != o ? e.filter.updatePriority(i, o) : a.getNode()
                        } else {
                            const s = be(n);
                            let d;
                            if (a.isCompleteForChild(l)) {
                                u = t.serverCache.getNode();
                                const e = gn(r, n, a.getNode(), u);
                                d = null != e ? a.getNode().getImmediateChild(l).updateChild(s, e) : a.getNode().getImmediateChild(l)
                            } else d = yn(r, l, t.serverCache);
                            c = null != d ? e.filter.updateChild(a.getNode(), l, d, s, i, o) : a.getNode()
                        }
                    }
                    return Vt(t, c, a.isFullyInitialized() || Ce(n), e.filter.filtersNodes())
                }
            }

            function An(e, t, n, r, i, o, s, a) {
                const c = t.serverCache;
                let u;
                const l = s ? e.filter : e.filter.getIndexedFilter();
                if (Ce(n)) u = l.updateFullNode(c.getNode(), r, null);
                else if (l.filtersNodes() && !c.isFiltered()) {
                    const e = c.getNode().updateChild(n, r);
                    u = l.updateFullNode(c.getNode(), e, null)
                } else {
                    const e = ve(n);
                    if (!c.isCompleteForPath(n) && ye(n) > 1) return t;
                    const i = be(n),
                        o = c.getNode().getImmediateChild(e).updateChild(i, r);
                    u = ".priority" === e ? l.updatePriority(c.getNode(), o) : l.updateChild(c.getNode(), e, o, i, Sn, null)
                }
                const d = Gt(t, u, c.isFullyInitialized() || Ce(n), l.filtersNodes());
                return Tn(e, d, n, i, new wn(i, d, o), a)
            }

            function Rn(e, t, n, r, i, o, s) {
                const a = t.eventCache;
                let c, u;
                const l = new wn(i, t, o);
                if (Ce(n)) u = e.filter.updateFullNode(t.eventCache.getNode(), r, s), c = Vt(t, u, !0, e.filter.filtersNodes());
                else {
                    const i = ve(n);
                    if (".priority" === i) u = e.filter.updatePriority(t.eventCache.getNode(), r), c = Vt(t, u, a.isFullyInitialized(), a.isFiltered());
                    else {
                        const o = be(n),
                            u = a.getNode().getImmediateChild(i);
                        let d;
                        if (Ce(o)) d = r;
                        else {
                            const e = l.getCompleteChild(i);
                            d = null != e ? ".priority" === Ie(o) && e.getChild(Se(o)).isEmpty() ? e : e.updateChild(o, r) : at.EMPTY_NODE
                        }
                        if (u.equals(d)) c = t;
                        else {
                            c = Vt(t, e.filter.updateChild(a.getNode(), i, d, o, l, s), a.isFullyInitialized(), e.filter.filtersNodes())
                        }
                    }
                }
                return c
            }

            function Pn(e, t) {
                return e.eventCache.isCompleteForChild(t)
            }

            function On(e, t, n) {
                return n.foreach(((e, n) => {
                    t = t.updateChild(e, n)
                })), t
            }

            function kn(e, t, n, r, i, o, s, a) {
                if (t.serverCache.getNode().isEmpty() && !t.serverCache.isFullyInitialized()) return t;
                let c, u = t;
                c = Ce(n) ? r : new Yt(null).setTree(n, r);
                const l = t.serverCache.getNode();
                return c.children.inorderTraversal(((n, r) => {
                    if (l.hasChild(n)) {
                        const c = On(0, t.serverCache.getNode().getImmediateChild(n), r);
                        u = An(e, u, new ge(n), c, i, o, s, a)
                    }
                })), c.children.inorderTraversal(((n, r) => {
                    const c = !t.serverCache.isCompleteForChild(n) && null === r.value;
                    if (!l.hasChild(n) && !c) {
                        const c = On(0, t.serverCache.getNode().getImmediateChild(n), r);
                        u = An(e, u, new ge(n), c, i, o, s, a)
                    }
                })), u
            }
            class Nn {
                constructor(e, t) {
                    this.query_ = e, this.eventRegistrations_ = [];
                    const n = this.query_._queryParams,
                        r = new _t(n.getIndex()),
                        i = (o = n).loadsAllData() ? new _t(o.getIndex()) : o.hasLimit() ? new yt(o) : new vt(o);
                    var o;
                    this.processor_ = function(e) {
                        return {
                            filter: e
                        }
                    }(i);
                    const s = t.serverCache,
                        a = t.eventCache,
                        c = r.updateFullNode(at.EMPTY_NODE, s.getNode(), null),
                        u = i.updateFullNode(at.EMPTY_NODE, a.getNode(), null),
                        l = new qt(c, s.isFullyInitialized(), r.filtersNodes()),
                        d = new qt(u, a.isFullyInitialized(), i.filtersNodes());
                    this.viewCache_ = Bt(d, l), this.eventGenerator_ = new Ht(this.query_)
                }
                get query() {
                    return this.query_
                }
            }

            function Dn(e, t) {
                const n = $t(e.viewCache_);
                return n && (e.query._queryParams.loadsAllData() || !Ce(t) && !n.getImmediateChild(ve(t)).isEmpty()) ? n.getChild(t) : null
            }

            function Mn(e) {
                return 0 === e.eventRegistrations_.length
            }

            function xn(e, t, n) {
                const r = [];
                if (n) {
                    s.assert(null == t, "A cancel should cancel all event registrations.");
                    const i = e.query._path;
                    e.eventRegistrations_.forEach((e => {
                        const t = e.createCancelEvent(n, i);
                        t && r.push(t)
                    }))
                }
                if (t) {
                    let n = [];
                    for (let r = 0; r < e.eventRegistrations_.length; ++r) {
                        const i = e.eventRegistrations_[r];
                        if (i.matches(t)) {
                            if (t.hasAnyCallback()) {
                                n = n.concat(e.eventRegistrations_.slice(r + 1));
                                break
                            }
                        } else n.push(i)
                    }
                    e.eventRegistrations_ = n
                } else e.eventRegistrations_ = [];
                return r
            }

            function Ln(e, t, n, r) {
                t.type === Mt.MERGE && null !== t.source.queryId && (s.assert($t(e.viewCache_), "We should always have a full cache before handling merges"), s.assert(zt(e.viewCache_), "Missing event cache, even though we have a server cache"));
                const i = e.viewCache_,
                    o = Cn(e.processor_, i, t, n, r);
                var a, c;
                return a = e.processor_, c = o.viewCache, s.assert(c.eventCache.getNode().isIndexed(a.filter.getIndex()), "Event snap not indexed"), s.assert(c.serverCache.getNode().isIndexed(a.filter.getIndex()), "Server snap not indexed"), s.assert(o.viewCache.serverCache.isFullyInitialized() || !i.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back"), e.viewCache_ = o.viewCache, Un(e, o.changes, o.viewCache.eventCache.getNode(), null)
            }

            function Un(e, t, n, r) {
                const i = r ? [r] : e.eventRegistrations_;
                return function(e, t, n, r) {
                    const i = [],
                        o = [];
                    return t.forEach((t => {
                        var n;
                        "child_changed" === t.type && e.index_.indexedValueChanged(t.oldSnap, t.snapshotNode) && o.push((n = t.childName, {
                            type: "child_moved",
                            snapshotNode: t.snapshotNode,
                            childName: n
                        }))
                    })), Wt(e, i, "child_removed", t, r, n), Wt(e, i, "child_added", t, r, n), Wt(e, i, "child_moved", o, r, n), Wt(e, i, "child_changed", t, r, n), Wt(e, i, "value", t, r, n), i
                }(e.eventGenerator_, t, n, i)
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let Fn, jn;
            class qn {
                constructor() {
                    this.views = new Map
                }
            }

            function Hn(e, t, n, r) {
                const i = t.source.queryId;
                if (null !== i) {
                    const o = e.views.get(i);
                    return s.assert(null != o, "SyncTree gave us an op for an invalid query."), Ln(o, t, n, r)
                } {
                    let i = [];
                    for (const o of e.views.values()) i = i.concat(Ln(o, t, n, r));
                    return i
                }
            }

            function Wn(e, t, n, r, i) {
                const o = t._queryIdentifier,
                    s = e.views.get(o);
                if (!s) {
                    let e = fn(n, i ? r : null),
                        o = !1;
                    e ? o = !0 : r instanceof at ? (e = mn(n, r), o = !1) : (e = at.EMPTY_NODE, o = !1);
                    const s = Bt(new qt(e, o, !1), new qt(r, i, !1));
                    return new Nn(t, s)
                }
                return s
            }

            function Bn(e, t, n, r, i, o) {
                const s = Wn(e, t, r, i, o);
                return e.views.has(t._queryIdentifier) || e.views.set(t._queryIdentifier, s),
                    function(e, t) {
                        e.eventRegistrations_.push(t)
                    }(s, n),
                    function(e, t) {
                        const n = e.viewCache_.eventCache,
                            r = [];
                        n.getNode().isLeafNode() || n.getNode().forEachChild(Ze, ((e, t) => {
                            r.push(ft(e, t))
                        }));
                        return n.isFullyInitialized() && r.push(pt(n.getNode())), Un(e, r, n.getNode(), t)
                    }(s, n)
            }

            function Vn(e, t, n, r) {
                const i = t._queryIdentifier,
                    o = [];
                let a = [];
                const c = Yn(e);
                if ("default" === i)
                    for (const [t, i] of e.views.entries()) a = a.concat(xn(i, n, r)), Mn(i) && (e.views.delete(t), i.query._queryParams.loadsAllData() || o.push(i.query));
                else {
                    const t = e.views.get(i);
                    t && (a = a.concat(xn(t, n, r)), Mn(t) && (e.views.delete(i), t.query._queryParams.loadsAllData() || o.push(t.query)))
                }
                return c && !Yn(e) && o.push(new(s.assert(Fn, "Reference.ts has not been loaded"), Fn)(t._repo, t._path)), {
                    removed: o,
                    events: a
                }
            }

            function Gn(e) {
                const t = [];
                for (const n of e.views.values()) n.query._queryParams.loadsAllData() || t.push(n);
                return t
            }

            function zn(e, t) {
                let n = null;
                for (const r of e.views.values()) n = n || Dn(r, t);
                return n
            }

            function $n(e, t) {
                if (t._queryParams.loadsAllData()) return Jn(e); {
                    const n = t._queryIdentifier;
                    return e.views.get(n)
                }
            }

            function Kn(e, t) {
                return null != $n(e, t)
            }

            function Yn(e) {
                return null != Jn(e)
            }

            function Jn(e) {
                for (const t of e.views.values())
                    if (t.query._queryParams.loadsAllData()) return t;
                return null
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            let Qn = 1;
            class Xn {
                constructor(e) {
                    this.listenProvider_ = e, this.syncPointTree_ = new Yt(null), this.pendingWriteTree_ = {
                        visibleWrites: Jt.empty(),
                        allWrites: [],
                        lastWriteId: -1
                    }, this.tagToQueryMap = new Map, this.queryToTagMap = new Map
                }
            }

            function Zn(e, t, n, r, i) {
                return function(e, t, n, r, i) {
                    s.assert(r > e.lastWriteId, "Stacking an older write on top of newer ones"), void 0 === i && (i = !0), e.allWrites.push({
                        path: t,
                        snap: n,
                        writeId: r,
                        visible: i
                    }), i && (e.visibleWrites = Qt(e.visibleWrites, t, n)), e.lastWriteId = r
                }(e.pendingWriteTree_, t, n, r, i), i ? cr(e, new Ft({
                    fromUser: !0,
                    fromServer: !1,
                    queryId: null,
                    tagged: !1
                }, t, n)) : []
            }

            function er(e, t, n, r) {
                ! function(e, t, n, r) {
                    s.assert(r > e.lastWriteId, "Stacking an older merge on top of newer ones"), e.allWrites.push({
                        path: t,
                        children: n,
                        writeId: r,
                        visible: !0
                    }), e.visibleWrites = Xt(e.visibleWrites, t, n), e.lastWriteId = r
                }(e.pendingWriteTree_, t, n, r);
                const i = Yt.fromObject(n);
                return cr(e, new jt({
                    fromUser: !0,
                    fromServer: !1,
                    queryId: null,
                    tagged: !1
                }, t, i))
            }

            function tr(e, t, n = !1) {
                const r = function(e, t) {
                    for (let n = 0; n < e.allWrites.length; n++) {
                        const r = e.allWrites[n];
                        if (r.writeId === t) return r
                    }
                    return null
                }(e.pendingWriteTree_, t);
                if (un(e.pendingWriteTree_, t)) {
                    let t = new Yt(null);
                    return null != r.snap ? t = t.set(_e(), !0) : U(r.children, (e => {
                        t = t.set(new ge(e), !0)
                    })), cr(e, new Lt(r.path, t, n))
                }
                return []
            }

            function nr(e, t, n) {
                return cr(e, new Ft({
                    fromUser: !1,
                    fromServer: !0,
                    queryId: null,
                    tagged: !1
                }, t, n))
            }

            function rr(e, t, n, r, i = !1) {
                const o = t._path,
                    s = e.syncPointTree_.get(o);
                let a = [];
                if (s && ("default" === t._queryIdentifier || Kn(s, t))) {
                    const c = Vn(s, t, n, r);
                    0 === s.views.size && (e.syncPointTree_ = e.syncPointTree_.remove(o));
                    const u = c.removed;
                    if (a = c.events, !i) {
                        const n = -1 !== u.findIndex((e => e._queryParams.loadsAllData())),
                            i = e.syncPointTree_.findOnPath(o, ((e, t) => Yn(t)));
                        if (n && !i) {
                            const t = e.syncPointTree_.subtree(o);
                            if (!t.isEmpty()) {
                                const n = function(e) {
                                    return e.fold(((e, t, n) => {
                                        if (t && Yn(t)) {
                                            return [Jn(t)]
                                        } {
                                            let e = [];
                                            return t && (e = Gn(t)), U(n, ((t, n) => {
                                                e = e.concat(n)
                                            })), e
                                        }
                                    }))
                                }(t);
                                for (let t = 0; t < n.length; ++t) {
                                    const r = n[t],
                                        i = r.query,
                                        o = dr(e, r);
                                    e.listenProvider_.startListening(_r(i), hr(e, i), o.hashFn, o.onComplete)
                                }
                            }
                        }
                        if (!i && u.length > 0 && !r)
                            if (n) {
                                const n = null;
                                e.listenProvider_.stopListening(_r(t), n)
                            } else u.forEach((t => {
                                const n = e.queryToTagMap.get(pr(t));
                                e.listenProvider_.stopListening(_r(t), n)
                            }))
                    }! function(e, t) {
                        for (let n = 0; n < t.length; ++n) {
                            const r = t[n];
                            if (!r._queryParams.loadsAllData()) {
                                const t = pr(r),
                                    n = e.queryToTagMap.get(t);
                                e.queryToTagMap.delete(t), e.tagToQueryMap.delete(n)
                            }
                        }
                    }(e, u)
                }
                return a
            }

            function ir(e, t, n, r) {
                const i = fr(e, r);
                if (null != i) {
                    const r = mr(i),
                        o = r.path,
                        s = r.queryId,
                        a = Te(o, t);
                    return gr(e, o, new Ft(xt(s), a, n))
                }
                return []
            }

            function or(e, t, n, r = !1) {
                const i = t._path;
                let o = null,
                    a = !1;
                e.syncPointTree_.foreachOnPath(i, ((e, t) => {
                    const n = Te(e, i);
                    o = o || zn(t, n), a = a || Yn(t)
                }));
                let c, u = e.syncPointTree_.get(i);
                if (u ? (a = a || Yn(u), o = o || zn(u, _e())) : (u = new qn, e.syncPointTree_ = e.syncPointTree_.set(i, u)), null != o) c = !0;
                else {
                    c = !1, o = at.EMPTY_NODE;
                    e.syncPointTree_.subtree(i).foreachChild(((e, t) => {
                        const n = zn(t, _e());
                        n && (o = o.updateImmediateChild(e, n))
                    }))
                }
                const l = Kn(u, t);
                if (!l && !t._queryParams.loadsAllData()) {
                    const n = pr(t);
                    s.assert(!e.queryToTagMap.has(n), "View does not exist, but we have a tag");
                    const r = Qn++;
                    e.queryToTagMap.set(n, r), e.tagToQueryMap.set(r, n)
                }
                let d = Bn(u, t, n, cn(e.pendingWriteTree_, i), o, c);
                if (!l && !a && !r) {
                    const n = $n(u, t);
                    d = d.concat(function(e, t, n) {
                            const r = t._path,
                                i = hr(e, t),
                                o = dr(e, n),
                                a = e.listenProvider_.startListening(_r(t), i, o.hashFn, o.onComplete),
                                c = e.syncPointTree_.subtree(r);
                            if (i) s.assert(!Yn(c.value), "If we're adding a query, it shouldn't be shadowed");
                            else {
                                const t = c.fold(((e, t, n) => {
                                    if (!Ce(e) && t && Yn(t)) return [Jn(t).query]; {
                                        let e = [];
                                        return t && (e = e.concat(Gn(t).map((e => e.query)))), U(n, ((t, n) => {
                                            e = e.concat(n)
                                        })), e
                                    }
                                }));
                                for (let n = 0; n < t.length; ++n) {
                                    const r = t[n];
                                    e.listenProvider_.stopListening(_r(r), hr(e, r))
                                }
                            }
                            return a
                        }
                        /**
                         * @license
                         * Copyright 2017 Google LLC
                         *
                         * Licensed under the Apache License, Version 2.0 (the "License");
                         * you may not use this file except in compliance with the License.
                         * You may obtain a copy of the License at
                         *
                         *   http://www.apache.org/licenses/LICENSE-2.0
                         *
                         * Unless required by applicable law or agreed to in writing, software
                         * distributed under the License is distributed on an "AS IS" BASIS,
                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                         * See the License for the specific language governing permissions and
                         * limitations under the License.
                         */
                        (e, t, n))
                }
                return d
            }

            function sr(e, t, n) {
                const r = e.pendingWriteTree_,
                    i = e.syncPointTree_.findOnPath(t, ((e, n) => {
                        const r = zn(n, Te(e, t));
                        if (r) return r
                    }));
                return pn(r, t, i, n, !0)
            }

            function ar(e, t) {
                const n = t._path;
                let r = null;
                e.syncPointTree_.foreachOnPath(n, ((e, t) => {
                    const i = Te(e, n);
                    r = r || zn(t, i)
                }));
                let i = e.syncPointTree_.get(n);
                i ? r = r || zn(i, _e()) : (i = new qn, e.syncPointTree_ = e.syncPointTree_.set(n, i));
                const o = null != r,
                    s = o ? new qt(r, !0, !1) : null;
                return function(e) {
                    return zt(e.viewCache_)
                }(Wn(i, t, cn(e.pendingWriteTree_, t._path), o ? s.getNode() : at.EMPTY_NODE, o))
            }

            function cr(e, t) {
                return ur(t, e.syncPointTree_, null, cn(e.pendingWriteTree_, _e()))
            }

            function ur(e, t, n, r) {
                if (Ce(e.path)) return lr(e, t, n, r); {
                    const i = t.get(_e());
                    null == n && null != i && (n = zn(i, _e()));
                    let o = [];
                    const s = ve(e.path),
                        a = e.operationForChild(s),
                        c = t.children.get(s);
                    if (c && a) {
                        const e = n ? n.getImmediateChild(s) : null,
                            t = bn(r, s);
                        o = o.concat(ur(a, c, e, t))
                    }
                    return i && (o = o.concat(Hn(i, e, r, n))), o
                }
            }

            function lr(e, t, n, r) {
                const i = t.get(_e());
                null == n && null != i && (n = zn(i, _e()));
                let o = [];
                return t.children.inorderTraversal(((t, i) => {
                    const s = n ? n.getImmediateChild(t) : null,
                        a = bn(r, t),
                        c = e.operationForChild(t);
                    c && (o = o.concat(lr(c, i, s, a)))
                })), i && (o = o.concat(Hn(i, e, r, n))), o
            }

            function dr(e, t) {
                const n = t.query,
                    r = hr(e, n);
                return {
                    hashFn: () => {
                        const e = function(e) {
                            return e.viewCache_.serverCache.getNode()
                        }(t) || at.EMPTY_NODE;
                        return e.hash()
                    },
                    onComplete: t => {
                        if ("ok" === t) return r ? function(e, t, n) {
                            const r = fr(e, n);
                            if (r) {
                                const n = mr(r),
                                    i = n.path,
                                    o = n.queryId,
                                    s = Te(i, t);
                                return gr(e, i, new Ut(xt(o), s))
                            }
                            return []
                        }(e, n._path, r) : function(e, t) {
                            return cr(e, new Ut({
                                fromUser: !1,
                                fromServer: !0,
                                queryId: null,
                                tagged: !1
                            }, t))
                        }(e, n._path); {
                            const r = function(e, t) {
                                let n = "Unknown Error";
                                "too_big" === e ? n = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" === e ? n = "Client doesn't have permission to access the desired data." : "unavailable" === e && (n = "The service is unavailable");
                                const r = new Error(e + " at " + t._path.toString() + ": " + n);
                                return r.code = e.toUpperCase(), r
                            }(t, n);
                            return rr(e, n, null, r)
                        }
                    }
                }
            }

            function hr(e, t) {
                const n = pr(t);
                return e.queryToTagMap.get(n)
            }

            function pr(e) {
                return e._path.toString() + "$" + e._queryIdentifier
            }

            function fr(e, t) {
                return e.tagToQueryMap.get(t)
            }

            function mr(e) {
                const t = e.indexOf("$");
                return s.assert(-1 !== t && t < e.length - 1, "Bad queryKey."), {
                    queryId: e.substr(t + 1),
                    path: new ge(e.substr(0, t))
                }
            }

            function gr(e, t, n) {
                const r = e.syncPointTree_.get(t);
                s.assert(r, "Missing sync point for query tag that we're tracking");
                return Hn(r, n, cn(e.pendingWriteTree_, t), null)
            }

            function _r(e) {
                return e._queryParams.loadsAllData() && !e._queryParams.isDefault() ? new(s.assert(jn, "Reference.ts has not been loaded"), jn)(e._repo, e._path) : e
            }
            class vr {
                constructor(e) {
                    this.node_ = e
                }
                getImmediateChild(e) {
                    const t = this.node_.getImmediateChild(e);
                    return new vr(t)
                }
                node() {
                    return this.node_
                }
            }
            class yr {
                constructor(e, t) {
                    this.syncTree_ = e, this.path_ = t
                }
                getImmediateChild(e) {
                    const t = we(this.path_, e);
                    return new yr(this.syncTree_, t)
                }
                node() {
                    return sr(this.syncTree_, this.path_)
                }
            }
            const br = function(e) {
                    return (e = e || {}).timestamp = e.timestamp || (new Date).getTime(), e
                },
                Ir = function(e, t, n) {
                    return e && "object" == typeof e ? (s.assert(".sv" in e, "Unexpected leaf node or priority contents"), "string" == typeof e[".sv"] ? Er(e[".sv"], t, n) : "object" == typeof e[".sv"] ? Sr(e[".sv"], t) : void s.assert(!1, "Unexpected server value: " + JSON.stringify(e, null, 2))) : e
                },
                Er = function(e, t, n) {
                    if ("timestamp" === e) return n.timestamp;
                    s.assert(!1, "Unexpected server value: " + e)
                },
                Sr = function(e, t, n) {
                    e.hasOwnProperty("increment") || s.assert(!1, "Unexpected server value: " + JSON.stringify(e, null, 2));
                    const r = e.increment;
                    "number" != typeof r && s.assert(!1, "Unexpected increment value: " + r);
                    const i = t.node();
                    if (s.assert(null != i, "Expected ChildrenNode.EMPTY_NODE for nulls"), !i.isLeafNode()) return r;
                    const o = i.getValue();
                    return "number" != typeof o ? r : o + r
                },
                wr = function(e, t, n, r) {
                    return Tr(t, new yr(n, e), r)
                },
                Cr = function(e, t, n) {
                    return Tr(e, new vr(t), n)
                };

            function Tr(e, t, n) {
                const r = e.getPriority().val(),
                    i = Ir(r, t.getImmediateChild(".priority"), n);
                let o;
                if (e.isLeafNode()) {
                    const r = e,
                        o = Ir(r.getValue(), t, n);
                    return o !== r.getValue() || i !== r.getPriority().val() ? new Xe(o, lt(i)) : e
                } {
                    const r = e;
                    return o = r, i !== r.getPriority().val() && (o = o.updatePriority(new Xe(i))), r.forEachChild(Ze, ((e, r) => {
                        const i = Tr(r, t.getImmediateChild(e), n);
                        i !== r && (o = o.updateImmediateChild(e, i))
                    })), o
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ar {
                constructor(e = "", t = null, n = {
                    children: {},
                    childCount: 0
                }) {
                    this.name = e, this.parent = t, this.node = n
                }
            }

            function Rr(e, t) {
                let n = t instanceof ge ? t : new ge(t),
                    r = e,
                    i = ve(n);
                for (; null !== i;) {
                    const e = s.safeGet(r.node.children, i) || {
                        children: {},
                        childCount: 0
                    };
                    r = new Ar(i, r, e), n = be(n), i = ve(n)
                }
                return r
            }

            function Pr(e) {
                return e.node.value
            }

            function Or(e, t) {
                e.node.value = t, xr(e)
            }

            function kr(e) {
                return e.node.childCount > 0
            }

            function Nr(e, t) {
                U(e.node.children, ((n, r) => {
                    t(new Ar(n, e, r))
                }))
            }

            function Dr(e, t, n, r) {
                n && !r && t(e), Nr(e, (e => {
                    Dr(e, t, !0, r)
                })), n && r && t(e)
            }

            function Mr(e) {
                return new ge(null === e.parent ? e.name : Mr(e.parent) + "/" + e.name)
            }

            function xr(e) {
                null !== e.parent && function(e, t, n) {
                    const r = function(e) {
                            return void 0 === Pr(e) && !kr(e)
                        }(n),
                        i = s.contains(e.node.children, t);
                    r && i ? (delete e.node.children[t], e.node.childCount--, xr(e)) : r || i || (e.node.children[t] = n.node, e.node.childCount++, xr(e))
                }
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                (e.parent, e.name, e)
            }
            const Lr = /[\[\].#$\/\u0000-\u001F\u007F]/,
                Ur = /[\[\].#$\u0000-\u001F\u007F]/,
                Fr = 10485760,
                jr = function(e) {
                    return "string" == typeof e && 0 !== e.length && !Lr.test(e)
                },
                qr = function(e) {
                    return "string" == typeof e && 0 !== e.length && !Ur.test(e)
                },
                Hr = function(e) {
                    return null === e || "string" == typeof e || "number" == typeof e && !P(e) || e && "object" == typeof e && s.contains(e, ".sv")
                },
                Wr = function(e, t, n, r) {
                    r && void 0 === t || Br(s.errorPrefix(e, "value"), t, n)
                },
                Br = function(e, t, n) {
                    const r = n instanceof ge ? new Oe(n, e) : n;
                    if (void 0 === t) throw new Error(e + "contains undefined " + Ne(r));
                    if ("function" == typeof t) throw new Error(e + "contains a function " + Ne(r) + " with contents = " + t.toString());
                    if (P(t)) throw new Error(e + "contains " + t.toString() + " " + Ne(r));
                    if ("string" == typeof t && t.length > Fr / 3 && s.stringLength(t) > Fr) throw new Error(e + "contains a string greater than " + Fr + " utf8 bytes " + Ne(r) + " ('" + t.substring(0, 50) + "...')");
                    if (t && "object" == typeof t) {
                        let n = !1,
                            i = !1;
                        if (U(t, ((t, o) => {
                                if (".value" === t) n = !0;
                                else if (".priority" !== t && ".sv" !== t && (i = !0, !jr(t))) throw new Error(e + " contains an invalid key (" + t + ") " + Ne(r) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');
                                ! function(e, t) {
                                    e.parts_.length > 0 && (e.byteLength_ += 1), e.parts_.push(t), e.byteLength_ += s.stringLength(t), ke(e)
                                }(r, t), Br(e, o, r),
                                    function(e) {
                                        const t = e.parts_.pop();
                                        e.byteLength_ -= s.stringLength(t), e.parts_.length > 0 && (e.byteLength_ -= 1)
                                    }(r)
                            })), n && i) throw new Error(e + ' contains ".value" child ' + Ne(r) + " in addition to actual children.")
                    }
                },
                Vr = function(e, t, n, r) {
                    if (r && void 0 === t) return;
                    const i = s.errorPrefix(e, "values");
                    if (!t || "object" != typeof t || Array.isArray(t)) throw new Error(i + " must be an object containing the children to replace.");
                    const o = [];
                    U(t, ((e, t) => {
                            const r = new ge(e);
                            if (Br(i, t, we(n, r)), ".priority" === Ie(r) && !Hr(t)) throw new Error(i + "contains an invalid value for '" + r.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null).");
                            o.push(r)
                        })),
                        function(e, t) {
                            let n, r;
                            for (n = 0; n < t.length; n++) {
                                r = t[n];
                                const i = Ee(r);
                                for (let t = 0; t < i.length; t++)
                                    if (".priority" === i[t] && t === i.length - 1);
                                    else if (!jr(i[t])) throw new Error(e + "contains an invalid key (" + i[t] + ") in path " + r.toString() + '. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"')
                            }
                            t.sort(Ae);
                            let i = null;
                            for (n = 0; n < t.length; n++) {
                                if (r = t[n], null !== i && Pe(i, r)) throw new Error(e + "contains a path " + i.toString() + " that is ancestor of another path " + r.toString());
                                i = r
                            }
                        }(i, o)
                },
                Gr = function(e, t, n) {
                    if (!n || void 0 !== t) {
                        if (P(t)) throw new Error(s.errorPrefix(e, "priority") + "is " + t.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
                        if (!Hr(t)) throw new Error(s.errorPrefix(e, "priority") + "must be a valid Firebase priority (a string, finite number, server value, or null).")
                    }
                },
                zr = function(e, t, n, r) {
                    if (!(r && void 0 === n || jr(n))) throw new Error(s.errorPrefix(e, t) + 'was an invalid key = "' + n + '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").')
                },
                $r = function(e, t, n, r) {
                    if (!(r && void 0 === n || qr(n))) throw new Error(s.errorPrefix(e, t) + 'was an invalid path = "' + n + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"')
                },
                Kr = function(e, t, n, r) {
                    n && (n = n.replace(/^\/*\.info(\/|$)/, "/")), $r(e, t, n, r)
                },
                Yr = function(e, t) {
                    if (".info" === ve(t)) throw new Error(e + " failed = Can't modify data under /.info/")
                },
                Jr = function(e, t) {
                    const n = t.path.toString();
                    if ("string" != typeof t.repoInfo.host || 0 === t.repoInfo.host.length || !jr(t.repoInfo.namespace) && "localhost" !== t.repoInfo.host.split(":")[0] || 0 !== n.length && ! function(e) {
                            return e && (e = e.replace(/^\/*\.info(\/|$)/, "/")), qr(e)
                        }(n)) throw new Error(s.errorPrefix(e, "url") + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".')
                };
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Qr {
                constructor() {
                    this.eventLists_ = [], this.recursionDepth_ = 0
                }
            }

            function Xr(e, t) {
                let n = null;
                for (let r = 0; r < t.length; r++) {
                    const i = t[r],
                        o = i.getPath();
                    null === n || Re(o, n.path) || (e.eventLists_.push(n), n = null), null === n && (n = {
                        events: [],
                        path: o
                    }), n.events.push(i)
                }
                n && e.eventLists_.push(n)
            }

            function Zr(e, t, n) {
                Xr(e, n), ti(e, (e => Re(e, t)))
            }

            function ei(e, t, n) {
                Xr(e, n), ti(e, (e => Pe(e, t) || Pe(t, e)))
            }

            function ti(e, t) {
                e.recursionDepth_++;
                let n = !0;
                for (let r = 0; r < e.eventLists_.length; r++) {
                    const i = e.eventLists_[r];
                    if (i) {
                        t(i.path) ? (ni(e.eventLists_[r]), e.eventLists_[r] = null) : n = !1
                    }
                }
                n && (e.eventLists_ = []), e.recursionDepth_--
            }

            function ni(e) {
                for (let t = 0; t < e.events.length; t++) {
                    const n = e.events[t];
                    if (null !== n) {
                        e.events[t] = null;
                        const r = n.getEventRunner();
                        I && w("event: " + n.toString()), H(r)
                    }
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const ri = "repo_interrupt",
                ii = 25;
            class oi {
                constructor(e, t, n, r) {
                    this.repoInfo_ = e, this.forceRestClient_ = t, this.authTokenProvider_ = n, this.appCheckProvider_ = r, this.dataUpdateCount = 0, this.statsListener_ = null, this.eventQueue_ = new Qr, this.nextWriteId_ = 1, this.interceptServerDataCallback_ = null, this.onDisconnect_ = Rt(), this.transactionQueueTree_ = new Ar, this.persistentConnection_ = null, this.key = this.repoInfo_.toURLString()
                }
                toString() {
                    return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host
                }
            }

            function si(e, t, n) {
                if (e.stats_ = ne(e.repoInfo_), e.forceRestClient_ || ("object" == typeof window && window.navigator && window.navigator.userAgent || "").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0) e.server_ = new Tt(e.repoInfo_, ((t, n, r, i) => {
                    ui(e, t, n, r, i)
                }), e.authTokenProvider_, e.appCheckProvider_), setTimeout((() => li(e, !0)), 0);
                else {
                    if (null != n) {
                        if ("object" != typeof n) throw new Error("Only objects are supported for option databaseAuthVariableOverride");
                        try {
                            s.stringify(n)
                        } catch (e) {
                            throw new Error("Invalid authOverride provided: " + e)
                        }
                    }
                    e.persistentConnection_ = new xe(e.repoInfo_, t, ((t, n, r, i) => {
                        ui(e, t, n, r, i)
                    }), (t => {
                        li(e, t)
                    }), (t => {
                        ! function(e, t) {
                            U(t, ((t, n) => {
                                di(e, t, n)
                            }))
                        }(e, t)
                    }), e.authTokenProvider_, e.appCheckProvider_, n), e.server_ = e.persistentConnection_
                }
                e.authTokenProvider_.addTokenChangeListener((t => {
                    e.server_.refreshAuthToken(t)
                })), e.appCheckProvider_.addTokenChangeListener((t => {
                    e.server_.refreshAppCheckToken(t.token)
                })), e.statsReporter_ = function(e, t) {
                    const n = e.toString();
                    return te[n] || (te[n] = t()), te[n]
                }(e.repoInfo_, (() => new Dt(e.stats_, e.server_))), e.infoData_ = new At, e.infoSyncTree_ = new Xn({
                    startListening: (t, n, r, i) => {
                        let o = [];
                        const s = e.infoData_.getNode(t._path);
                        return s.isEmpty() || (o = nr(e.infoSyncTree_, t._path, s), setTimeout((() => {
                            i("ok")
                        }), 0)), o
                    },
                    stopListening: () => {}
                }), di(e, "connected", !1), e.serverSyncTree_ = new Xn({
                    startListening: (t, n, r, i) => (e.server_.listen(t, r, n, ((n, r) => {
                        const o = i(n, r);
                        ei(e.eventQueue_, t._path, o)
                    })), []),
                    stopListening: (t, n) => {
                        e.server_.unlisten(t, n)
                    }
                })
            }

            function ai(e) {
                const t = e.infoData_.getNode(new ge(".info/serverTimeOffset")).val() || 0;
                return (new Date).getTime() + t
            }

            function ci(e) {
                return br({
                    timestamp: ai(e)
                })
            }

            function ui(e, t, n, r, i) {
                e.dataUpdateCount++;
                const o = new ge(t);
                n = e.interceptServerDataCallback_ ? e.interceptServerDataCallback_(t, n) : n;
                let a = [];
                if (i)
                    if (r) {
                        const t = s.map(n, (e => lt(e)));
                        a = function(e, t, n, r) {
                            const i = fr(e, r);
                            if (i) {
                                const r = mr(i),
                                    o = r.path,
                                    s = r.queryId,
                                    a = Te(o, t),
                                    c = Yt.fromObject(n);
                                return gr(e, o, new jt(xt(s), a, c))
                            }
                            return []
                        }(e.serverSyncTree_, o, t, i)
                    } else {
                        const t = lt(n);
                        a = ir(e.serverSyncTree_, o, t, i)
                    }
                else if (r) {
                    const t = s.map(n, (e => lt(e)));
                    a = function(e, t, n) {
                        const r = Yt.fromObject(n);
                        return cr(e, new jt({
                            fromUser: !1,
                            fromServer: !0,
                            queryId: null,
                            tagged: !1
                        }, t, r))
                    }(e.serverSyncTree_, o, t)
                } else {
                    const t = lt(n);
                    a = nr(e.serverSyncTree_, o, t)
                }
                let c = o;
                a.length > 0 && (c = Ei(e, o)), ei(e.eventQueue_, c, a)
            }

            function li(e, t) {
                di(e, "connected", t), !1 === t && function(e) {
                    vi(e, "onDisconnectEvents");
                    const t = ci(e),
                        n = Rt();
                    kt(e.onDisconnect_, _e(), ((r, i) => {
                        const o = wr(r, i, e.serverSyncTree_, t);
                        Pt(n, r, o)
                    }));
                    let r = [];
                    kt(n, _e(), ((t, n) => {
                        r = r.concat(nr(e.serverSyncTree_, t, n));
                        const i = Ai(e, t);
                        Ei(e, i)
                    })), e.onDisconnect_ = Rt(), ei(e.eventQueue_, _e(), r)
                }(e)
            }

            function di(e, t, n) {
                const r = new ge("/.info/" + t),
                    i = lt(n);
                e.infoData_.updateSnapshot(r, i);
                const o = nr(e.infoSyncTree_, r, i);
                ei(e.eventQueue_, r, o)
            }

            function hi(e) {
                return e.nextWriteId_++
            }

            function pi(e, t, n, r, i) {
                vi(e, "set", {
                    path: t.toString(),
                    value: n,
                    priority: r
                });
                const o = ci(e),
                    s = lt(n, r),
                    a = sr(e.serverSyncTree_, t),
                    c = Cr(s, a, o),
                    u = hi(e),
                    l = Zn(e.serverSyncTree_, t, c, u, !0);
                Xr(e.eventQueue_, l), e.server_.put(t.toString(), s.val(!0), ((n, r) => {
                    const o = "ok" === n;
                    o || R("set at " + t + " failed: " + n);
                    const s = tr(e.serverSyncTree_, u, !o);
                    ei(e.eventQueue_, t, s), yi(e, i, n, r)
                }));
                const d = Ai(e, t);
                Ei(e, d), ei(e.eventQueue_, d, [])
            }

            function fi(e, t, n) {
                e.server_.onDisconnectCancel(t.toString(), ((r, i) => {
                    "ok" === r && Ot(e.onDisconnect_, t), yi(e, n, r, i)
                }))
            }

            function mi(e, t, n, r) {
                const i = lt(n);
                e.server_.onDisconnectPut(t.toString(), i.val(!0), ((n, o) => {
                    "ok" === n && Pt(e.onDisconnect_, t, i), yi(e, r, n, o)
                }))
            }

            function gi(e, t, n) {
                let r;
                r = ".info" === ve(t._path) ? rr(e.infoSyncTree_, t, n) : rr(e.serverSyncTree_, t, n), Zr(e.eventQueue_, t._path, r)
            }

            function _i(e) {
                e.persistentConnection_ && e.persistentConnection_.interrupt(ri)
            }

            function vi(e, ...t) {
                let n = "";
                e.persistentConnection_ && (n = e.persistentConnection_.id + ":"), w(n, ...t)
            }

            function yi(e, t, n, r) {
                t && H((() => {
                    if ("ok" === n) t(null);
                    else {
                        const e = (n || "error").toUpperCase();
                        let i = e;
                        r && (i += ": " + r);
                        const o = new Error(i);
                        o.code = e, t(o)
                    }
                }))
            }

            function bi(e, t, n) {
                return sr(e.serverSyncTree_, t, n) || at.EMPTY_NODE
            }

            function Ii(e, t = e.transactionQueueTree_) {
                if (t || Ti(e, t), Pr(t)) {
                    const n = wi(e, t);
                    s.assert(n.length > 0, "Sending zero length transaction queue");
                    n.every((e => 0 === e.status)) && function(e, t, n) {
                        const r = n.map((e => e.currentWriteId)),
                            i = bi(e, t, r);
                        let o = i;
                        const a = i.hash();
                        for (let e = 0; e < n.length; e++) {
                            const r = n[e];
                            s.assert(0 === r.status, "tryToSendTransactionQueue_: items in queue should all be run."), r.status = 1, r.retryCount++;
                            const i = Te(t, r.path);
                            o = o.updateChild(i, r.currentOutputSnapshotRaw)
                        }
                        const c = o.val(!0),
                            u = t;
                        e.server_.put(u.toString(), c, (r => {
                            vi(e, "transaction put response", {
                                path: u.toString(),
                                status: r
                            });
                            let i = [];
                            if ("ok" === r) {
                                const r = [];
                                for (let t = 0; t < n.length; t++) n[t].status = 2, i = i.concat(tr(e.serverSyncTree_, n[t].currentWriteId)), n[t].onComplete && r.push((() => n[t].onComplete(null, !0, n[t].currentOutputSnapshotResolved))), n[t].unwatcher();
                                Ti(e, Rr(e.transactionQueueTree_, t)), Ii(e, e.transactionQueueTree_), ei(e.eventQueue_, t, i);
                                for (let e = 0; e < r.length; e++) H(r[e])
                            } else {
                                if ("datastale" === r)
                                    for (let e = 0; e < n.length; e++) 3 === n[e].status ? n[e].status = 4 : n[e].status = 0;
                                else {
                                    R("transaction at " + u.toString() + " failed: " + r);
                                    for (let e = 0; e < n.length; e++) n[e].status = 4, n[e].abortReason = r
                                }
                                Ei(e, t)
                            }
                        }), a)
                    }(e, Mr(t), n)
                } else kr(t) && Nr(t, (t => {
                    Ii(e, t)
                }))
            }

            function Ei(e, t) {
                const n = Si(e, t),
                    r = Mr(n);
                return function(e, t, n) {
                    if (0 === t.length) return;
                    const r = [];
                    let i = [];
                    const o = t.filter((e => 0 === e.status)),
                        a = o.map((e => e.currentWriteId));
                    for (let o = 0; o < t.length; o++) {
                        const u = t[o],
                            l = Te(n, u.path);
                        let d, h = !1;
                        if (s.assert(null !== l, "rerunTransactionsUnderNode_: relativePath should not be null."), 4 === u.status) h = !0, d = u.abortReason, i = i.concat(tr(e.serverSyncTree_, u.currentWriteId, !0));
                        else if (0 === u.status)
                            if (u.retryCount >= ii) h = !0, d = "maxretry", i = i.concat(tr(e.serverSyncTree_, u.currentWriteId, !0));
                            else {
                                const n = bi(e, u.path, a);
                                u.currentInputSnapshot = n;
                                const r = t[o].update(n.val());
                                if (void 0 !== r) {
                                    Br("transaction failed: Data returned ", r, u.path);
                                    let t = lt(r);
                                    "object" == typeof r && null != r && s.contains(r, ".priority") || (t = t.updatePriority(n.getPriority()));
                                    const o = u.currentWriteId,
                                        c = ci(e),
                                        l = Cr(t, n, c);
                                    u.currentOutputSnapshotRaw = t, u.currentOutputSnapshotResolved = l, u.currentWriteId = hi(e), a.splice(a.indexOf(o), 1), i = i.concat(Zn(e.serverSyncTree_, u.path, l, u.currentWriteId, u.applyLocally)), i = i.concat(tr(e.serverSyncTree_, o, !0))
                                } else h = !0, d = "nodata", i = i.concat(tr(e.serverSyncTree_, u.currentWriteId, !0))
                            }
                        ei(e.eventQueue_, n, i), i = [], h && (t[o].status = 2, c = t[o].unwatcher, setTimeout(c, Math.floor(0)), t[o].onComplete && ("nodata" === d ? r.push((() => t[o].onComplete(null, !1, t[o].currentInputSnapshot))) : r.push((() => t[o].onComplete(new Error(d), !1, null)))))
                    }
                    var c;
                    Ti(e, e.transactionQueueTree_);
                    for (let e = 0; e < r.length; e++) H(r[e]);
                    Ii(e, e.transactionQueueTree_)
                }(e, wi(e, n), r), r
            }

            function Si(e, t) {
                let n, r = e.transactionQueueTree_;
                for (n = ve(t); null !== n && void 0 === Pr(r);) r = Rr(r, n), n = ve(t = be(t));
                return r
            }

            function wi(e, t) {
                const n = [];
                return Ci(e, t, n), n.sort(((e, t) => e.order - t.order)), n
            }

            function Ci(e, t, n) {
                const r = Pr(t);
                if (r)
                    for (let e = 0; e < r.length; e++) n.push(r[e]);
                Nr(t, (t => {
                    Ci(e, t, n)
                }))
            }

            function Ti(e, t) {
                const n = Pr(t);
                if (n) {
                    let e = 0;
                    for (let t = 0; t < n.length; t++) 2 !== n[t].status && (n[e] = n[t], e++);
                    n.length = e, Or(t, n.length > 0 ? n : void 0)
                }
                Nr(t, (t => {
                    Ti(e, t)
                }))
            }

            function Ai(e, t) {
                const n = Mr(Si(e, t)),
                    r = Rr(e.transactionQueueTree_, t);
                return function(e, t, n) {
                    let r = n ? e : e.parent;
                    for (; null !== r;) {
                        if (t(r)) return !0;
                        r = r.parent
                    }
                }(r, (t => {
                    Ri(e, t)
                })), Ri(e, r), Dr(r, (t => {
                    Ri(e, t)
                })), n
            }

            function Ri(e, t) {
                const n = Pr(t);
                if (n) {
                    const r = [];
                    let i = [],
                        o = -1;
                    for (let t = 0; t < n.length; t++) 3 === n[t].status || (1 === n[t].status ? (s.assert(o === t - 1, "All SENT items should be at beginning of queue."), o = t, n[t].status = 3, n[t].abortReason = "set") : (s.assert(0 === n[t].status, "Unexpected transaction status in abort"), n[t].unwatcher(), i = i.concat(tr(e.serverSyncTree_, n[t].currentWriteId, !0)), n[t].onComplete && r.push(n[t].onComplete.bind(null, new Error("set"), !1, null)))); - 1 === o ? Or(t, void 0) : n.length = o + 1, ei(e.eventQueue_, Mr(t), i);
                    for (let e = 0; e < r.length; e++) H(r[e])
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Pi = function(e, t) {
                    const n = Oi(e),
                        r = n.namespace;
                    "firebase.com" === n.domain && A(n.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead"), r && "undefined" !== r || "localhost" === n.domain || A("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com"), n.secure || "undefined" != typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf("https:") && R("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
                    const i = "ws" === n.scheme || "wss" === n.scheme;
                    return {
                        repoInfo: new Q(n.host, n.secure, r, i, t, "", r !== n.subdomain),
                        path: new ge(n.pathString)
                    }
                },
                Oi = function(e) {
                    let t = "",
                        n = "",
                        r = "",
                        i = "",
                        o = "",
                        s = !0,
                        a = "https",
                        c = 443;
                    if ("string" == typeof e) {
                        let u = e.indexOf("//");
                        u >= 0 && (a = e.substring(0, u - 1), e = e.substring(u + 2));
                        let l = e.indexOf("/"); - 1 === l && (l = e.length);
                        let d = e.indexOf("?"); - 1 === d && (d = e.length), t = e.substring(0, Math.min(l, d)), l < d && (i = function(e) {
                            let t = "";
                            const n = e.split("/");
                            for (let e = 0; e < n.length; e++)
                                if (n[e].length > 0) {
                                    let r = n[e];
                                    try {
                                        r = decodeURIComponent(r.replace(/\+/g, " "))
                                    } catch (e) {}
                                    t += "/" + r
                                }
                            return t
                        }(e.substring(l, d)));
                        const h = function(e) {
                            const t = {};
                            "?" === e.charAt(0) && (e = e.substring(1));
                            for (const n of e.split("&")) {
                                if (0 === n.length) continue;
                                const r = n.split("=");
                                2 === r.length ? t[decodeURIComponent(r[0])] = decodeURIComponent(r[1]) : R(`Invalid query segment '${n}' in query '${e}'`)
                            }
                            return t
                        }(e.substring(Math.min(e.length, d)));
                        u = t.indexOf(":"), u >= 0 ? (s = "https" === a || "wss" === a, c = parseInt(t.substring(u + 1), 10)) : u = t.length;
                        const p = t.slice(0, u);
                        if ("localhost" === p.toLowerCase()) n = "localhost";
                        else if (p.split(".").length <= 2) n = p;
                        else {
                            const e = t.indexOf(".");
                            r = t.substring(0, e).toLowerCase(), n = t.substring(e + 1), o = r
                        }
                        "ns" in h && (o = h.ns)
                    }
                    return {
                        host: t,
                        port: c,
                        domain: n,
                        subdomain: r,
                        secure: s,
                        scheme: a,
                        pathString: i,
                        namespace: o
                    }
                },
                ki = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz",
                Ni = function() {
                    let e = 0;
                    const t = [];
                    return function(n) {
                        const r = n === e;
                        let i;
                        e = n;
                        const o = new Array(8);
                        for (i = 7; i >= 0; i--) o[i] = ki.charAt(n % 64), n = Math.floor(n / 64);
                        s.assert(0 === n, "Cannot push at time == 0");
                        let a = o.join("");
                        if (r) {
                            for (i = 11; i >= 0 && 63 === t[i]; i--) t[i] = 0;
                            t[i]++
                        } else
                            for (i = 0; i < 12; i++) t[i] = Math.floor(64 * Math.random());
                        for (i = 0; i < 12; i++) a += ki.charAt(t[i]);
                        return s.assert(20 === a.length, "nextPushId: Length should be 20."), a
                    }
                }();
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Di {
                constructor(e, t, n, r) {
                    this.eventType = e, this.eventRegistration = t, this.snapshot = n, this.prevName = r
                }
                getPath() {
                    const e = this.snapshot.ref;
                    return "value" === this.eventType ? e._path : e.parent._path
                }
                getEventType() {
                    return this.eventType
                }
                getEventRunner() {
                    return this.eventRegistration.getEventRunner(this)
                }
                toString() {
                    return this.getPath().toString() + ":" + this.eventType + ":" + s.stringify(this.snapshot.exportVal())
                }
            }
            class Mi {
                constructor(e, t, n) {
                    this.eventRegistration = e, this.error = t, this.path = n
                }
                getPath() {
                    return this.path
                }
                getEventType() {
                    return "cancel"
                }
                getEventRunner() {
                    return this.eventRegistration.getEventRunner(this)
                }
                toString() {
                    return this.path.toString() + ":cancel"
                }
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class xi {
                constructor(e, t) {
                    this.snapshotCallback = e, this.cancelCallback = t
                }
                onValue(e, t) {
                    this.snapshotCallback.call(null, e, t)
                }
                onCancel(e) {
                    return s.assert(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback"), this.cancelCallback.call(null, e)
                }
                get hasCancelCallback() {
                    return !!this.cancelCallback
                }
                matches(e) {
                    return this.snapshotCallback === e.snapshotCallback || void 0 !== this.snapshotCallback.userCallback && this.snapshotCallback.userCallback === e.snapshotCallback.userCallback && this.snapshotCallback.context === e.snapshotCallback.context
                }
            }
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Li {
                constructor(e, t) {
                    this._repo = e, this._path = t
                }
                cancel() {
                    const e = new s.Deferred;
                    return fi(this._repo, this._path, e.wrapCallback((() => {}))), e.promise
                }
                remove() {
                    Yr("OnDisconnect.remove", this._path);
                    const e = new s.Deferred;
                    return mi(this._repo, this._path, null, e.wrapCallback((() => {}))), e.promise
                }
                set(e) {
                    Yr("OnDisconnect.set", this._path), Wr("OnDisconnect.set", e, this._path, !1);
                    const t = new s.Deferred;
                    return mi(this._repo, this._path, e, t.wrapCallback((() => {}))), t.promise
                }
                setWithPriority(e, t) {
                    Yr("OnDisconnect.setWithPriority", this._path), Wr("OnDisconnect.setWithPriority", e, this._path, !1), Gr("OnDisconnect.setWithPriority", t, !1);
                    const n = new s.Deferred;
                    return function(e, t, n, r, i) {
                        const o = lt(n, r);
                        e.server_.onDisconnectPut(t.toString(), o.val(!0), ((n, r) => {
                            "ok" === n && Pt(e.onDisconnect_, t, o), yi(0, i, n, r)
                        }))
                    }(this._repo, this._path, e, t, n.wrapCallback((() => {}))), n.promise
                }
                update(e) {
                    Yr("OnDisconnect.update", this._path), Vr("OnDisconnect.update", e, this._path, !1);
                    const t = new s.Deferred;
                    return function(e, t, n, r) {
                        if (s.isEmpty(n)) return w("onDisconnect().update() called with empty data.  Don't do anything."), void yi(0, r, "ok", void 0);
                        e.server_.onDisconnectMerge(t.toString(), n, ((i, o) => {
                            "ok" === i && U(n, ((n, r) => {
                                const i = lt(r);
                                Pt(e.onDisconnect_, we(t, n), i)
                            })), yi(0, r, i, o)
                        }))
                    }(this._repo, this._path, e, t.wrapCallback((() => {}))), t.promise
                }
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class Ui {
                constructor(e, t, n, r) {
                    this._repo = e, this._path = t, this._queryParams = n, this._orderByCalled = r
                }
                get key() {
                    return Ce(this._path) ? null : Ie(this._path)
                }
                get ref() {
                    return new Hi(this._repo, this._path)
                }
                get _queryIdentifier() {
                    const e = Ct(this._queryParams),
                        t = x(e);
                    return "{}" === t ? "default" : t
                }
                get _queryObject() {
                    return Ct(this._queryParams)
                }
                isEqual(e) {
                    if (!((e = s.getModularInstance(e)) instanceof Ui)) return !1;
                    const t = this._repo === e._repo,
                        n = Re(this._path, e._path),
                        r = this._queryIdentifier === e._queryIdentifier;
                    return t && n && r
                }
                toJSON() {
                    return this.toString()
                }
                toString() {
                    return this._repo.toString() + function(e) {
                        let t = "";
                        for (let n = e.pieceNum_; n < e.pieces_.length; n++) "" !== e.pieces_[n] && (t += "/" + encodeURIComponent(String(e.pieces_[n])));
                        return t || "/"
                    }(this._path)
                }
            }

            function Fi(e, t) {
                if (!0 === e._orderByCalled) throw new Error(t + ": You can't combine multiple orderBy calls.")
            }

            function ji(e) {
                let t = null,
                    n = null;
                if (e.hasStart() && (t = e.getIndexStartValue()), e.hasEnd() && (n = e.getIndexEndValue()), e.getIndex() === qe) {
                    const r = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().",
                        i = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.";
                    if (e.hasStart()) {
                        if (e.getIndexStartName() !== O) throw new Error(r);
                        if ("string" != typeof t) throw new Error(i)
                    }
                    if (e.hasEnd()) {
                        if (e.getIndexEndName() !== k) throw new Error(r);
                        if ("string" != typeof n) throw new Error(i)
                    }
                } else if (e.getIndex() === Ze) {
                    if (null != t && !Hr(t) || null != n && !Hr(n)) throw new Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).")
                } else if (s.assert(e.getIndex() instanceof dt || e.getIndex() === ht, "unknown index type."), null != t && "object" == typeof t || null != n && "object" == typeof n) throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.")
            }

            function qi(e) {
                if (e.hasStart() && e.hasEnd() && e.hasLimit() && !e.hasAnchoredLimit()) throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.")
            }
            class Hi extends Ui {
                constructor(e, t) {
                    super(e, t, new bt, !1)
                }
                get parent() {
                    const e = Se(this._path);
                    return null === e ? null : new Hi(this._repo, e)
                }
                get root() {
                    let e = this;
                    for (; null !== e.parent;) e = e.parent;
                    return e
                }
            }
            class Wi {
                constructor(e, t, n) {
                    this._node = e, this.ref = t, this._index = n
                }
                get priority() {
                    return this._node.getPriority().val()
                }
                get key() {
                    return this.ref.key
                }
                get size() {
                    return this._node.numChildren()
                }
                child(e) {
                    const t = new ge(e),
                        n = Vi(this.ref, e);
                    return new Wi(this._node.getChild(t), n, Ze)
                }
                exists() {
                    return !this._node.isEmpty()
                }
                exportVal() {
                    return this._node.val(!0)
                }
                forEach(e) {
                    if (this._node.isLeafNode()) return !1;
                    return !!this._node.forEachChild(this._index, ((t, n) => e(new Wi(n, Vi(this.ref, t), Ze))))
                }
                hasChild(e) {
                    const t = new ge(e);
                    return !this._node.getChild(t).isEmpty()
                }
                hasChildren() {
                    return !this._node.isLeafNode() && !this._node.isEmpty()
                }
                toJSON() {
                    return this.exportVal()
                }
                val() {
                    return this._node.val()
                }
            }

            function Bi(e, t) {
                return (e = s.getModularInstance(e))._checkNotDeleted("ref"), void 0 !== t ? Vi(e._root, t) : e._root
            }

            function Vi(e, t) {
                return null === ve((e = s.getModularInstance(e))._path) ? Kr("child", "path", t, !1) : $r("child", "path", t, !1), new Hi(e._repo, we(e._path, t))
            }

            function Gi(e, t) {
                e = s.getModularInstance(e), Yr("set", e._path), Wr("set", t, e._path, !1);
                const n = new s.Deferred;
                return pi(e._repo, e._path, t, null, n.wrapCallback((() => {}))), n.promise
            }
            class zi {
                constructor(e) {
                    this.callbackContext = e
                }
                respondsTo(e) {
                    return "value" === e
                }
                createEvent(e, t) {
                    const n = t._queryParams.getIndex();
                    return new Di("value", this, new Wi(e.snapshotNode, new Hi(t._repo, t._path), n))
                }
                getEventRunner(e) {
                    return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, null)
                }
                createCancelEvent(e, t) {
                    return this.callbackContext.hasCancelCallback ? new Mi(this, e, t) : null
                }
                matches(e) {
                    return e instanceof zi && (!e.callbackContext || !this.callbackContext || e.callbackContext.matches(this.callbackContext))
                }
                hasAnyCallback() {
                    return null !== this.callbackContext
                }
            }
            class $i {
                constructor(e, t) {
                    this.eventType = e, this.callbackContext = t
                }
                respondsTo(e) {
                    let t = "children_added" === e ? "child_added" : e;
                    return t = "children_removed" === t ? "child_removed" : t, this.eventType === t
                }
                createCancelEvent(e, t) {
                    return this.callbackContext.hasCancelCallback ? new Mi(this, e, t) : null
                }
                createEvent(e, t) {
                    s.assert(null != e.childName, "Child events should have a childName.");
                    const n = Vi(new Hi(t._repo, t._path), e.childName),
                        r = t._queryParams.getIndex();
                    return new Di(e.type, this, new Wi(e.snapshotNode, n, r), e.prevName)
                }
                getEventRunner(e) {
                    return "cancel" === e.getEventType() ? () => this.callbackContext.onCancel(e.error) : () => this.callbackContext.onValue(e.snapshot, e.prevName)
                }
                matches(e) {
                    return e instanceof $i && (this.eventType === e.eventType && (!this.callbackContext || !e.callbackContext || this.callbackContext.matches(e.callbackContext)))
                }
                hasAnyCallback() {
                    return !!this.callbackContext
                }
            }

            function Ki(e, t, n, r, i) {
                let o;
                if ("object" == typeof r && (o = void 0, i = r), "function" == typeof r && (o = r), i && i.onlyOnce) {
                    const t = n,
                        r = (n, r) => {
                            gi(e._repo, e, a), t(n, r)
                        };
                    r.userCallback = n.userCallback, r.context = n.context, n = r
                }
                const s = new xi(n, o || void 0),
                    a = "value" === t ? new zi(s) : new $i(t, s);
                return function(e, t, n) {
                    let r;
                    r = ".info" === ve(t._path) ? or(e.infoSyncTree_, t, n) : or(e.serverSyncTree_, t, n), Zr(e.eventQueue_, t._path, r)
                }(e._repo, e, a), () => gi(e._repo, e, a)
            }

            function Yi(e, t, n, r) {
                return Ki(e, "value", t, n, r)
            }
            class Ji {}
            class Qi extends Ji {
                constructor(e, t) {
                    super(), this._value = e, this._key = t
                }
                _apply(e) {
                    Wr("endAt", this._value, e._path, !0);
                    const t = Et(e._queryParams, this._value, this._key);
                    if (qi(t), ji(t), e._queryParams.hasEnd()) throw new Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo).");
                    return new Ui(e._repo, e._path, t, e._orderByCalled)
                }
            }
            class Xi extends Ji {
                constructor(e, t) {
                    super(), this._value = e, this._key = t
                }
                _apply(e) {
                    Wr("endBefore", this._value, e._path, !1);
                    const t = function(e, t, n) {
                        let r;
                        return r = e.index_ === qe || n ? Et(e, t, n) : Et(e, t, O), r.endBeforeSet_ = !0, r
                    }(e._queryParams, this._value, this._key);
                    if (qi(t), ji(t), e._queryParams.hasEnd()) throw new Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo).");
                    return new Ui(e._repo, e._path, t, e._orderByCalled)
                }
            }
            class Zi extends Ji {
                constructor(e, t) {
                    super(), this._value = e, this._key = t
                }
                _apply(e) {
                    Wr("startAt", this._value, e._path, !0);
                    const t = It(e._queryParams, this._value, this._key);
                    if (qi(t), ji(t), e._queryParams.hasStart()) throw new Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo).");
                    return new Ui(e._repo, e._path, t, e._orderByCalled)
                }
            }
            class eo extends Ji {
                constructor(e, t) {
                    super(), this._value = e, this._key = t
                }
                _apply(e) {
                    Wr("startAfter", this._value, e._path, !1);
                    const t = function(e, t, n) {
                        let r;
                        return r = e.index_ === qe || n ? It(e, t, n) : It(e, t, k), r.startAfterSet_ = !0, r
                    }(e._queryParams, this._value, this._key);
                    if (qi(t), ji(t), e._queryParams.hasStart()) throw new Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo).");
                    return new Ui(e._repo, e._path, t, e._orderByCalled)
                }
            }
            class to extends Ji {
                constructor(e) {
                    super(), this._limit = e
                }
                _apply(e) {
                    if (e._queryParams.hasLimit()) throw new Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast).");
                    return new Ui(e._repo, e._path, function(e, t) {
                        const n = e.copy();
                        return n.limitSet_ = !0, n.limit_ = t, n.viewFrom_ = "l", n
                    }(e._queryParams, this._limit), e._orderByCalled)
                }
            }
            class no extends Ji {
                constructor(e) {
                    super(), this._limit = e
                }
                _apply(e) {
                    if (e._queryParams.hasLimit()) throw new Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast).");
                    return new Ui(e._repo, e._path, function(e, t) {
                        const n = e.copy();
                        return n.limitSet_ = !0, n.limit_ = t, n.viewFrom_ = "r", n
                    }(e._queryParams, this._limit), e._orderByCalled)
                }
            }
            class ro extends Ji {
                constructor(e) {
                    super(), this._path = e
                }
                _apply(e) {
                    Fi(e, "orderByChild");
                    const t = new ge(this._path);
                    if (Ce(t)) throw new Error("orderByChild: cannot pass in empty path. Use orderByValue() instead.");
                    const n = new dt(t),
                        r = St(e._queryParams, n);
                    return ji(r), new Ui(e._repo, e._path, r, !0)
                }
            }
            class io extends Ji {
                _apply(e) {
                    Fi(e, "orderByKey");
                    const t = St(e._queryParams, qe);
                    return ji(t), new Ui(e._repo, e._path, t, !0)
                }
            }
            class oo extends Ji {
                _apply(e) {
                    Fi(e, "orderByPriority");
                    const t = St(e._queryParams, Ze);
                    return ji(t), new Ui(e._repo, e._path, t, !0)
                }
            }
            class so extends Ji {
                _apply(e) {
                    Fi(e, "orderByValue");
                    const t = St(e._queryParams, ht);
                    return ji(t), new Ui(e._repo, e._path, t, !0)
                }
            }
            class ao extends Ji {
                constructor(e, t) {
                    super(), this._value = e, this._key = t
                }
                _apply(e) {
                    if (Wr("equalTo", this._value, e._path, !1), e._queryParams.hasStart()) throw new Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).");
                    if (e._queryParams.hasEnd()) throw new Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).");
                    return new Qi(this._value, this._key)._apply(new Zi(this._value, this._key)._apply(e))
                }
            }! function(e) {
                s.assert(!Fn, "__referenceConstructor has already been defined"), Fn = e
            }(Hi),
            function(e) {
                s.assert(!jn, "__referenceConstructor has already been defined"), jn = e
            }(Hi);
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const co = "FIREBASE_DATABASE_EMULATOR_HOST",
                uo = {};
            let lo = !1;

            function ho(e, t, n, i, o) {
                let s = i || e.options.databaseURL;
                void 0 === s && (e.options.projectId || A("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."), w("Using default host for project ", e.options.projectId), s = `${e.options.projectId}-default-rtdb.firebaseio.com`);
                let a, c, u = Pi(s, o),
                    l = u.repoInfo;
                void 0 !== r && r.env && (c = r.env[co]), c ? (a = !0, s = `http://${c}?ns=${l.namespace}`, u = Pi(s, o), l = u.repoInfo) : a = !u.repoInfo.secure;
                const d = o && a ? new G(G.OWNER) : new V(e.name, e.options, t);
                Jr("Invalid Firebase Database URL", u), Ce(u.path) || A("Database URL must point to the root of a Firebase Database (not including a child path).");
                const h = function(e, t, n, r) {
                    let i = uo[t.name];
                    i || (i = {}, uo[t.name] = i);
                    let o = i[e.toURLString()];
                    o && A("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
                    return o = new oi(e, lo, n, r), i[e.toURLString()] = o, o
                }(l, e, d, new B(e.name, n));
                return new po(h, e)
            }
            class po {
                constructor(e, t) {
                    this._repoInternal = e, this.app = t, this.type = "database", this._instanceStarted = !1
                }
                get _repo() {
                    return this._instanceStarted || (si(this._repoInternal, this.app.options.appId, this.app.options.databaseAuthVariableOverride), this._instanceStarted = !0), this._repoInternal
                }
                get _root() {
                    return this._rootInternal || (this._rootInternal = new Hi(this._repo, _e())), this._rootInternal
                }
                _delete() {
                    return null !== this._rootInternal && (! function(e, t) {
                        const n = uo[t];
                        n && n[e.key] === e || A(`Database ${t}(${e.repoInfo_}) has already been deleted.`), _i(e), delete n[e.key]
                    }(this._repo, this.app.name), this._repoInternal = null, this._rootInternal = null), Promise.resolve()
                }
                _checkNotDeleted(e) {
                    null === this._rootInternal && A("Cannot call " + e + " on a deleted database.")
                }
            }

            function fo() {
                ue.IS_TRANSPORT_INITIALIZED && R("Transport has already been initialized. Please call this function before calling ref or setting up a listener")
            }

            function mo(e, t, n, r = {}) {
                (e = s.getModularInstance(e))._checkNotDeleted("useEmulator"), e._instanceStarted && A("Cannot call useEmulator() after instance has already been initialized.");
                const i = e._repoInternal;
                let o;
                if (i.repoInfo_.nodeAdmin) r.mockUserToken && A('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'), o = new G(G.OWNER);
                else if (r.mockUserToken) {
                    const t = "string" == typeof r.mockUserToken ? r.mockUserToken : s.createMockUserToken(r.mockUserToken, e.app.options.projectId);
                    o = new G(t)
                }! function(e, t, n, r) {
                    e.repoInfo_ = new Q(`${t}:${n}`, !1, e.repoInfo_.namespace, e.repoInfo_.webSocketOnly, e.repoInfo_.nodeAdmin, e.repoInfo_.persistenceKey, e.repoInfo_.includeNamespaceInQueryParams, !0), r && (e.authTokenProvider_ = r)
                }(i, t, n, o)
            }
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const go = {
                ".sv": "timestamp"
            };
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class _o {
                constructor(e, t) {
                    this.committed = e, this.snapshot = t
                }
                toJSON() {
                    return {
                        committed: this.committed,
                        snapshot: this.snapshot.toJSON()
                    }
                }
            }
            xe.prototype.simpleListen = function(e, t) {
                this.sendRequest("q", {
                    p: e
                }, t)
            }, xe.prototype.echo = function(e, t) {
                this.sendRequest("echo", {
                    d: e
                }, t)
            };
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var vo;
            d(i.SDK_VERSION), i._registerComponent(new o.Component("database", ((e, {
                    instanceIdentifier: t
                }) => ho(e.getProvider("app").getImmediate(), e.getProvider("auth-internal"), e.getProvider("app-check-internal"), t)), "PUBLIC").setMultipleInstances(!0)), i.registerVersion(c, u, vo), i.registerVersion(c, u, "cjs2017"), t.DataSnapshot = Wi, t.Database = po, t.OnDisconnect = Li, t.QueryConstraint = Ji, t.TransactionResult = _o, t._QueryImpl = Ui, t._QueryParams = bt, t._ReferenceImpl = Hi, t._TEST_ACCESS_forceRestClient = function(e) {
                    ! function(e) {
                        lo = e
                    }(e)
                }, t._TEST_ACCESS_hijackHash = function(e) {
                    const t = xe.prototype.put;
                    return xe.prototype.put = function(n, r, i, o) {
                            void 0 !== o && (o = e()), t.call(this, n, r, i, o)
                        },
                        function() {
                            xe.prototype.put = t
                        }
                }, t._repoManagerDatabaseFromApp = ho, t._setSDKVersion = d, t._validatePathString = $r, t._validateWritablePath = Yr, t.child = Vi, t.connectDatabaseEmulator = mo, t.enableLogging = function(e, t) {
                    S(e, t)
                }, t.endAt = function(e, t) {
                    return zr("endAt", "key", t, !0), new Qi(e, t)
                }, t.endBefore = function(e, t) {
                    return zr("endBefore", "key", t, !0), new Xi(e, t)
                }, t.equalTo = function(e, t) {
                    return zr("equalTo", "key", t, !0), new ao(e, t)
                }, t.forceLongPolling = function() {
                    fo(), ce.forceDisallow(), oe.forceAllow()
                }, t.forceWebSockets = function() {
                    fo(), oe.forceDisallow()
                }, t.get = function(e) {
                    e = s.getModularInstance(e);
                    const t = new xi((() => {})),
                        n = new zi(t);
                    return function(e, t, n) {
                        const r = ar(e.serverSyncTree_, t);
                        return null != r ? Promise.resolve(r) : e.server_.get(t).then((r => {
                            const i = lt(r).withIndex(t._queryParams.getIndex());
                            let o;
                            if (or(e.serverSyncTree_, t, n, !0), t._queryParams.loadsAllData()) o = nr(e.serverSyncTree_, t._path, i);
                            else {
                                const n = hr(e.serverSyncTree_, t);
                                o = ir(e.serverSyncTree_, t._path, i, n)
                            }
                            return ei(e.eventQueue_, t._path, o), rr(e.serverSyncTree_, t, n, null, !0), i
                        }), (n => (vi(e, "get for query " + s.stringify(t) + " failed: " + n), Promise.reject(new Error(n)))))
                    }(e._repo, e, n).then((t => new Wi(t, new Hi(e._repo, e._path), e._queryParams.getIndex())))
                }, t.getDatabase = function(e = i.getApp(), t) {
                    const n = i._getProvider(e, "database").getImmediate({
                        identifier: t
                    });
                    if (!n._instanceStarted) {
                        const e = s.getDefaultEmulatorHostnameAndPort("database");
                        e && mo(n, ...e)
                    }
                    return n
                }, t.goOffline = function(e) {
                    (e = s.getModularInstance(e))._checkNotDeleted("goOffline"), _i(e._repo)
                }, t.goOnline = function(e) {
                    var t;
                    (e = s.getModularInstance(e))._checkNotDeleted("goOnline"), (t = e._repo).persistentConnection_ && t.persistentConnection_.resume(ri)
                }, t.increment = function(e) {
                    return {
                        ".sv": {
                            increment: e
                        }
                    }
                }, t.limitToFirst = function(e) {
                    if ("number" != typeof e || Math.floor(e) !== e || e <= 0) throw new Error("limitToFirst: First argument must be a positive integer.");
                    return new to(e)
                }, t.limitToLast = function(e) {
                    if ("number" != typeof e || Math.floor(e) !== e || e <= 0) throw new Error("limitToLast: First argument must be a positive integer.");
                    return new no(e)
                }, t.off = function(e, t, n) {
                    let r = null;
                    const i = n ? new xi(n) : null;
                    "value" === t ? r = new zi(i) : t && (r = new $i(t, i)), gi(e._repo, e, r)
                }, t.onChildAdded = function(e, t, n, r) {
                    return Ki(e, "child_added", t, n, r)
                }, t.onChildChanged = function(e, t, n, r) {
                    return Ki(e, "child_changed", t, n, r)
                }, t.onChildMoved = function(e, t, n, r) {
                    return Ki(e, "child_moved", t, n, r)
                }, t.onChildRemoved = function(e, t, n, r) {
                    return Ki(e, "child_removed", t, n, r)
                }, t.onDisconnect = function(e) {
                    return e = s.getModularInstance(e), new Li(e._repo, e._path)
                }, t.onValue = Yi, t.orderByChild = function(e) {
                    if ("$key" === e) throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
                    if ("$priority" === e) throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
                    if ("$value" === e) throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
                    return $r("orderByChild", "path", e, !1), new ro(e)
                }, t.orderByKey = function() {
                    return new io
                }, t.orderByPriority = function() {
                    return new oo
                }, t.orderByValue = function() {
                    return new so
                }, t.push = function(e, t) {
                    e = s.getModularInstance(e), Yr("push", e._path), Wr("push", t, e._path, !0);
                    const n = ai(e._repo),
                        r = Ni(n),
                        i = Vi(e, r),
                        o = Vi(e, r);
                    let a;
                    return a = null != t ? Gi(o, t).then((() => o)) : Promise.resolve(o), i.then = a.then.bind(a), i.catch = a.then.bind(a, void 0), i
                }, t.query = function(e, ...t) {
                    let n = s.getModularInstance(e);
                    for (const e of t) n = e._apply(n);
                    return n
                }, t.ref = Bi, t.refFromURL = function(e, t) {
                    (e = s.getModularInstance(e))._checkNotDeleted("refFromURL");
                    const n = Pi(t, e._repo.repoInfo_.nodeAdmin);
                    Jr("refFromURL", n);
                    const r = n.repoInfo;
                    return e._repo.repoInfo_.isCustomHost() || r.host === e._repo.repoInfo_.host || A("refFromURL: Host name does not match the current database: (found " + r.host + " but expected " + e._repo.repoInfo_.host + ")"), Bi(e, n.path.toString())
                }, t.remove = function(e) {
                    return Yr("remove", e._path), Gi(e, null)
                }, t.runTransaction = function(e, t, n) {
                    var r;
                    if (e = s.getModularInstance(e), Yr("Reference.transaction", e._path), ".length" === e.key || ".keys" === e.key) throw "Reference.transaction failed: " + e.key + " is a read-only object.";
                    const i = null === (r = null == n ? void 0 : n.applyLocally) || void 0 === r || r,
                        o = new s.Deferred,
                        a = Yi(e, (() => {}));
                    return function(e, t, n, r, i, o) {
                        vi(e, "transaction on " + t);
                        const a = {
                                path: t,
                                update: n,
                                onComplete: r,
                                status: null,
                                order: v(),
                                applyLocally: o,
                                retryCount: 0,
                                unwatcher: i,
                                abortReason: null,
                                currentWriteId: null,
                                currentInputSnapshot: null,
                                currentOutputSnapshotRaw: null,
                                currentOutputSnapshotResolved: null
                            },
                            c = bi(e, t, void 0);
                        a.currentInputSnapshot = c;
                        const u = a.update(c.val());
                        if (void 0 === u) a.unwatcher(), a.currentOutputSnapshotRaw = null, a.currentOutputSnapshotResolved = null, a.onComplete && a.onComplete(null, !1, a.currentInputSnapshot);
                        else {
                            Br("transaction failed: Data returned ", u, a.path), a.status = 0;
                            const n = Rr(e.transactionQueueTree_, t),
                                r = Pr(n) || [];
                            let i;
                            r.push(a), Or(n, r), "object" == typeof u && null !== u && s.contains(u, ".priority") ? (i = s.safeGet(u, ".priority"), s.assert(Hr(i), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")) : i = (sr(e.serverSyncTree_, t) || at.EMPTY_NODE).getPriority().val();
                            const o = ci(e),
                                l = lt(u, i),
                                d = Cr(l, c, o);
                            a.currentOutputSnapshotRaw = l, a.currentOutputSnapshotResolved = d, a.currentWriteId = hi(e);
                            const h = Zn(e.serverSyncTree_, t, d, a.currentWriteId, a.applyLocally);
                            ei(e.eventQueue_, t, h), Ii(e, e.transactionQueueTree_)
                        }
                    }(e._repo, e._path, t, ((t, n, r) => {
                        let i = null;
                        t ? o.reject(t) : (i = new Wi(r, new Hi(e._repo, e._path), Ze), o.resolve(new _o(n, i)))
                    }), a, i), o.promise
                }
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                , t.serverTimestamp = function() {
                    return go
                }, t.set = Gi, t.setPriority = function(e, t) {
                    e = s.getModularInstance(e), Yr("setPriority", e._path), Gr("setPriority", t, !1);
                    const n = new s.Deferred;
                    return pi(e._repo, we(e._path, ".priority"), t, null, n.wrapCallback((() => {}))), n.promise
                }, t.setWithPriority = function(e, t, n) {
                    if (Yr("setWithPriority", e._path), Wr("setWithPriority", t, e._path, !1), Gr("setWithPriority", n, !1), ".length" === e.key || ".keys" === e.key) throw "setWithPriority failed: " + e.key + " is a read-only object.";
                    const r = new s.Deferred;
                    return pi(e._repo, e._path, t, n, r.wrapCallback((() => {}))), r.promise
                }, t.startAfter = function(e, t) {
                    return zr("startAfter", "key", t, !0), new eo(e, t)
                }, t.startAt = function(e = null, t) {
                    return zr("startAt", "key", t, !0), new Zi(e, t)
                }, t.update = function(e, t) {
                    Vr("update", t, e._path, !1);
                    const n = new s.Deferred;
                    return function(e, t, n, r) {
                        vi(e, "update", {
                            path: t.toString(),
                            value: n
                        });
                        let i = !0;
                        const o = ci(e),
                            s = {};
                        if (U(n, ((n, r) => {
                                i = !1, s[n] = wr(we(t, n), lt(r), e.serverSyncTree_, o)
                            })), i) w("update() called with empty data.  Don't do anything."), yi(0, r, "ok", void 0);
                        else {
                            const i = hi(e),
                                o = er(e.serverSyncTree_, t, s, i);
                            Xr(e.eventQueue_, o), e.server_.merge(t.toString(), n, ((n, o) => {
                                const s = "ok" === n;
                                s || R("update at " + t + " failed: " + n);
                                const a = tr(e.serverSyncTree_, i, !s),
                                    c = a.length > 0 ? Ei(e, t) : t;
                                ei(e.eventQueue_, c, a), yi(0, r, n, o)
                            })), U(n, (n => {
                                const r = Ai(e, we(t, n));
                                Ei(e, r)
                            })), ei(e.eventQueue_, t, [])
                        }
                    }(e._repo, e._path, t, n.wrapCallback((() => {}))), n.promise
                }
        },
        35129: function(e, t, n) {
            "use strict";
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            var r, i, o = n(92712),
                s = [];
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            t.LogLevel = void 0, (i = t.LogLevel || (t.LogLevel = {}))[i.DEBUG = 0] = "DEBUG", i[i.VERBOSE = 1] = "VERBOSE", i[i.INFO = 2] = "INFO", i[i.WARN = 3] = "WARN", i[i.ERROR = 4] = "ERROR", i[i.SILENT = 5] = "SILENT";
            var a = {
                    debug: t.LogLevel.DEBUG,
                    verbose: t.LogLevel.VERBOSE,
                    info: t.LogLevel.INFO,
                    warn: t.LogLevel.WARN,
                    error: t.LogLevel.ERROR,
                    silent: t.LogLevel.SILENT
                },
                c = t.LogLevel.INFO,
                u = ((r = {})[t.LogLevel.DEBUG] = "log", r[t.LogLevel.VERBOSE] = "log", r[t.LogLevel.INFO] = "info", r[t.LogLevel.WARN] = "warn", r[t.LogLevel.ERROR] = "error", r),
                l = function(e, t) {
                    for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
                    if (!(t < e.logLevel)) {
                        var i = (new Date).toISOString(),
                            s = u[t];
                        if (!s) throw new Error("Attempted to log a message with an invalid logType (value: ".concat(t, ")"));
                        console[s].apply(console, o.__spreadArray(["[".concat(i, "]  ").concat(e.name, ":")], n, !1))
                    }
                },
                d = function() {
                    function e(e) {
                        this.name = e, this._logLevel = c, this._logHandler = l, this._userLogHandler = null, s.push(this)
                    }
                    return Object.defineProperty(e.prototype, "logLevel", {
                        get: function() {
                            return this._logLevel
                        },
                        set: function(e) {
                            if (!(e in t.LogLevel)) throw new TypeError('Invalid value "'.concat(e, '" assigned to `logLevel`'));
                            this._logLevel = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.setLogLevel = function(e) {
                        this._logLevel = "string" == typeof e ? a[e] : e
                    }, Object.defineProperty(e.prototype, "logHandler", {
                        get: function() {
                            return this._logHandler
                        },
                        set: function(e) {
                            if ("function" != typeof e) throw new TypeError("Value assigned to `logHandler` must be a function");
                            this._logHandler = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "userLogHandler", {
                        get: function() {
                            return this._userLogHandler
                        },
                        set: function(e) {
                            this._userLogHandler = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.debug = function() {
                        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                        this._userLogHandler && this._userLogHandler.apply(this, o.__spreadArray([this, t.LogLevel.DEBUG], e, !1)), this._logHandler.apply(this, o.__spreadArray([this, t.LogLevel.DEBUG], e, !1))
                    }, e.prototype.log = function() {
                        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                        this._userLogHandler && this._userLogHandler.apply(this, o.__spreadArray([this, t.LogLevel.VERBOSE], e, !1)), this._logHandler.apply(this, o.__spreadArray([this, t.LogLevel.VERBOSE], e, !1))
                    }, e.prototype.info = function() {
                        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                        this._userLogHandler && this._userLogHandler.apply(this, o.__spreadArray([this, t.LogLevel.INFO], e, !1)), this._logHandler.apply(this, o.__spreadArray([this, t.LogLevel.INFO], e, !1))
                    }, e.prototype.warn = function() {
                        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                        this._userLogHandler && this._userLogHandler.apply(this, o.__spreadArray([this, t.LogLevel.WARN], e, !1)), this._logHandler.apply(this, o.__spreadArray([this, t.LogLevel.WARN], e, !1))
                    }, e.prototype.error = function() {
                        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
                        this._userLogHandler && this._userLogHandler.apply(this, o.__spreadArray([this, t.LogLevel.ERROR], e, !1)), this._logHandler.apply(this, o.__spreadArray([this, t.LogLevel.ERROR], e, !1))
                    }, e
                }();
            t.Logger = d, t.setLogLevel = function(e) {
                s.forEach((function(t) {
                    t.setLogLevel(e)
                }))
            }, t.setUserLogHandler = function(e, n) {
                for (var r = function(r) {
                        var i = null;
                        n && n.level && (i = a[n.level]), r.userLogHandler = null === e ? null : function(n, r) {
                            for (var o = [], s = 2; s < arguments.length; s++) o[s - 2] = arguments[s];
                            var a = o.map((function(e) {
                                if (null == e) return null;
                                if ("string" == typeof e) return e;
                                if ("number" == typeof e || "boolean" == typeof e) return e.toString();
                                if (e instanceof Error) return e.message;
                                try {
                                    return JSON.stringify(e)
                                } catch (e) {
                                    return null
                                }
                            })).filter((function(e) {
                                return e
                            })).join(" ");
                            r >= (null != i ? i : n.logLevel) && e({
                                level: t.LogLevel[r].toLowerCase(),
                                message: a,
                                args: o,
                                type: n.name
                            })
                        }
                    }, i = 0, o = s; i < o.length; i++) {
                    r(o[i])
                }
            }
        },
        6789: function(e, t, n) {
            "use strict";
            var r = n(13158);
            Object.defineProperty(t, "__esModule", {
                value: !0
            });
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const i = {
                    NODE_CLIENT: !1,
                    NODE_ADMIN: !1,
                    SDK_VERSION: "${JSCORE_VERSION}"
                },
                o = function(e, t) {
                    if (!e) throw s(t)
                },
                s = function(e) {
                    return new Error("Firebase Database (" + i.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + e)
                },
                a = function(e) {
                    const t = [];
                    let n = 0;
                    for (let r = 0; r < e.length; r++) {
                        let i = e.charCodeAt(r);
                        i < 128 ? t[n++] = i : i < 2048 ? (t[n++] = i >> 6 | 192, t[n++] = 63 & i | 128) : 55296 == (64512 & i) && r + 1 < e.length && 56320 == (64512 & e.charCodeAt(r + 1)) ? (i = 65536 + ((1023 & i) << 10) + (1023 & e.charCodeAt(++r)), t[n++] = i >> 18 | 240, t[n++] = i >> 12 & 63 | 128, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128) : (t[n++] = i >> 12 | 224, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128)
                    }
                    return t
                },
                c = {
                    byteToCharMap_: null,
                    charToByteMap_: null,
                    byteToCharMapWebSafe_: null,
                    charToByteMapWebSafe_: null,
                    ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                    get ENCODED_VALS() {
                        return this.ENCODED_VALS_BASE + "+/="
                    },
                    get ENCODED_VALS_WEBSAFE() {
                        return this.ENCODED_VALS_BASE + "-_."
                    },
                    HAS_NATIVE_SUPPORT: "function" == typeof atob,
                    encodeByteArray(e, t) {
                        if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter");
                        this.init_();
                        const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
                            r = [];
                        for (let t = 0; t < e.length; t += 3) {
                            const i = e[t],
                                o = t + 1 < e.length,
                                s = o ? e[t + 1] : 0,
                                a = t + 2 < e.length,
                                c = a ? e[t + 2] : 0,
                                u = i >> 2,
                                l = (3 & i) << 4 | s >> 4;
                            let d = (15 & s) << 2 | c >> 6,
                                h = 63 & c;
                            a || (h = 64, o || (d = 64)), r.push(n[u], n[l], n[d], n[h])
                        }
                        return r.join("")
                    },
                    encodeString(e, t) {
                        return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(a(e), t)
                    },
                    decodeString(e, t) {
                        return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function(e) {
                            const t = [];
                            let n = 0,
                                r = 0;
                            for (; n < e.length;) {
                                const i = e[n++];
                                if (i < 128) t[r++] = String.fromCharCode(i);
                                else if (i > 191 && i < 224) {
                                    const o = e[n++];
                                    t[r++] = String.fromCharCode((31 & i) << 6 | 63 & o)
                                } else if (i > 239 && i < 365) {
                                    const o = ((7 & i) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536;
                                    t[r++] = String.fromCharCode(55296 + (o >> 10)), t[r++] = String.fromCharCode(56320 + (1023 & o))
                                } else {
                                    const o = e[n++],
                                        s = e[n++];
                                    t[r++] = String.fromCharCode((15 & i) << 12 | (63 & o) << 6 | 63 & s)
                                }
                            }
                            return t.join("")
                        }(this.decodeStringToByteArray(e, t))
                    },
                    decodeStringToByteArray(e, t) {
                        this.init_();
                        const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_,
                            r = [];
                        for (let t = 0; t < e.length;) {
                            const i = n[e.charAt(t++)],
                                o = t < e.length ? n[e.charAt(t)] : 0;
                            ++t;
                            const s = t < e.length ? n[e.charAt(t)] : 64;
                            ++t;
                            const a = t < e.length ? n[e.charAt(t)] : 64;
                            if (++t, null == i || null == o || null == s || null == a) throw new u;
                            const c = i << 2 | o >> 4;
                            if (r.push(c), 64 !== s) {
                                const e = o << 4 & 240 | s >> 2;
                                if (r.push(e), 64 !== a) {
                                    const e = s << 6 & 192 | a;
                                    r.push(e)
                                }
                            }
                        }
                        return r
                    },
                    init_() {
                        if (!this.byteToCharMap_) {
                            this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
                            for (let e = 0; e < this.ENCODED_VALS.length; e++) this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e)
                        }
                    }
                };
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class u extends Error {
                constructor() {
                    super(...arguments), this.name = "DecodeBase64StringError"
                }
            }
            const l = function(e) {
                    const t = a(e);
                    return c.encodeByteArray(t, !0)
                },
                d = function(e) {
                    return l(e).replace(/\./g, "")
                },
                h = function(e) {
                    try {
                        return c.decodeString(e, !0)
                    } catch (e) {
                        console.error("base64Decode failed: ", e)
                    }
                    return null
                };

            function p(e, t) {
                if (!(t instanceof Object)) return t;
                switch (t.constructor) {
                    case Date:
                        return new Date(t.getTime());
                    case Object:
                        void 0 === e && (e = {});
                        break;
                    case Array:
                        e = [];
                        break;
                    default:
                        return t
                }
                for (const n in t) t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = p(e[n], t[n]));
                return e
            }
            /**
             * @license
             * Copyright 2022 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function f() {
                if ("undefined" != typeof self) return self;
                if ("undefined" != typeof window) return window;
                if (void 0 !== n.g) return n.g;
                throw new Error("Unable to locate global object.")
            }
            /**
             * @license
             * Copyright 2022 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const m = () => {
                    try {
                        return f().__FIREBASE_DEFAULTS__ || (() => {
                            if (void 0 === r || void 0 === r.env) return;
                            const e = r.env.__FIREBASE_DEFAULTS__;
                            return e ? JSON.parse(e) : void 0
                        })() || (() => {
                            if ("undefined" == typeof document) return;
                            let e;
                            try {
                                e = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
                            } catch (e) {
                                return
                            }
                            const t = e && h(e[1]);
                            return t && JSON.parse(t)
                        })()
                    } catch (e) {
                        return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`)
                    }
                },
                g = e => {
                    var t, n;
                    return null === (n = null === (t = m()) || void 0 === t ? void 0 : t.emulatorHosts) || void 0 === n ? void 0 : n[e]
                };
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class _ {
                constructor() {
                    this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise(((e, t) => {
                        this.resolve = e, this.reject = t
                    }))
                }
                wrapCallback(e) {
                    return (t, n) => {
                        t ? this.reject(t) : this.resolve(n), "function" == typeof e && (this.promise.catch((() => {})), 1 === e.length ? e(t) : e(t, n))
                    }
                }
            }
            /**
             * @license
             * Copyright 2021 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function v() {
                return "undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : ""
            }

            function y() {
                var e;
                const t = null === (e = m()) || void 0 === e ? void 0 : e.forceEnvironment;
                if ("node" === t) return !0;
                if ("browser" === t) return !1;
                try {
                    return "[object process]" === Object.prototype.toString.call(n.g.process)
                } catch (e) {
                    return !1
                }
            }
            class b extends Error {
                constructor(e, t, n) {
                    super(t), this.code = e, this.customData = n, this.name = "FirebaseError", Object.setPrototypeOf(this, b.prototype), Error.captureStackTrace && Error.captureStackTrace(this, I.prototype.create)
                }
            }
            class I {
                constructor(e, t, n) {
                    this.service = e, this.serviceName = t, this.errors = n
                }
                create(e, ...t) {
                    const n = t[0] || {},
                        r = `${this.service}/${e}`,
                        i = this.errors[e],
                        o = i ? function(e, t) {
                            return e.replace(E, ((e, n) => {
                                const r = t[n];
                                return null != r ? String(r) : `<${n}?>`
                            }))
                        }(i, n) : "Error",
                        s = `${this.serviceName}: ${o} (${r}).`;
                    return new b(r, s, n)
                }
            }
            const E = /\{\$([^}]+)}/g;
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function S(e) {
                return JSON.parse(e)
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const w = function(e) {
                let t = {},
                    n = {},
                    r = {},
                    i = "";
                try {
                    const o = e.split(".");
                    t = S(h(o[0]) || ""), n = S(h(o[1]) || ""), i = o[2], r = n.d || {}, delete n.d
                } catch (e) {}
                return {
                    header: t,
                    claims: n,
                    data: r,
                    signature: i
                }
            };

            function C(e) {
                return null !== e && "object" == typeof e
            }
            /**
             * @license
             * Copyright 2022 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            class T {
                constructor(e, t) {
                    this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = t, this.task.then((() => {
                        e(this)
                    })).catch((e => {
                        this.error(e)
                    }))
                }
                next(e) {
                    this.forEachObserver((t => {
                        t.next(e)
                    }))
                }
                error(e) {
                    this.forEachObserver((t => {
                        t.error(e)
                    })), this.close(e)
                }
                complete() {
                    this.forEachObserver((e => {
                        e.complete()
                    })), this.close()
                }
                subscribe(e, t, n) {
                    let r;
                    if (void 0 === e && void 0 === t && void 0 === n) throw new Error("Missing Observer.");
                    r = function(e, t) {
                        if ("object" != typeof e || null === e) return !1;
                        for (const n of t)
                            if (n in e && "function" == typeof e[n]) return !0;
                        return !1
                    }(e, ["next", "error", "complete"]) ? e : {
                        next: e,
                        error: t,
                        complete: n
                    }, void 0 === r.next && (r.next = A), void 0 === r.error && (r.error = A), void 0 === r.complete && (r.complete = A);
                    const i = this.unsubscribeOne.bind(this, this.observers.length);
                    return this.finalized && this.task.then((() => {
                        try {
                            this.finalError ? r.error(this.finalError) : r.complete()
                        } catch (e) {}
                    })), this.observers.push(r), i
                }
                unsubscribeOne(e) {
                    void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this))
                }
                forEachObserver(e) {
                    if (!this.finalized)
                        for (let t = 0; t < this.observers.length; t++) this.sendOne(t, e)
                }
                sendOne(e, t) {
                    this.task.then((() => {
                        if (void 0 !== this.observers && void 0 !== this.observers[e]) try {
                            t(this.observers[e])
                        } catch (e) {
                            "undefined" != typeof console && console.error && console.error(e)
                        }
                    }))
                }
                close(e) {
                    this.finalized || (this.finalized = !0, void 0 !== e && (this.finalError = e), this.task.then((() => {
                        this.observers = void 0, this.onNoObservers = void 0
                    })))
                }
            }

            function A() {}
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            function R(e, t) {
                return `${e} failed: ${t} argument `
            }
            /**
             * @license
             * Copyright 2017 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const P = 144e5;
            t.CONSTANTS = i, t.DecodeBase64StringError = u, t.Deferred = _, t.ErrorFactory = I, t.FirebaseError = b, t.MAX_VALUE_MILLIS = P, t.RANDOM_FACTOR = .5, t.Sha1 =
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                class {
                    constructor() {
                        this.chain_ = [], this.buf_ = [], this.W_ = [], this.pad_ = [], this.inbuf_ = 0, this.total_ = 0, this.blockSize = 64, this.pad_[0] = 128;
                        for (let e = 1; e < this.blockSize; ++e) this.pad_[e] = 0;
                        this.reset()
                    }
                    reset() {
                        this.chain_[0] = 1732584193, this.chain_[1] = 4023233417, this.chain_[2] = 2562383102, this.chain_[3] = 271733878, this.chain_[4] = 3285377520, this.inbuf_ = 0, this.total_ = 0
                    }
                    compress_(e, t) {
                        t || (t = 0);
                        const n = this.W_;
                        if ("string" == typeof e)
                            for (let r = 0; r < 16; r++) n[r] = e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | e.charCodeAt(t + 3), t += 4;
                        else
                            for (let r = 0; r < 16; r++) n[r] = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3], t += 4;
                        for (let e = 16; e < 80; e++) {
                            const t = n[e - 3] ^ n[e - 8] ^ n[e - 14] ^ n[e - 16];
                            n[e] = 4294967295 & (t << 1 | t >>> 31)
                        }
                        let r, i, o = this.chain_[0],
                            s = this.chain_[1],
                            a = this.chain_[2],
                            c = this.chain_[3],
                            u = this.chain_[4];
                        for (let e = 0; e < 80; e++) {
                            e < 40 ? e < 20 ? (r = c ^ s & (a ^ c), i = 1518500249) : (r = s ^ a ^ c, i = 1859775393) : e < 60 ? (r = s & a | c & (s | a), i = 2400959708) : (r = s ^ a ^ c, i = 3395469782);
                            const t = (o << 5 | o >>> 27) + r + u + i + n[e] & 4294967295;
                            u = c, c = a, a = 4294967295 & (s << 30 | s >>> 2), s = o, o = t
                        }
                        this.chain_[0] = this.chain_[0] + o & 4294967295, this.chain_[1] = this.chain_[1] + s & 4294967295, this.chain_[2] = this.chain_[2] + a & 4294967295, this.chain_[3] = this.chain_[3] + c & 4294967295, this.chain_[4] = this.chain_[4] + u & 4294967295
                    }
                    update(e, t) {
                        if (null == e) return;
                        void 0 === t && (t = e.length);
                        const n = t - this.blockSize;
                        let r = 0;
                        const i = this.buf_;
                        let o = this.inbuf_;
                        for (; r < t;) {
                            if (0 === o)
                                for (; r <= n;) this.compress_(e, r), r += this.blockSize;
                            if ("string" == typeof e) {
                                for (; r < t;)
                                    if (i[o] = e.charCodeAt(r), ++o, ++r, o === this.blockSize) {
                                        this.compress_(i), o = 0;
                                        break
                                    }
                            } else
                                for (; r < t;)
                                    if (i[o] = e[r], ++o, ++r, o === this.blockSize) {
                                        this.compress_(i), o = 0;
                                        break
                                    }
                        }
                        this.inbuf_ = o, this.total_ += t
                    }
                    digest() {
                        const e = [];
                        let t = 8 * this.total_;
                        this.inbuf_ < 56 ? this.update(this.pad_, 56 - this.inbuf_) : this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
                        for (let e = this.blockSize - 1; e >= 56; e--) this.buf_[e] = 255 & t, t /= 256;
                        this.compress_(this.buf_);
                        let n = 0;
                        for (let t = 0; t < 5; t++)
                            for (let r = 24; r >= 0; r -= 8) e[n] = this.chain_[t] >> r & 255, ++n;
                        return e
                    }
                }, t.areCookiesEnabled = function() {
                    return !("undefined" == typeof navigator || !navigator.cookieEnabled)
                }
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                , t.assert = o, t.assertionError = s, t.async = function(e, t) {
                    return (...n) => {
                        Promise.resolve(!0).then((() => {
                            e(...n)
                        })).catch((e => {
                            t && t(e)
                        }))
                    }
                }, t.base64 = c, t.base64Decode = h, t.base64Encode = l, t.base64urlEncodeWithoutPadding = d, t.calculateBackoffMillis = function(e, t = 1e3, n = 2) {
                    const r = t * Math.pow(n, e),
                        i = Math.round(.5 * r * (Math.random() - .5) * 2);
                    return Math.min(P, r + i)
                }
                /**
                 * @license
                 * Copyright 2020 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                , t.contains =
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                function(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t)
                }, t.createMockUserToken = function(e, t) {
                    if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
                    const n = t || "demo-project",
                        r = e.iat || 0,
                        i = e.sub || e.user_id;
                    if (!i) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
                    const o = Object.assign({
                        iss: `https://securetoken.google.com/${n}`,
                        aud: n,
                        iat: r,
                        exp: r + 3600,
                        auth_time: r,
                        sub: i,
                        user_id: i,
                        firebase: {
                            sign_in_provider: "custom",
                            identities: {}
                        }
                    }, e);
                    return [d(JSON.stringify({
                        alg: "none",
                        type: "JWT"
                    })), d(JSON.stringify(o)), ""].join(".")
                }, t.createSubscribe = function(e, t) {
                    const n = new T(e, t);
                    return n.subscribe.bind(n)
                }, t.decode = w, t.deepCopy =
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                function(e) {
                    return p(void 0, e)
                }, t.deepEqual = function e(t, n) {
                    if (t === n) return !0;
                    const r = Object.keys(t),
                        i = Object.keys(n);
                    for (const o of r) {
                        if (!i.includes(o)) return !1;
                        const r = t[o],
                            s = n[o];
                        if (C(r) && C(s)) {
                            if (!e(r, s)) return !1
                        } else if (r !== s) return !1
                    }
                    for (const e of i)
                        if (!r.includes(e)) return !1;
                    return !0
                }, t.deepExtend = p, t.errorPrefix = R, t.extractQuerystring = function(e) {
                    const t = e.indexOf("?");
                    if (!t) return "";
                    const n = e.indexOf("#", t);
                    return e.substring(t, n > 0 ? n : void 0)
                }, t.getDefaultAppConfig = () => {
                    var e;
                    return null === (e = m()) || void 0 === e ? void 0 : e.config
                }, t.getDefaultEmulatorHost = g, t.getDefaultEmulatorHostnameAndPort = e => {
                    const t = g(e);
                    if (!t) return;
                    const n = t.lastIndexOf(":");
                    if (n <= 0 || n + 1 === t.length) throw new Error(`Invalid host ${t} with no separate hostname and port!`);
                    const r = parseInt(t.substring(n + 1), 10);
                    return "[" === t[0] ? [t.substring(1, n - 1), r] : [t.substring(0, n), r]
                }, t.getDefaults = m, t.getExperimentalSetting = e => {
                    var t;
                    return null === (t = m()) || void 0 === t ? void 0 : t[`_${e}`]
                }, t.getGlobal = f, t.getModularInstance =
                /**
                 * @license
                 * Copyright 2021 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                function(e) {
                    return e && e._delegate ? e._delegate : e
                }, t.getUA = v, t.isAdmin = function(e) {
                    const t = w(e).claims;
                    return "object" == typeof t && !0 === t.admin
                }, t.isBrowser = function() {
                    return "object" == typeof self && self.self === self
                }, t.isBrowserExtension = function() {
                    const e = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0;
                    return "object" == typeof e && void 0 !== e.id
                }, t.isElectron = function() {
                    return v().indexOf("Electron/") >= 0
                }, t.isEmpty = function(e) {
                    for (const t in e)
                        if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
                    return !0
                }, t.isIE = function() {
                    const e = v();
                    return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0
                }, t.isIndexedDBAvailable = function() {
                    try {
                        return "object" == typeof indexedDB
                    } catch (e) {
                        return !1
                    }
                }, t.isMobileCordova = function() {
                    return "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(v())
                }, t.isNode = y, t.isNodeSdk = function() {
                    return !0 === i.NODE_CLIENT || !0 === i.NODE_ADMIN
                }, t.isReactNative = function() {
                    return "object" == typeof navigator && "ReactNative" === navigator.product
                }, t.isSafari = function() {
                    return !y() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
                }, t.isUWP = function() {
                    return v().indexOf("MSAppHost/") >= 0
                }, t.isValidFormat = function(e) {
                    const t = w(e).claims;
                    return !!t && "object" == typeof t && t.hasOwnProperty("iat")
                }, t.isValidTimestamp = function(e) {
                    const t = w(e).claims,
                        n = Math.floor((new Date).getTime() / 1e3);
                    let r = 0,
                        i = 0;
                    return "object" == typeof t && (t.hasOwnProperty("nbf") ? r = t.nbf : t.hasOwnProperty("iat") && (r = t.iat), i = t.hasOwnProperty("exp") ? t.exp : r + 86400), !!n && !!r && !!i && n >= r && n <= i
                }, t.issuedAtTime = function(e) {
                    const t = w(e).claims;
                    return "object" == typeof t && t.hasOwnProperty("iat") ? t.iat : null
                }, t.jsonEval = S, t.map = function(e, t, n) {
                    const r = {};
                    for (const i in e) Object.prototype.hasOwnProperty.call(e, i) && (r[i] = t.call(n, e[i], i, e));
                    return r
                }, t.ordinal = function(e) {
                    return Number.isFinite(e) ? e + function(e) {
                        e = Math.abs(e);
                        const t = e % 100;
                        if (t >= 10 && t <= 20) return "th";
                        const n = e % 10;
                        if (1 === n) return "st";
                        if (2 === n) return "nd";
                        if (3 === n) return "rd";
                        return "th"
                    }(e) : `${e}`
                }, t.promiseWithTimeout = function(e, t = 2e3) {
                    const n = new _;
                    return setTimeout((() => n.reject("timeout!")), t), e.then(n.resolve, n.reject), n.promise
                }
                /**
                 * @license
                 * Copyright 2017 Google LLC
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *   http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                , t.querystring = function(e) {
                    const t = [];
                    for (const [n, r] of Object.entries(e)) Array.isArray(r) ? r.forEach((e => {
                        t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e))
                    })) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(r));
                    return t.length ? "&" + t.join("&") : ""
                }, t.querystringDecode = function(e) {
                    const t = {};
                    return e.replace(/^\?/, "").split("&").forEach((e => {
                        if (e) {
                            const [n, r] = e.split("=");
                            t[decodeURIComponent(n)] = decodeURIComponent(r)
                        }
                    })), t
                }, t.safeGet = function(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0
                }, t.stringLength = function(e) {
                    let t = 0;
                    for (let n = 0; n < e.length; n++) {
                        const r = e.charCodeAt(n);
                        r < 128 ? t++ : r < 2048 ? t += 2 : r >= 55296 && r <= 56319 ? (t += 4, n++) : t += 3
                    }
                    return t
                }, t.stringToByteArray = function(e) {
                    const t = [];
                    let n = 0;
                    for (let r = 0; r < e.length; r++) {
                        let i = e.charCodeAt(r);
                        if (i >= 55296 && i <= 56319) {
                            const t = i - 55296;
                            r++, o(r < e.length, "Surrogate pair missing trail surrogate.");
                            i = 65536 + (t << 10) + (e.charCodeAt(r) - 56320)
                        }
                        i < 128 ? t[n++] = i : i < 2048 ? (t[n++] = i >> 6 | 192, t[n++] = 63 & i | 128) : i < 65536 ? (t[n++] = i >> 12 | 224, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128) : (t[n++] = i >> 18 | 240, t[n++] = i >> 12 & 63 | 128, t[n++] = i >> 6 & 63 | 128, t[n++] = 63 & i | 128)
                    }
                    return t
                }, t.stringify = function(e) {
                    return JSON.stringify(e)
                }, t.uuidv4 = function() {
                    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e => {
                        const t = 16 * Math.random() | 0;
                        return ("x" === e ? t : 3 & t | 8).toString(16)
                    }))
                }, t.validateArgCount = function(e, t, n, r) {
                    let i;
                    if (r < t ? i = "at least " + t : r > n && (i = 0 === n ? "none" : "no more than " + n), i) {
                        throw new Error(e + " failed: Was called with " + r + (1 === r ? " argument." : " arguments.") + " Expects " + i + ".")
                    }
                }, t.validateCallback = function(e, t, n, r) {
                    if ((!r || n) && "function" != typeof n) throw new Error(R(e, t) + "must be a valid function.")
                }, t.validateContextObject = function(e, t, n, r) {
                    if ((!r || n) && ("object" != typeof n || null === n)) throw new Error(R(e, t) + "must be a valid context object.")
                }, t.validateIndexedDBOpenable = function() {
                    return new Promise(((e, t) => {
                        try {
                            let n = !0;
                            const r = "validate-browser-context-for-indexeddb-analytics-module",
                                i = self.indexedDB.open(r);
                            i.onsuccess = () => {
                                i.result.close(), n || self.indexedDB.deleteDatabase(r), e(!0)
                            }, i.onupgradeneeded = () => {
                                n = !1
                            }, i.onerror = () => {
                                var e;
                                t((null === (e = i.error) || void 0 === e ? void 0 : e.message) || "")
                            }
                        } catch (e) {
                            t(e)
                        }
                    }))
                }, t.validateNamespace = function(e, t, n) {
                    if ((!n || t) && "string" != typeof t) throw new Error(R(e, "namespace") + "must be a valid firebase namespace.")
                }
        },
        26339: function(e) {
            for (var t = [], n = 0; n < 256; ++n) t[n] = (n + 256).toString(16).substr(1);
            e.exports = function(e, n) {
                var r = n || 0,
                    i = t;
                return [i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]]].join("")
            }
        },
        54848: function(e) {
            var t = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
            if (t) {
                var n = new Uint8Array(16);
                e.exports = function() {
                    return t(n), n
                }
            } else {
                var r = new Array(16);
                e.exports = function() {
                    for (var e, t = 0; t < 16; t++) 0 == (3 & t) && (e = 4294967296 * Math.random()), r[t] = e >>> ((3 & t) << 3) & 255;
                    return r
                }
            }
        },
        38578: function(e, t, n) {
            var r = n(54848),
                i = n(26339);
            e.exports = function(e, t, n) {
                var o = t && n || 0;
                "string" == typeof e && (t = "binary" === e ? new Array(16) : null, e = null);
                var s = (e = e || {}).random || (e.rng || r)();
                if (s[6] = 15 & s[6] | 64, s[8] = 63 & s[8] | 128, t)
                    for (var a = 0; a < 16; ++a) t[o + a] = s[a];
                return t || i(s)
            }
        },
        18053: function(e, t, n) {
            let r, i;

            function o(e) {
                const t = (e || "").split("/");
                return t[t.length - 1]
            }
            e.exports = class {
                atomicServerTime = !1;
                constructor(e, {
                    atomicServerTime: t = !1
                } = {}) {
                    i = n(38578), e = e || i(), n(30507), n(36691), r = (() => {
                        const e = n(56345);
                        return e.default ? e.default : e
                    })(), this.name = e, this.listeningOnRefs = [], this.db = null, this.terminated = !1, this._initializationInProgress = Promise.resolve(), this.atomicServerTime = t
                }
                async connect(e, t) {
                    return this._assertInstanceAlive(), await this._initializationInProgress, this._initializationInProgress = new Promise((e => this._initializationCompleted = e)), Promise.resolve().then((() => this.db ? (this._initializationCompleted(), this.db.goOnline()) : Promise.resolve().then((() => r.initializeApp(e, this.name))).then((e => e.auth().signInWithCustomToken(t).then((() => {
                        if (this._initializationCompleted(), this.terminated) return e.delete();
                        this.db = e.database()
                    })))))).catch((e => {
                        throw this._initializationCompleted(), e
                    }))
                }
                disconnect() {
                    this.db && (this.listeningOnRefs.forEach((e => e.off())), this.listeningOnRefs.length = 0, this.db.goOffline())
                }
                terminate() {
                    if (this.terminated = !0, this.disconnect(), this.db) try {
                        return this.db.app.delete()
                    } finally {
                        this.db = null
                    }
                }
                getFirebaseServerTime(e) {
                    if (!this.db) throw new Error(`FirebaseService.getFirebaseServerTime: not connected! (path=${o(e)})`);
                    if (this.atomicServerTime) return this.db.ref("/.info/serverTimeOffset").once("value").then((e => e.val() + Date.now()));
                    const t = this.db.ref(e);
                    return t.set(r.database.ServerValue.TIMESTAMP).then((() => t.once("value").then((e => e.val()))))
                }
                getValuesAtPath({
                    path: e
                }) {
                    if (!this.db) throw new Error(`FirebaseService.getValuesAsPath: not connected! (path=${o(e)})`);
                    return this.db.ref(e).once("value").then((e => e.val()))
                }
                listenOnRef(e, t) {
                    return this._listenOnRefWithQuery(e, t)
                }
                listenOnPath(e, t) {
                    if (!this.db) throw new Error(`FirebaseService.listenOnPath: not connected! (path=${o(e)})`);
                    const n = this.db.ref(e);
                    return this._listenOnRefWithQuery(n, t)
                }
                _listenOnRefWithQuery(e, {
                    orderBy: t,
                    startAt: n
                } = {}) {
                    return t && (e = e.orderByChild(t)), n && (e = e.startAt(n)), {
                        when: t => ({
                            call: n => {
                                e.on(t, (e => {
                                    try {
                                        const t = n({
                                            key: e.key,
                                            value: e.val(),
                                            ref: e.ref
                                        });
                                        t && "function" == typeof t.catch && t.catch(console.error)
                                    } catch (e) {
                                        console.error(e)
                                    }
                                })), this.listeningOnRefs.push(e)
                            }
                        })
                    }
                }
                _assertInstanceAlive() {
                    if (this.terminated) throw new Error(`Can't connect a firebase service after termination, please use a different instance (name=${this.name})`)
                }
            }
        },
        88144: function(e, t, n) {
            var r; /*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
            e = n.nmd(e),
                function(i) {
                    var o = t,
                        s = (e && e.exports, "object" == typeof n.g && n.g);
                    s.global !== s && s.window;
                    var a = function(e) {
                        this.message = e
                    };
                    (a.prototype = new Error).name = "InvalidCharacterError";
                    var c = function(e) {
                            throw new a(e)
                        },
                        u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                        l = /[\t\n\f\r ]/g,
                        d = {
                            encode: function(e) {
                                e = String(e), /[^\0-\xFF]/.test(e) && c("The string to be encoded contains characters outside of the Latin1 range.");
                                for (var t, n, r, i, o = e.length % 3, s = "", a = -1, l = e.length - o; ++a < l;) t = e.charCodeAt(a) << 16, n = e.charCodeAt(++a) << 8, r = e.charCodeAt(++a), s += u.charAt((i = t + n + r) >> 18 & 63) + u.charAt(i >> 12 & 63) + u.charAt(i >> 6 & 63) + u.charAt(63 & i);
                                return 2 == o ? (t = e.charCodeAt(a) << 8, n = e.charCodeAt(++a), s += u.charAt((i = t + n) >> 10) + u.charAt(i >> 4 & 63) + u.charAt(i << 2 & 63) + "=") : 1 == o && (i = e.charCodeAt(a), s += u.charAt(i >> 2) + u.charAt(i << 4 & 63) + "=="), s
                            },
                            decode: function(e) {
                                var t = (e = String(e).replace(l, "")).length;
                                t % 4 == 0 && (t = (e = e.replace(/==?$/, "")).length), (t % 4 == 1 || /[^+a-zA-Z0-9/]/.test(e)) && c("Invalid character: the string to be decoded is not correctly encoded.");
                                for (var n, r, i = 0, o = "", s = -1; ++s < t;) r = u.indexOf(e.charAt(s)), n = i % 4 ? 64 * n + r : r, i++ % 4 && (o += String.fromCharCode(255 & n >> (-2 * i & 6)));
                                return o
                            },
                            version: "0.1.0"
                        };
                    void 0 === (r = function() {
                        return d
                    }.call(t, n, t, e)) || (e.exports = r)
                }()
        },
        47737: function(e, t, n) {
            "use strict";
            var r = n(91528),
                i = n(73235),
                o = i(r("String.prototype.indexOf"));
            e.exports = function(e, t) {
                var n = r(e, !!t);
                return "function" == typeof n && o(e, ".prototype.") > -1 ? i(n) : n
            }
        },
        73235: function(e, t, n) {
            "use strict";
            var r = n(37156),
                i = n(91528),
                o = i("%Function.prototype.apply%"),
                s = i("%Function.prototype.call%"),
                a = i("%Reflect.apply%", !0) || r.call(s, o),
                c = i("%Object.getOwnPropertyDescriptor%", !0),
                u = i("%Object.defineProperty%", !0),
                l = i("%Math.max%");
            if (u) try {
                u({}, "a", {
                    value: 1
                })
            } catch (e) {
                u = null
            }
            e.exports = function(e) {
                var t = a(r, s, arguments);
                c && u && (c(t, "length").configurable && u(t, "length", {
                    value: 1 + l(0, e.length - (arguments.length - 1))
                }));
                return t
            };
            var d = function() {
                return a(r, o, arguments)
            };
            u ? u(e.exports, "apply", {
                value: d
            }) : e.exports.apply = d
        },
        56345: function(e, t, n) {
            "use strict";

            function r(e) {
                return e && "object" == typeof e && "default" in e ? e : {
                    default: e
                }
            }
            var i = r(n(20179));
            /**
             * @license
             * Copyright 2020 Google LLC
             *
             * Licensed under the Apache License, Version 2.0 (the "License");
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *   http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an "AS IS" BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            i.default.registerVersion("firebase", "9.23.0", "app-compat"), e.exports = i.default
        },
        36691: function(e, t, n) {
            "use strict";
            n(9454)
        },
        30507: function(e, t, n) {
            "use strict";
            n(62961)
        },
        62521: function(e) {
            "use strict";
            var t = Array.prototype.slice,
                n = Object.prototype.toString;
            e.exports = function(e) {
                var r = this;
                if ("function" != typeof r || "[object Function]" !== n.call(r)) throw new TypeError("Function.prototype.bind called on incompatible " + r);
                for (var i, o = t.call(arguments, 1), s = Math.max(0, r.length - o.length), a = [], c = 0; c < s; c++) a.push("$" + c);
                if (i = Function("binder", "return function (" + a.join(",") + "){ return binder.apply(this,arguments); }")((function() {
                        if (this instanceof i) {
                            var n = r.apply(this, o.concat(t.call(arguments)));
                            return Object(n) === n ? n : this
                        }
                        return r.apply(e, o.concat(t.call(arguments)))
                    })), r.prototype) {
                    var u = function() {};
                    u.prototype = r.prototype, i.prototype = new u, u.prototype = null
                }
                return i
            }
        },
        37156: function(e, t, n) {
            "use strict";
            var r = n(62521);
            e.exports = Function.prototype.bind || r
        },
        91528: function(e, t, n) {
            "use strict";
            var r, i = SyntaxError,
                o = Function,
                s = TypeError,
                a = function(e) {
                    try {
                        return o('"use strict"; return (' + e + ").constructor;")()
                    } catch (e) {}
                },
                c = Object.getOwnPropertyDescriptor;
            if (c) try {
                c({}, "")
            } catch (e) {
                c = null
            }
            var u = function() {
                    throw new s
                },
                l = c ? function() {
                    try {
                        return u
                    } catch (e) {
                        try {
                            return c(arguments, "callee").get
                        } catch (e) {
                            return u
                        }
                    }
                }() : u,
                d = n(10465)(),
                h = n(91209)(),
                p = Object.getPrototypeOf || (h ? function(e) {
                    return e.__proto__
                } : null),
                f = {},
                m = "undefined" != typeof Uint8Array && p ? p(Uint8Array) : r,
                g = {
                    "%AggregateError%": "undefined" == typeof AggregateError ? r : AggregateError,
                    "%Array%": Array,
                    "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? r : ArrayBuffer,
                    "%ArrayIteratorPrototype%": d && p ? p([][Symbol.iterator]()) : r,
                    "%AsyncFromSyncIteratorPrototype%": r,
                    "%AsyncFunction%": f,
                    "%AsyncGenerator%": f,
                    "%AsyncGeneratorFunction%": f,
                    "%AsyncIteratorPrototype%": f,
                    "%Atomics%": "undefined" == typeof Atomics ? r : Atomics,
                    "%BigInt%": "undefined" == typeof BigInt ? r : BigInt,
                    "%BigInt64Array%": "undefined" == typeof BigInt64Array ? r : BigInt64Array,
                    "%BigUint64Array%": "undefined" == typeof BigUint64Array ? r : BigUint64Array,
                    "%Boolean%": Boolean,
                    "%DataView%": "undefined" == typeof DataView ? r : DataView,
                    "%Date%": Date,
                    "%decodeURI%": decodeURI,
                    "%decodeURIComponent%": decodeURIComponent,
                    "%encodeURI%": encodeURI,
                    "%encodeURIComponent%": encodeURIComponent,
                    "%Error%": Error,
                    "%eval%": eval,
                    "%EvalError%": EvalError,
                    "%Float32Array%": "undefined" == typeof Float32Array ? r : Float32Array,
                    "%Float64Array%": "undefined" == typeof Float64Array ? r : Float64Array,
                    "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? r : FinalizationRegistry,
                    "%Function%": o,
                    "%GeneratorFunction%": f,
                    "%Int8Array%": "undefined" == typeof Int8Array ? r : Int8Array,
                    "%Int16Array%": "undefined" == typeof Int16Array ? r : Int16Array,
                    "%Int32Array%": "undefined" == typeof Int32Array ? r : Int32Array,
                    "%isFinite%": isFinite,
                    "%isNaN%": isNaN,
                    "%IteratorPrototype%": d && p ? p(p([][Symbol.iterator]())) : r,
                    "%JSON%": "object" == typeof JSON ? JSON : r,
                    "%Map%": "undefined" == typeof Map ? r : Map,
                    "%MapIteratorPrototype%": "undefined" != typeof Map && d && p ? p((new Map)[Symbol.iterator]()) : r,
                    "%Math%": Math,
                    "%Number%": Number,
                    "%Object%": Object,
                    "%parseFloat%": parseFloat,
                    "%parseInt%": parseInt,
                    "%Promise%": "undefined" == typeof Promise ? r : Promise,
                    "%Proxy%": "undefined" == typeof Proxy ? r : Proxy,
                    "%RangeError%": RangeError,
                    "%ReferenceError%": ReferenceError,
                    "%Reflect%": "undefined" == typeof Reflect ? r : Reflect,
                    "%RegExp%": RegExp,
                    "%Set%": "undefined" == typeof Set ? r : Set,
                    "%SetIteratorPrototype%": "undefined" != typeof Set && d && p ? p((new Set)[Symbol.iterator]()) : r,
                    "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? r : SharedArrayBuffer,
                    "%String%": String,
                    "%StringIteratorPrototype%": d && p ? p("" [Symbol.iterator]()) : r,
                    "%Symbol%": d ? Symbol : r,
                    "%SyntaxError%": i,
                    "%ThrowTypeError%": l,
                    "%TypedArray%": m,
                    "%TypeError%": s,
                    "%Uint8Array%": "undefined" == typeof Uint8Array ? r : Uint8Array,
                    "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? r : Uint8ClampedArray,
                    "%Uint16Array%": "undefined" == typeof Uint16Array ? r : Uint16Array,
                    "%Uint32Array%": "undefined" == typeof Uint32Array ? r : Uint32Array,
                    "%URIError%": URIError,
                    "%WeakMap%": "undefined" == typeof WeakMap ? r : WeakMap,
                    "%WeakRef%": "undefined" == typeof WeakRef ? r : WeakRef,
                    "%WeakSet%": "undefined" == typeof WeakSet ? r : WeakSet
                };
            if (p) try {
                null.error
            } catch (e) {
                var _ = p(p(e));
                g["%Error.prototype%"] = _
            }
            var v = function e(t) {
                    var n;
                    if ("%AsyncFunction%" === t) n = a("async function () {}");
                    else if ("%GeneratorFunction%" === t) n = a("function* () {}");
                    else if ("%AsyncGeneratorFunction%" === t) n = a("async function* () {}");
                    else if ("%AsyncGenerator%" === t) {
                        var r = e("%AsyncGeneratorFunction%");
                        r && (n = r.prototype)
                    } else if ("%AsyncIteratorPrototype%" === t) {
                        var i = e("%AsyncGenerator%");
                        i && p && (n = p(i.prototype))
                    }
                    return g[t] = n, n
                },
                y = {
                    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                    "%ArrayPrototype%": ["Array", "prototype"],
                    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                    "%ArrayProto_values%": ["Array", "prototype", "values"],
                    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                    "%BooleanPrototype%": ["Boolean", "prototype"],
                    "%DataViewPrototype%": ["DataView", "prototype"],
                    "%DatePrototype%": ["Date", "prototype"],
                    "%ErrorPrototype%": ["Error", "prototype"],
                    "%EvalErrorPrototype%": ["EvalError", "prototype"],
                    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                    "%FunctionPrototype%": ["Function", "prototype"],
                    "%Generator%": ["GeneratorFunction", "prototype"],
                    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                    "%JSONParse%": ["JSON", "parse"],
                    "%JSONStringify%": ["JSON", "stringify"],
                    "%MapPrototype%": ["Map", "prototype"],
                    "%NumberPrototype%": ["Number", "prototype"],
                    "%ObjectPrototype%": ["Object", "prototype"],
                    "%ObjProto_toString%": ["Object", "prototype", "toString"],
                    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                    "%PromisePrototype%": ["Promise", "prototype"],
                    "%PromiseProto_then%": ["Promise", "prototype", "then"],
                    "%Promise_all%": ["Promise", "all"],
                    "%Promise_reject%": ["Promise", "reject"],
                    "%Promise_resolve%": ["Promise", "resolve"],
                    "%RangeErrorPrototype%": ["RangeError", "prototype"],
                    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                    "%RegExpPrototype%": ["RegExp", "prototype"],
                    "%SetPrototype%": ["Set", "prototype"],
                    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                    "%StringPrototype%": ["String", "prototype"],
                    "%SymbolPrototype%": ["Symbol", "prototype"],
                    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                    "%TypeErrorPrototype%": ["TypeError", "prototype"],
                    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                    "%URIErrorPrototype%": ["URIError", "prototype"],
                    "%WeakMapPrototype%": ["WeakMap", "prototype"],
                    "%WeakSetPrototype%": ["WeakSet", "prototype"]
                },
                b = n(37156),
                I = n(98776),
                E = b.call(Function.call, Array.prototype.concat),
                S = b.call(Function.apply, Array.prototype.splice),
                w = b.call(Function.call, String.prototype.replace),
                C = b.call(Function.call, String.prototype.slice),
                T = b.call(Function.call, RegExp.prototype.exec),
                A = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
                R = /\\(\\)?/g,
                P = function(e, t) {
                    var n, r = e;
                    if (I(y, r) && (r = "%" + (n = y[r])[0] + "%"), I(g, r)) {
                        var o = g[r];
                        if (o === f && (o = v(r)), void 0 === o && !t) throw new s("intrinsic " + e + " exists, but is not available. Please file an issue!");
                        return {
                            alias: n,
                            name: r,
                            value: o
                        }
                    }
                    throw new i("intrinsic " + e + " does not exist!")
                };
            e.exports = function(e, t) {
                if ("string" != typeof e || 0 === e.length) throw new s("intrinsic name must be a non-empty string");
                if (arguments.length > 1 && "boolean" != typeof t) throw new s('"allowMissing" argument must be a boolean');
                if (null === T(/^%?[^%]*%?$/, e)) throw new i("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                var n = function(e) {
                        var t = C(e, 0, 1),
                            n = C(e, -1);
                        if ("%" === t && "%" !== n) throw new i("invalid intrinsic syntax, expected closing `%`");
                        if ("%" === n && "%" !== t) throw new i("invalid intrinsic syntax, expected opening `%`");
                        var r = [];
                        return w(e, A, (function(e, t, n, i) {
                            r[r.length] = n ? w(i, R, "$1") : t || e
                        })), r
                    }(e),
                    r = n.length > 0 ? n[0] : "",
                    o = P("%" + r + "%", t),
                    a = o.name,
                    u = o.value,
                    l = !1,
                    d = o.alias;
                d && (r = d[0], S(n, E([0, 1], d)));
                for (var h = 1, p = !0; h < n.length; h += 1) {
                    var f = n[h],
                        m = C(f, 0, 1),
                        _ = C(f, -1);
                    if (('"' === m || "'" === m || "`" === m || '"' === _ || "'" === _ || "`" === _) && m !== _) throw new i("property names with quotes must have matching quotes");
                    if ("constructor" !== f && p || (l = !0), I(g, a = "%" + (r += "." + f) + "%")) u = g[a];
                    else if (null != u) {
                        if (!(f in u)) {
                            if (!t) throw new s("base intrinsic for " + e + " exists, but the property is not available.");
                            return
                        }
                        if (c && h + 1 >= n.length) {
                            var v = c(u, f);
                            u = (p = !!v) && "get" in v && !("originalValue" in v.get) ? v.get : u[f]
                        } else p = I(u, f), u = u[f];
                        p && !l && (g[a] = u)
                    }
                }
                return u
            }
        },
        91209: function(e) {
            "use strict";
            var t = {
                    foo: {}
                },
                n = Object;
            e.exports = function() {
                return {
                    __proto__: t
                }.foo === t.foo && !({
                        __proto__: null
                    }
                    instanceof n)
            }
        },
        10465: function(e, t, n) {
            "use strict";
            var r = "undefined" != typeof Symbol && Symbol,
                i = n(16073);
            e.exports = function() {
                return "function" == typeof r && ("function" == typeof Symbol && ("symbol" == typeof r("foo") && ("symbol" == typeof Symbol("bar") && i())))
            }
        },
        16073: function(e) {
            "use strict";
            e.exports = function() {
                if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
                if ("symbol" == typeof Symbol.iterator) return !0;
                var e = {},
                    t = Symbol("test"),
                    n = Object(t);
                if ("string" == typeof t) return !1;
                if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1;
                if ("[object Symbol]" !== Object.prototype.toString.call(n)) return !1;
                for (t in e[t] = 42, e) return !1;
                if ("function" == typeof Object.keys && 0 !== Object.keys(e).length) return !1;
                if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1;
                var r = Object.getOwnPropertySymbols(e);
                if (1 !== r.length || r[0] !== t) return !1;
                if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
                if ("function" == typeof Object.getOwnPropertyDescriptor) {
                    var i = Object.getOwnPropertyDescriptor(e, t);
                    if (42 !== i.value || !0 !== i.enumerable) return !1
                }
                return !0
            }
        },
        98776: function(e, t, n) {
            "use strict";
            var r = n(37156);
            e.exports = r.call(Function.call, Object.prototype.hasOwnProperty)
        },
        85198: function(e) {
            e.exports = function(e, t, n) {
                switch (n.length) {
                    case 0:
                        return e.call(t);
                    case 1:
                        return e.call(t, n[0]);
                    case 2:
                        return e.call(t, n[0], n[1]);
                    case 3:
                        return e.call(t, n[0], n[1], n[2])
                }
                return e.apply(t, n)
            }
        },
        26758: function(e) {
            e.exports = function(e, t) {
                for (var n = -1, r = null == e ? 0 : e.length; ++n < r && !1 !== t(e[n], n, e););
                return e
            }
        },
        88058: function(e, t, n) {
            var r = n(87650);
            e.exports = function(e, t) {
                return !!(null == e ? 0 : e.length) && r(e, t, 0) > -1
            }
        },
        37431: function(e) {
            e.exports = function(e, t, n) {
                for (var r = -1, i = null == e ? 0 : e.length; ++r < i;)
                    if (n(t, e[r])) return !0;
                return !1
            }
        },
        26974: function(e) {
            e.exports = function(e, t, n, r) {
                var i = -1,
                    o = null == e ? 0 : e.length;
                for (r && o && (n = e[++i]); ++i < o;) n = t(n, e[i], i, e);
                return n
            }
        },
        4373: function(e, t, n) {
            var r = n(40999),
                i = n(26530);
            e.exports = function(e, t, n) {
                (void 0 !== n && !i(e[t], n) || void 0 === n && !(t in e)) && r(e, t, n)
            }
        },
        47596: function(e, t, n) {
            var r = n(40999),
                i = n(26530),
                o = Object.prototype.hasOwnProperty;
            e.exports = function(e, t, n) {
                var s = e[t];
                o.call(e, t) && i(s, n) && (void 0 !== n || t in e) || r(e, t, n)
            }
        },
        5615: function(e, t, n) {
            var r = n(96051),
                i = n(52635);
            e.exports = function(e, t) {
                return e && r(t, i(t), e)
            }
        },
        3238: function(e, t, n) {
            var r = n(96051),
                i = n(5850);
            e.exports = function(e, t) {
                return e && r(t, i(t), e)
            }
        },
        40999: function(e, t, n) {
            var r = n(9346);
            e.exports = function(e, t, n) {
                "__proto__" == t && r ? r(e, t, {
                    configurable: !0,
                    enumerable: !0,
                    value: n,
                    writable: !0
                }) : e[t] = n
            }
        },
        42327: function(e, t, n) {
            var r = n(4281),
                i = n(26758),
                o = n(47596),
                s = n(5615),
                a = n(3238),
                c = n(78172),
                u = n(66438),
                l = n(23746),
                d = n(93989),
                h = n(36094),
                p = n(15559),
                f = n(26686),
                m = n(26019),
                g = n(27621),
                _ = n(73905),
                v = n(77236),
                y = n(98752),
                b = n(9525),
                I = n(85973),
                E = n(66925),
                S = n(52635),
                w = n(5850),
                C = "[object Arguments]",
                T = "[object Function]",
                A = "[object Object]",
                R = {};
            R[C] = R["[object Array]"] = R["[object ArrayBuffer]"] = R["[object DataView]"] = R["[object Boolean]"] = R["[object Date]"] = R["[object Float32Array]"] = R["[object Float64Array]"] = R["[object Int8Array]"] = R["[object Int16Array]"] = R["[object Int32Array]"] = R["[object Map]"] = R["[object Number]"] = R[A] = R["[object RegExp]"] = R["[object Set]"] = R["[object String]"] = R["[object Symbol]"] = R["[object Uint8Array]"] = R["[object Uint8ClampedArray]"] = R["[object Uint16Array]"] = R["[object Uint32Array]"] = !0, R["[object Error]"] = R[T] = R["[object WeakMap]"] = !1, e.exports = function e(t, n, P, O, k, N) {
                var D, M = 1 & n,
                    x = 2 & n,
                    L = 4 & n;
                if (P && (D = k ? P(t, O, k, N) : P(t)), void 0 !== D) return D;
                if (!I(t)) return t;
                var U = v(t);
                if (U) {
                    if (D = m(t), !M) return u(t, D)
                } else {
                    var F = f(t),
                        j = F == T || "[object GeneratorFunction]" == F;
                    if (y(t)) return c(t, M);
                    if (F == A || F == C || j && !k) {
                        if (D = x || j ? {} : _(t), !M) return x ? d(t, a(D, t)) : l(t, s(D, t))
                    } else {
                        if (!R[F]) return k ? t : {};
                        D = g(t, F, M)
                    }
                }
                N || (N = new r);
                var q = N.get(t);
                if (q) return q;
                N.set(t, D), E(t) ? t.forEach((function(r) {
                    D.add(e(r, n, P, r, t, N))
                })) : b(t) && t.forEach((function(r, i) {
                    D.set(i, e(r, n, P, i, t, N))
                }));
                var H = U ? void 0 : (L ? x ? p : h : x ? w : S)(t);
                return i(H || t, (function(r, i) {
                    H && (r = t[i = r]), o(D, i, e(r, n, P, i, t, N))
                })), D
            }
        },
        67372: function(e, t, n) {
            var r = n(85973),
                i = Object.create,
                o = function() {
                    function e() {}
                    return function(t) {
                        if (!r(t)) return {};
                        if (i) return i(t);
                        e.prototype = t;
                        var n = new e;
                        return e.prototype = void 0, n
                    }
                }();
            e.exports = o
        },
        91096: function(e, t, n) {
            var r = n(61124),
                i = n(88058),
                o = n(37431),
                s = n(26460),
                a = n(76535),
                c = n(30555);
            e.exports = function(e, t, n, u) {
                var l = -1,
                    d = i,
                    h = !0,
                    p = e.length,
                    f = [],
                    m = t.length;
                if (!p) return f;
                n && (t = s(t, a(n))), u ? (d = o, h = !1) : t.length >= 200 && (d = c, h = !1, t = new r(t));
                e: for (; ++l < p;) {
                    var g = e[l],
                        _ = null == n ? g : n(g);
                    if (g = u || 0 !== g ? g : 0, h && _ == _) {
                        for (var v = m; v--;)
                            if (t[v] === _) continue e;
                        f.push(g)
                    } else d(t, _, u) || f.push(g)
                }
                return f
            }
        },
        56671: function(e, t, n) {
            var r = n(35897),
                i = n(74741)(r);
            e.exports = i
        },
        60833: function(e, t, n) {
            var r = n(22945);
            e.exports = function(e, t, n) {
                for (var i = -1, o = e.length; ++i < o;) {
                    var s = e[i],
                        a = t(s);
                    if (null != a && (void 0 === c ? a == a && !r(a) : n(a, c))) var c = a,
                        u = s
                }
                return u
            }
        },
        93861: function(e, t, n) {
            var r = n(56671);
            e.exports = function(e, t) {
                var n = [];
                return r(e, (function(e, r, i) {
                    t(e, r, i) && n.push(e)
                })), n
            }
        },
        60528: function(e) {
            e.exports = function(e, t, n, r) {
                for (var i = e.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i;)
                    if (t(e[o], o, e)) return o;
                return -1
            }
        },
        40314: function(e, t, n) {
            var r = n(63848),
                i = n(91754);
            e.exports = function e(t, n, o, s, a) {
                var c = -1,
                    u = t.length;
                for (o || (o = i), a || (a = []); ++c < u;) {
                    var l = t[c];
                    n > 0 && o(l) ? n > 1 ? e(l, n - 1, o, s, a) : r(a, l) : s || (a[a.length] = l)
                }
                return a
            }
        },
        49238: function(e) {
            e.exports = function(e, t) {
                return e > t
            }
        },
        87650: function(e, t, n) {
            var r = n(60528),
                i = n(25556),
                o = n(54256);
            e.exports = function(e, t, n) {
                return t == t ? o(e, t, n) : r(e, i, n)
            }
        },
        4368: function(e, t, n) {
            var r = n(26686),
                i = n(3387);
            e.exports = function(e) {
                return i(e) && "[object Map]" == r(e)
            }
        },
        25556: function(e) {
            e.exports = function(e) {
                return e != e
            }
        },
        4642: function(e, t, n) {
            var r = n(26686),
                i = n(3387);
            e.exports = function(e) {
                return i(e) && "[object Set]" == r(e)
            }
        },
        32578: function(e, t, n) {
            var r = n(85973),
                i = n(65003),
                o = n(14904),
                s = Object.prototype.hasOwnProperty;
            e.exports = function(e) {
                if (!r(e)) return o(e);
                var t = i(e),
                    n = [];
                for (var a in e)("constructor" != a || !t && s.call(e, a)) && n.push(a);
                return n
            }
        },
        52920: function(e, t, n) {
            var r = n(56671),
                i = n(81580);
            e.exports = function(e, t) {
                var n = -1,
                    o = i(e) ? Array(e.length) : [];
                return r(e, (function(e, r, i) {
                    o[++n] = t(e, r, i)
                })), o
            }
        },
        63920: function(e, t, n) {
            var r = n(4281),
                i = n(4373),
                o = n(60641),
                s = n(74810),
                a = n(85973),
                c = n(5850),
                u = n(85623);
            e.exports = function e(t, n, l, d, h) {
                t !== n && o(n, (function(o, c) {
                    if (h || (h = new r), a(o)) s(t, n, c, l, e, d, h);
                    else {
                        var p = d ? d(u(t, c), o, c + "", t, n, h) : void 0;
                        void 0 === p && (p = o), i(t, c, p)
                    }
                }), c)
            }
        },
        74810: function(e, t, n) {
            var r = n(4373),
                i = n(78172),
                o = n(22215),
                s = n(66438),
                a = n(73905),
                c = n(86981),
                u = n(77236),
                l = n(99747),
                d = n(98752),
                h = n(93839),
                p = n(85973),
                f = n(9636),
                m = n(14812),
                g = n(85623),
                _ = n(57464);
            e.exports = function(e, t, n, v, y, b, I) {
                var E = g(e, n),
                    S = g(t, n),
                    w = I.get(S);
                if (w) r(e, n, w);
                else {
                    var C = b ? b(E, S, n + "", e, t, I) : void 0,
                        T = void 0 === C;
                    if (T) {
                        var A = u(S),
                            R = !A && d(S),
                            P = !A && !R && m(S);
                        C = S, A || R || P ? u(E) ? C = E : l(E) ? C = s(E) : R ? (T = !1, C = i(S, !0)) : P ? (T = !1, C = o(S, !0)) : C = [] : f(S) || c(S) ? (C = E, c(E) ? C = _(E) : p(E) && !h(E) || (C = a(S))) : T = !1
                    }
                    T && (I.set(S, C), y(C, S, v, b, I), I.delete(S)), r(e, n, C)
                }
            }
        },
        50690: function(e, t, n) {
            var r = n(26460),
                i = n(80166),
                o = n(88904),
                s = n(52920),
                a = n(36024),
                c = n(76535),
                u = n(1397),
                l = n(15362),
                d = n(77236);
            e.exports = function(e, t, n) {
                t = t.length ? r(t, (function(e) {
                    return d(e) ? function(t) {
                        return i(t, 1 === e.length ? e[0] : e)
                    } : e
                })) : [l];
                var h = -1;
                t = r(t, c(o));
                var p = s(e, (function(e, n, i) {
                    return {
                        criteria: r(t, (function(t) {
                            return t(e)
                        })),
                        index: ++h,
                        value: e
                    }
                }));
                return a(p, (function(e, t) {
                    return u(e, t, n)
                }))
            }
        },
        96621: function(e, t, n) {
            var r = n(80166),
                i = n(58116),
                o = n(18422);
            e.exports = function(e, t, n) {
                for (var s = -1, a = t.length, c = {}; ++s < a;) {
                    var u = t[s],
                        l = r(e, u);
                    n(l, u) && i(c, o(u, e), l)
                }
                return c
            }
        },
        77993: function(e, t, n) {
            var r = n(69386),
                i = n(74363),
                o = Array.prototype.splice;
            e.exports = function(e, t) {
                for (var n = e ? t.length : 0, s = n - 1; n--;) {
                    var a = t[n];
                    if (n == s || a !== c) {
                        var c = a;
                        i(a) ? o.call(e, a, 1) : r(e, a)
                    }
                }
                return e
            }
        },
        65090: function(e) {
            e.exports = function(e, t, n, r, i) {
                return i(e, (function(e, i, o) {
                    n = r ? (r = !1, e) : t(n, e, i, o)
                })), n
            }
        },
        94569: function(e, t, n) {
            var r = n(15362),
                i = n(94468),
                o = n(98756);
            e.exports = function(e, t) {
                return o(i(e, t, r), e + "")
            }
        },
        58116: function(e, t, n) {
            var r = n(47596),
                i = n(18422),
                o = n(74363),
                s = n(85973),
                a = n(18780);
            e.exports = function(e, t, n, c) {
                if (!s(e)) return e;
                for (var u = -1, l = (t = i(t, e)).length, d = l - 1, h = e; null != h && ++u < l;) {
                    var p = a(t[u]),
                        f = n;
                    if ("__proto__" === p || "constructor" === p || "prototype" === p) return e;
                    if (u != d) {
                        var m = h[p];
                        void 0 === (f = c ? c(m, p, h) : void 0) && (f = s(m) ? m : o(t[u + 1]) ? [] : {})
                    }
                    r(h, p, f), h = h[p]
                }
                return e
            }
        },
        81676: function(e, t, n) {
            var r = n(88211),
                i = n(9346),
                o = n(15362),
                s = i ? function(e, t) {
                    return i(e, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: r(t),
                        writable: !0
                    })
                } : o;
            e.exports = s
        },
        4293: function(e) {
            e.exports = function(e, t, n) {
                var r = -1,
                    i = e.length;
                t < 0 && (t = -t > i ? 0 : i + t), (n = n > i ? i : n) < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
                for (var o = Array(i); ++r < i;) o[r] = e[r + t];
                return o
            }
        },
        36024: function(e) {
            e.exports = function(e, t) {
                var n = e.length;
                for (e.sort(t); n--;) e[n] = e[n].value;
                return e
            }
        },
        63349: function(e, t, n) {
            var r = n(5720),
                i = /^\s+/;
            e.exports = function(e) {
                return e ? e.slice(0, r(e) + 1).replace(i, "") : e
            }
        },
        84351: function(e, t, n) {
            var r = n(61124),
                i = n(88058),
                o = n(37431),
                s = n(30555),
                a = n(58491),
                c = n(66350);
            e.exports = function(e, t, n) {
                var u = -1,
                    l = i,
                    d = e.length,
                    h = !0,
                    p = [],
                    f = p;
                if (n) h = !1, l = o;
                else if (d >= 200) {
                    var m = t ? null : a(e);
                    if (m) return c(m);
                    h = !1, l = s, f = new r
                } else f = t ? [] : p;
                e: for (; ++u < d;) {
                    var g = e[u],
                        _ = t ? t(g) : g;
                    if (g = n || 0 !== g ? g : 0, h && _ == _) {
                        for (var v = f.length; v--;)
                            if (f[v] === _) continue e;
                        t && f.push(_), p.push(g)
                    } else l(f, _, n) || (f !== p && f.push(_), p.push(g))
                }
                return p
            }
        },
        69386: function(e, t, n) {
            var r = n(18422),
                i = n(22972),
                o = n(18293),
                s = n(18780);
            e.exports = function(e, t) {
                return t = r(t, e), null == (e = o(e, t)) || delete e[s(i(t))]
            }
        },
        13632: function(e, t, n) {
            var r = n(5982);
            e.exports = function(e) {
                var t = new e.constructor(e.byteLength);
                return new r(t).set(new r(e)), t
            }
        },
        78172: function(e, t, n) {
            e = n.nmd(e);
            var r = n(70441),
                i = t && !t.nodeType && t,
                o = i && e && !e.nodeType && e,
                s = o && o.exports === i ? r.Buffer : void 0,
                a = s ? s.allocUnsafe : void 0;
            e.exports = function(e, t) {
                if (t) return e.slice();
                var n = e.length,
                    r = a ? a(n) : new e.constructor(n);
                return e.copy(r), r
            }
        },
        39841: function(e, t, n) {
            var r = n(13632);
            e.exports = function(e, t) {
                var n = t ? r(e.buffer) : e.buffer;
                return new e.constructor(n, e.byteOffset, e.byteLength)
            }
        },
        62769: function(e) {
            var t = /\w*$/;
            e.exports = function(e) {
                var n = new e.constructor(e.source, t.exec(e));
                return n.lastIndex = e.lastIndex, n
            }
        },
        49130: function(e, t, n) {
            var r = n(54690),
                i = r ? r.prototype : void 0,
                o = i ? i.valueOf : void 0;
            e.exports = function(e) {
                return o ? Object(o.call(e)) : {}
            }
        },
        22215: function(e, t, n) {
            var r = n(13632);
            e.exports = function(e, t) {
                var n = t ? r(e.buffer) : e.buffer;
                return new e.constructor(n, e.byteOffset, e.length)
            }
        },
        40709: function(e, t, n) {
            var r = n(22945);
            e.exports = function(e, t) {
                if (e !== t) {
                    var n = void 0 !== e,
                        i = null === e,
                        o = e == e,
                        s = r(e),
                        a = void 0 !== t,
                        c = null === t,
                        u = t == t,
                        l = r(t);
                    if (!c && !l && !s && e > t || s && a && u && !c && !l || i && a && u || !n && u || !o) return 1;
                    if (!i && !s && !l && e < t || l && n && o && !i && !s || c && n && o || !a && o || !u) return -1
                }
                return 0
            }
        },
        1397: function(e, t, n) {
            var r = n(40709);
            e.exports = function(e, t, n) {
                for (var i = -1, o = e.criteria, s = t.criteria, a = o.length, c = n.length; ++i < a;) {
                    var u = r(o[i], s[i]);
                    if (u) return i >= c ? u : u * ("desc" == n[i] ? -1 : 1)
                }
                return e.index - t.index
            }
        },
        66438: function(e) {
            e.exports = function(e, t) {
                var n = -1,
                    r = e.length;
                for (t || (t = Array(r)); ++n < r;) t[n] = e[n];
                return t
            }
        },
        96051: function(e, t, n) {
            var r = n(47596),
                i = n(40999);
            e.exports = function(e, t, n, o) {
                var s = !n;
                n || (n = {});
                for (var a = -1, c = t.length; ++a < c;) {
                    var u = t[a],
                        l = o ? o(n[u], e[u], u, n, e) : void 0;
                    void 0 === l && (l = e[u]), s ? i(n, u, l) : r(n, u, l)
                }
                return n
            }
        },
        23746: function(e, t, n) {
            var r = n(96051),
                i = n(75904);
            e.exports = function(e, t) {
                return r(e, i(e), t)
            }
        },
        93989: function(e, t, n) {
            var r = n(96051),
                i = n(12511);
            e.exports = function(e, t) {
                return r(e, i(e), t)
            }
        },
        32544: function(e, t, n) {
            var r = n(94569),
                i = n(63108);
            e.exports = function(e) {
                return r((function(t, n) {
                    var r = -1,
                        o = n.length,
                        s = o > 1 ? n[o - 1] : void 0,
                        a = o > 2 ? n[2] : void 0;
                    for (s = e.length > 3 && "function" == typeof s ? (o--, s) : void 0, a && i(n[0], n[1], a) && (s = o < 3 ? void 0 : s, o = 1), t = Object(t); ++r < o;) {
                        var c = n[r];
                        c && e(t, c, r, s)
                    }
                    return t
                }))
            }
        },
        74741: function(e, t, n) {
            var r = n(81580);
            e.exports = function(e, t) {
                return function(n, i) {
                    if (null == n) return n;
                    if (!r(n)) return e(n, i);
                    for (var o = n.length, s = t ? o : -1, a = Object(n);
                        (t ? s-- : ++s < o) && !1 !== i(a[s], s, a););
                    return n
                }
            }
        },
        3086: function(e, t, n) {
            var r = n(88904),
                i = n(81580),
                o = n(52635);
            e.exports = function(e) {
                return function(t, n, s) {
                    var a = Object(t);
                    if (!i(t)) {
                        var c = r(n, 3);
                        t = o(t), n = function(e) {
                            return c(a[e], e, a)
                        }
                    }
                    var u = e(t, n, s);
                    return u > -1 ? a[c ? t[u] : u] : void 0
                }
            }
        },
        58491: function(e, t, n) {
            var r = n(69902),
                i = n(13581),
                o = n(66350),
                s = r && 1 / o(new r([, -0]))[1] == 1 / 0 ? function(e) {
                    return new r(e)
                } : i;
            e.exports = s
        },
        79294: function(e, t, n) {
            var r = n(9636);
            e.exports = function(e) {
                return r(e) ? void 0 : e
            }
        },
        9346: function(e, t, n) {
            var r = n(84457),
                i = function() {
                    try {
                        var e = r(Object, "defineProperty");
                        return e({}, "", {}), e
                    } catch (e) {}
                }();
            e.exports = i
        },
        83368: function(e, t, n) {
            var r = n(75453),
                i = n(94468),
                o = n(98756);
            e.exports = function(e) {
                return o(i(e, void 0, r), e + "")
            }
        },
        15559: function(e, t, n) {
            var r = n(39329),
                i = n(12511),
                o = n(5850);
            e.exports = function(e) {
                return r(e, o, i)
            }
        },
        71407: function(e, t, n) {
            var r = n(53717)(Object.getPrototypeOf, Object);
            e.exports = r
        },
        12511: function(e, t, n) {
            var r = n(63848),
                i = n(71407),
                o = n(75904),
                s = n(27471),
                a = Object.getOwnPropertySymbols ? function(e) {
                    for (var t = []; e;) r(t, o(e)), e = i(e);
                    return t
                } : s;
            e.exports = a
        },
        26019: function(e) {
            var t = Object.prototype.hasOwnProperty;
            e.exports = function(e) {
                var n = e.length,
                    r = new e.constructor(n);
                return n && "string" == typeof e[0] && t.call(e, "index") && (r.index = e.index, r.input = e.input), r
            }
        },
        27621: function(e, t, n) {
            var r = n(13632),
                i = n(39841),
                o = n(62769),
                s = n(49130),
                a = n(22215);
            e.exports = function(e, t, n) {
                var c = e.constructor;
                switch (t) {
                    case "[object ArrayBuffer]":
                        return r(e);
                    case "[object Boolean]":
                    case "[object Date]":
                        return new c(+e);
                    case "[object DataView]":
                        return i(e, n);
                    case "[object Float32Array]":
                    case "[object Float64Array]":
                    case "[object Int8Array]":
                    case "[object Int16Array]":
                    case "[object Int32Array]":
                    case "[object Uint8Array]":
                    case "[object Uint8ClampedArray]":
                    case "[object Uint16Array]":
                    case "[object Uint32Array]":
                        return a(e, n);
                    case "[object Map]":
                    case "[object Set]":
                        return new c;
                    case "[object Number]":
                    case "[object String]":
                        return new c(e);
                    case "[object RegExp]":
                        return o(e);
                    case "[object Symbol]":
                        return s(e)
                }
            }
        },
        73905: function(e, t, n) {
            var r = n(67372),
                i = n(71407),
                o = n(65003);
            e.exports = function(e) {
                return "function" != typeof e.constructor || o(e) ? {} : r(i(e))
            }
        },
        91754: function(e, t, n) {
            var r = n(54690),
                i = n(86981),
                o = n(77236),
                s = r ? r.isConcatSpreadable : void 0;
            e.exports = function(e) {
                return o(e) || i(e) || !!(s && e && e[s])
            }
        },
        63108: function(e, t, n) {
            var r = n(26530),
                i = n(81580),
                o = n(74363),
                s = n(85973);
            e.exports = function(e, t, n) {
                if (!s(n)) return !1;
                var a = typeof t;
                return !!("number" == a ? i(n) && o(t, n.length) : "string" == a && t in n) && r(n[t], e)
            }
        },
        14904: function(e) {
            e.exports = function(e) {
                var t = [];
                if (null != e)
                    for (var n in Object(e)) t.push(n);
                return t
            }
        },
        94468: function(e, t, n) {
            var r = n(85198),
                i = Math.max;
            e.exports = function(e, t, n) {
                return t = i(void 0 === t ? e.length - 1 : t, 0),
                    function() {
                        for (var o = arguments, s = -1, a = i(o.length - t, 0), c = Array(a); ++s < a;) c[s] = o[t + s];
                        s = -1;
                        for (var u = Array(t + 1); ++s < t;) u[s] = o[s];
                        return u[t] = n(c), r(e, this, u)
                    }
            }
        },
        18293: function(e, t, n) {
            var r = n(80166),
                i = n(4293);
            e.exports = function(e, t) {
                return t.length < 2 ? e : r(e, i(t, 0, -1))
            }
        },
        85623: function(e) {
            e.exports = function(e, t) {
                if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t) return e[t]
            }
        },
        98756: function(e, t, n) {
            var r = n(81676),
                i = n(79116)(r);
            e.exports = i
        },
        79116: function(e) {
            var t = Date.now;
            e.exports = function(e) {
                var n = 0,
                    r = 0;
                return function() {
                    var i = t(),
                        o = 16 - (i - r);
                    if (r = i, o > 0) {
                        if (++n >= 800) return arguments[0]
                    } else n = 0;
                    return e.apply(void 0, arguments)
                }
            }
        },
        54256: function(e) {
            e.exports = function(e, t, n) {
                for (var r = n - 1, i = e.length; ++r < i;)
                    if (e[r] === t) return r;
                return -1
            }
        },
        5720: function(e) {
            var t = /\s/;
            e.exports = function(e) {
                for (var n = e.length; n-- && t.test(e.charAt(n)););
                return n
            }
        },
        50403: function(e, t, n) {
            var r = n(63848),
                i = n(40314),
                o = n(66438),
                s = n(77236);
            e.exports = function() {
                var e = arguments.length;
                if (!e) return [];
                for (var t = Array(e - 1), n = arguments[0], a = e; a--;) t[a - 1] = arguments[a];
                return r(s(n) ? o(n) : [n], i(t, 1))
            }
        },
        88211: function(e) {
            e.exports = function(e) {
                return function() {
                    return e
                }
            }
        },
        45750: function(e, t, n) {
            var r = n(85973),
                i = n(28148),
                o = n(78746),
                s = Math.max,
                a = Math.min;
            e.exports = function(e, t, n) {
                var c, u, l, d, h, p, f = 0,
                    m = !1,
                    g = !1,
                    _ = !0;
                if ("function" != typeof e) throw new TypeError("Expected a function");

                function v(t) {
                    var n = c,
                        r = u;
                    return c = u = void 0, f = t, d = e.apply(r, n)
                }

                function y(e) {
                    var n = e - p;
                    return void 0 === p || n >= t || n < 0 || g && e - f >= l
                }

                function b() {
                    var e = i();
                    if (y(e)) return I(e);
                    h = setTimeout(b, function(e) {
                        var n = t - (e - p);
                        return g ? a(n, l - (e - f)) : n
                    }(e))
                }

                function I(e) {
                    return h = void 0, _ && c ? v(e) : (c = u = void 0, d)
                }

                function E() {
                    var e = i(),
                        n = y(e);
                    if (c = arguments, u = this, p = e, n) {
                        if (void 0 === h) return function(e) {
                            return f = e, h = setTimeout(b, t), m ? v(e) : d
                        }(p);
                        if (g) return clearTimeout(h), h = setTimeout(b, t), v(p)
                    }
                    return void 0 === h && (h = setTimeout(b, t)), d
                }
                return t = o(t) || 0, r(n) && (m = !!n.leading, l = (g = "maxWait" in n) ? s(o(n.maxWait) || 0, t) : l, _ = "trailing" in n ? !!n.trailing : _), E.cancel = function() {
                    void 0 !== h && clearTimeout(h), f = 0, c = p = u = h = void 0
                }, E.flush = function() {
                    return void 0 === h ? d : I(i())
                }, E
            }
        },
        484: function(e, t, n) {
            var r = n(91096),
                i = n(40314),
                o = n(94569),
                s = n(99747),
                a = o((function(e, t) {
                    return s(e) ? r(e, i(t, 1, s, !0)) : []
                }));
            e.exports = a
        },
        86330: function(e, t, n) {
            var r = n(69037),
                i = n(93861),
                o = n(88904),
                s = n(77236);
            e.exports = function(e, t) {
                return (s(e) ? r : i)(e, o(t, 3))
            }
        },
        56786: function(e, t, n) {
            var r = n(3086)(n(28611));
            e.exports = r
        },
        28611: function(e, t, n) {
            var r = n(60528),
                i = n(88904),
                o = n(25225),
                s = Math.max;
            e.exports = function(e, t, n) {
                var a = null == e ? 0 : e.length;
                if (!a) return -1;
                var c = null == n ? 0 : o(n);
                return c < 0 && (c = s(a + c, 0)), r(e, i(t, 3), c)
            }
        },
        79937: function(e, t, n) {
            e.exports = n(13230)
        },
        75453: function(e, t, n) {
            var r = n(40314);
            e.exports = function(e) {
                return (null == e ? 0 : e.length) ? r(e, 1) : []
            }
        },
        13230: function(e) {
            e.exports = function(e) {
                return e && e.length ? e[0] : void 0
            }
        },
        99747: function(e, t, n) {
            var r = n(81580),
                i = n(3387);
            e.exports = function(e) {
                return i(e) && r(e)
            }
        },
        86834: function(e, t, n) {
            var r = n(78803),
                i = n(26686),
                o = n(86981),
                s = n(77236),
                a = n(81580),
                c = n(98752),
                u = n(65003),
                l = n(14812),
                d = Object.prototype.hasOwnProperty;
            e.exports = function(e) {
                if (null == e) return !0;
                if (a(e) && (s(e) || "string" == typeof e || "function" == typeof e.splice || c(e) || l(e) || o(e))) return !e.length;
                var t = i(e);
                if ("[object Map]" == t || "[object Set]" == t) return !e.size;
                if (u(e)) return !r(e).length;
                for (var n in e)
                    if (d.call(e, n)) return !1;
                return !0
            }
        },
        89793: function(e, t, n) {
            var r = n(31071);
            e.exports = function(e, t) {
                return r(e, t)
            }
        },
        9525: function(e, t, n) {
            var r = n(4368),
                i = n(76535),
                o = n(91782),
                s = o && o.isMap,
                a = s ? i(s) : r;
            e.exports = a
        },
        9636: function(e, t, n) {
            var r = n(94318),
                i = n(71407),
                o = n(3387),
                s = Function.prototype,
                a = Object.prototype,
                c = s.toString,
                u = a.hasOwnProperty,
                l = c.call(Object);
            e.exports = function(e) {
                if (!o(e) || "[object Object]" != r(e)) return !1;
                var t = i(e);
                if (null === t) return !0;
                var n = u.call(t, "constructor") && t.constructor;
                return "function" == typeof n && n instanceof n && c.call(n) == l
            }
        },
        66925: function(e, t, n) {
            var r = n(4642),
                i = n(76535),
                o = n(91782),
                s = o && o.isSet,
                a = s ? i(s) : r;
            e.exports = a
        },
        5850: function(e, t, n) {
            var r = n(16222),
                i = n(32578),
                o = n(81580);
            e.exports = function(e) {
                return o(e) ? r(e, !0) : i(e)
            }
        },
        22972: function(e) {
            e.exports = function(e) {
                var t = null == e ? 0 : e.length;
                return t ? e[t - 1] : void 0
            }
        },
        37213: function(e, t, n) {
            var r = n(26460),
                i = n(88904),
                o = n(52920),
                s = n(77236);
            e.exports = function(e, t) {
                return (s(e) ? r : o)(e, i(t, 3))
            }
        },
        80340: function(e, t, n) {
            var r = n(60833),
                i = n(49238),
                o = n(88904);
            e.exports = function(e, t) {
                return e && e.length ? r(e, o(t, 2), i) : void 0
            }
        },
        86349: function(e, t, n) {
            var r = n(63920),
                i = n(32544)((function(e, t, n) {
                    r(e, t, n)
                }));
            e.exports = i
        },
        35913: function(e) {
            e.exports = function(e) {
                if ("function" != typeof e) throw new TypeError("Expected a function");
                return function() {
                    var t = arguments;
                    switch (t.length) {
                        case 0:
                            return !e.call(this);
                        case 1:
                            return !e.call(this, t[0]);
                        case 2:
                            return !e.call(this, t[0], t[1]);
                        case 3:
                            return !e.call(this, t[0], t[1], t[2])
                    }
                    return !e.apply(this, t)
                }
            }
        },
        13581: function(e) {
            e.exports = function() {}
        },
        28148: function(e, t, n) {
            var r = n(70441);
            e.exports = function() {
                return r.Date.now()
            }
        },
        9086: function(e, t, n) {
            var r = n(26460),
                i = n(42327),
                o = n(69386),
                s = n(18422),
                a = n(96051),
                c = n(79294),
                u = n(83368),
                l = n(15559),
                d = u((function(e, t) {
                    var n = {};
                    if (null == e) return n;
                    var u = !1;
                    t = r(t, (function(t) {
                        return t = s(t, e), u || (u = t.length > 1), t
                    })), a(e, l(e), n), u && (n = i(n, 7, c));
                    for (var d = t.length; d--;) o(n, t[d]);
                    return n
                }));
            e.exports = d
        },
        95492: function(e, t, n) {
            var r = n(88904),
                i = n(35913),
                o = n(79922);
            e.exports = function(e, t) {
                return o(e, i(r(t)))
            }
        },
        79922: function(e, t, n) {
            var r = n(26460),
                i = n(88904),
                o = n(96621),
                s = n(15559);
            e.exports = function(e, t) {
                if (null == e) return {};
                var n = r(s(e), (function(e) {
                    return [e]
                }));
                return t = i(t), o(e, n, (function(e, n) {
                    return t(e, n[0])
                }))
            }
        },
        20520: function(e, t, n) {
            var r = n(26974),
                i = n(56671),
                o = n(88904),
                s = n(65090),
                a = n(77236);
            e.exports = function(e, t, n) {
                var c = a(e) ? r : s,
                    u = arguments.length < 3;
                return c(e, o(t, 4), n, u, i)
            }
        },
        43913: function(e, t, n) {
            var r = n(88904),
                i = n(77993);
            e.exports = function(e, t) {
                var n = [];
                if (!e || !e.length) return n;
                var o = -1,
                    s = [],
                    a = e.length;
                for (t = r(t, 3); ++o < a;) {
                    var c = e[o];
                    t(c, o, e) && (n.push(c), s.push(o))
                }
                return i(e, s), n
            }
        },
        98978: function(e, t, n) {
            var r = n(40314),
                i = n(50690),
                o = n(94569),
                s = n(63108),
                a = o((function(e, t) {
                    if (null == e) return [];
                    var n = t.length;
                    return n > 1 && s(e, t[0], t[1]) ? t = [] : n > 2 && s(t[0], t[1], t[2]) && (t = [t[0]]), i(e, r(t, 1), [])
                }));
            e.exports = a
        },
        33259: function(e, t, n) {
            var r = n(45750),
                i = n(85973);
            e.exports = function(e, t, n) {
                var o = !0,
                    s = !0;
                if ("function" != typeof e) throw new TypeError("Expected a function");
                return i(n) && (o = "leading" in n ? !!n.leading : o, s = "trailing" in n ? !!n.trailing : s), r(e, t, {
                    leading: o,
                    maxWait: t,
                    trailing: s
                })
            }
        },
        90992: function(e, t, n) {
            var r = n(78746),
                i = 1 / 0;
            e.exports = function(e) {
                return e ? (e = r(e)) === i || e === -1 / 0 ? 17976931348623157e292 * (e < 0 ? -1 : 1) : e == e ? e : 0 : 0 === e ? e : 0
            }
        },
        25225: function(e, t, n) {
            var r = n(90992);
            e.exports = function(e) {
                var t = r(e),
                    n = t % 1;
                return t == t ? n ? t - n : t : 0
            }
        },
        78746: function(e, t, n) {
            var r = n(63349),
                i = n(85973),
                o = n(22945),
                s = /^[-+]0x[0-9a-f]+$/i,
                a = /^0b[01]+$/i,
                c = /^0o[0-7]+$/i,
                u = parseInt;
            e.exports = function(e) {
                if ("number" == typeof e) return e;
                if (o(e)) return NaN;
                if (i(e)) {
                    var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                    e = i(t) ? t + "" : t
                }
                if ("string" != typeof e) return 0 === e ? e : +e;
                e = r(e);
                var n = a.test(e);
                return n || c.test(e) ? u(e.slice(2), n ? 2 : 8) : s.test(e) ? NaN : +e
            }
        },
        57464: function(e, t, n) {
            var r = n(96051),
                i = n(5850);
            e.exports = function(e) {
                return r(e, i(e))
            }
        },
        59784: function(e, t, n) {
            var r = n(40314),
                i = n(88904),
                o = n(94569),
                s = n(84351),
                a = n(99747),
                c = n(22972),
                u = o((function(e) {
                    var t = c(e);
                    return a(t) && (t = void 0), s(r(e, 1, a, !0), i(t, 2))
                }));
            e.exports = u
        },
        91815: function(e, t, n) {
            var r = n(84351);
            e.exports = function(e) {
                return e && e.length ? r(e) : []
            }
        },
        86205: function(e, t, n) {
            var r = n(91096),
                i = n(94569),
                o = n(99747),
                s = i((function(e, t) {
                    return o(e) ? r(e, t) : []
                }));
            e.exports = s
        },
        9718: function(e, t) {
            "use strict";
            t.__esModule = !0;
            var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                return typeof e
            } : function(e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            };
            t.default = function(e, t) {
                return function i(o, s) {
                    if (e(o, s)) return !0;
                    if (Array.isArray(o)) return !(!Array.isArray(s) || o.length !== s.length || !o.every((function(e, t) {
                        return i(e, s[t])
                    })));
                    if (Array.isArray(s)) return !1;
                    if ("object" === (void 0 === o ? "undefined" : n(o))) {
                        if ("object" !== (void 0 === s ? "undefined" : n(s))) return !1;
                        var a = null === o,
                            c = null === s;
                        if (a || c) return a === c;
                        var u = Object.keys(o),
                            l = Object.keys(s);
                        if (u.length !== l.length) return !1;
                        var d = t ? i : e;
                        return !!u.every((function(e) {
                            return r(o, e) && r(s, e) && d(o[e], s[e])
                        }))
                    }
                    return !1
                }
            };
            var r = function(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }
        },
        72083: function(e, t, n) {
            "use strict";
            var r, i = n(84717),
                o = (r = i) && r.__esModule ? r : {
                    default: r
                };
            t.Z = o.default
        },
        57447: function(e, t) {
            "use strict";
            t.__esModule = !0, t.default = function(e, t) {
                var n = [];

                function r(e) {
                    var r = n.findIndex((function(n) {
                        return t(e, n.key)
                    }));
                    if (r > -1) {
                        var i = n[r];
                        return r > 0 && (n.slice(r, 1), n.unshift(i)), i.value
                    }
                }
                return {
                    get: r,
                    put: function(t, i) {
                        r(t) || (n.unshift({
                            key: t,
                            value: i
                        }), n.length > e && n.pop())
                    }
                }
            }
        },
        84717: function(e, t, n) {
            "use strict";
            t.__esModule = !0, t.default = function() {
                for (var e = 1, t = function(e, t) {
                        return e === t
                    }, n = !1, s = arguments.length, a = Array(s), c = 0; c < s; c++) a[c] = arguments[c];
                "number" == typeof a[0] && (e = a.shift());
                "function" == typeof a[0] ? t = a.shift() : void 0 === a[0] && a.shift();
                "boolean" == typeof a[0] && (n = a[0]);
                var u = function(e, t) {
                    return 1 === e ? (0, o.default)(t) : (0, i.default)(e, t)
                }(e, function(e, t) {
                    var n = t ? (0, r.default)(e, t) : e;
                    return function(e, t) {
                        if (e.length !== t.length) return !1;
                        for (var r = 0; r < e.length; r += 1)
                            if (!n(e[r], t[r])) return !1;
                        return !0
                    }
                }(t, n));
                return function(e) {
                    return function() {
                        for (var t = arguments.length, n = Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                        var i = u.get(n);
                        return void 0 === i && (i = e.apply(e, n), u.put(n, i)), i
                    }
                }
            };
            var r = s(n(9718)),
                i = s(n(57447)),
                o = s(n(84729));

            function s(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
        },
        84729: function(e, t) {
            "use strict";
            t.__esModule = !0, t.default = function(e) {
                var t = void 0;
                return {
                    get: function(n) {
                        if (t && e(n, t.key)) return t.value
                    },
                    put: function(e, n) {
                        t = {
                            key: e,
                            value: n
                        }
                    }
                }
            }
        },
        13970: function(e, t, n) {
            var r = "function" == typeof Map && Map.prototype,
                i = Object.getOwnPropertyDescriptor && r ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
                o = r && i && "function" == typeof i.get ? i.get : null,
                s = r && Map.prototype.forEach,
                a = "function" == typeof Set && Set.prototype,
                c = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
                u = a && c && "function" == typeof c.get ? c.get : null,
                l = a && Set.prototype.forEach,
                d = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
                h = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
                p = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
                f = Boolean.prototype.valueOf,
                m = Object.prototype.toString,
                g = Function.prototype.toString,
                _ = String.prototype.match,
                v = String.prototype.slice,
                y = String.prototype.replace,
                b = String.prototype.toUpperCase,
                I = String.prototype.toLowerCase,
                E = RegExp.prototype.test,
                S = Array.prototype.concat,
                w = Array.prototype.join,
                C = Array.prototype.slice,
                T = Math.floor,
                A = "function" == typeof BigInt ? BigInt.prototype.valueOf : null,
                R = Object.getOwnPropertySymbols,
                P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null,
                O = "function" == typeof Symbol && "object" == typeof Symbol.iterator,
                k = "function" == typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === O || "symbol") ? Symbol.toStringTag : null,
                N = Object.prototype.propertyIsEnumerable,
                D = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
                    return e.__proto__
                } : null);

            function M(e, t) {
                if (e === 1 / 0 || e === -1 / 0 || e != e || e && e > -1e3 && e < 1e3 || E.call(/e/, t)) return t;
                var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
                if ("number" == typeof e) {
                    var r = e < 0 ? -T(-e) : T(e);
                    if (r !== e) {
                        var i = String(r),
                            o = v.call(t, i.length + 1);
                        return y.call(i, n, "$&_") + "." + y.call(y.call(o, /([0-9]{3})/g, "$&_"), /_$/, "")
                    }
                }
                return y.call(t, n, "$&_")
            }
            var x = n(45503),
                L = x.custom,
                U = W(L) ? L : null;

            function F(e, t, n) {
                var r = "double" === (n.quoteStyle || t) ? '"' : "'";
                return r + e + r
            }

            function j(e) {
                return y.call(String(e), /"/g, "&quot;")
            }

            function q(e) {
                return !("[object Array]" !== G(e) || k && "object" == typeof e && k in e)
            }

            function H(e) {
                return !("[object RegExp]" !== G(e) || k && "object" == typeof e && k in e)
            }

            function W(e) {
                if (O) return e && "object" == typeof e && e instanceof Symbol;
                if ("symbol" == typeof e) return !0;
                if (!e || "object" != typeof e || !P) return !1;
                try {
                    return P.call(e), !0
                } catch (e) {}
                return !1
            }
            e.exports = function e(t, n, r, i) {
                var a = n || {};
                if (V(a, "quoteStyle") && "single" !== a.quoteStyle && "double" !== a.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
                if (V(a, "maxStringLength") && ("number" == typeof a.maxStringLength ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : null !== a.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
                var c = !V(a, "customInspect") || a.customInspect;
                if ("boolean" != typeof c && "symbol" !== c) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
                if (V(a, "indent") && null !== a.indent && "\t" !== a.indent && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
                if (V(a, "numericSeparator") && "boolean" != typeof a.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
                var m = a.numericSeparator;
                if (void 0 === t) return "undefined";
                if (null === t) return "null";
                if ("boolean" == typeof t) return t ? "true" : "false";
                if ("string" == typeof t) return $(t, a);
                if ("number" == typeof t) {
                    if (0 === t) return 1 / 0 / t > 0 ? "0" : "-0";
                    var b = String(t);
                    return m ? M(t, b) : b
                }
                if ("bigint" == typeof t) {
                    var E = String(t) + "n";
                    return m ? M(t, E) : E
                }
                var T = void 0 === a.depth ? 5 : a.depth;
                if (void 0 === r && (r = 0), r >= T && T > 0 && "object" == typeof t) return q(t) ? "[Array]" : "[Object]";
                var R = function(e, t) {
                    var n;
                    if ("\t" === e.indent) n = "\t";
                    else {
                        if (!("number" == typeof e.indent && e.indent > 0)) return null;
                        n = w.call(Array(e.indent + 1), " ")
                    }
                    return {
                        base: n,
                        prev: w.call(Array(t + 1), n)
                    }
                }(a, r);
                if (void 0 === i) i = [];
                else if (z(i, t) >= 0) return "[Circular]";

                function L(t, n, o) {
                    if (n && (i = C.call(i)).push(n), o) {
                        var s = {
                            depth: a.depth
                        };
                        return V(a, "quoteStyle") && (s.quoteStyle = a.quoteStyle), e(t, s, r + 1, i)
                    }
                    return e(t, a, r + 1, i)
                }
                if ("function" == typeof t && !H(t)) {
                    var B = function(e) {
                            if (e.name) return e.name;
                            var t = _.call(g.call(e), /^function\s*([\w$]+)/);
                            if (t) return t[1];
                            return null
                        }(t),
                        K = Z(t, L);
                    return "[Function" + (B ? ": " + B : " (anonymous)") + "]" + (K.length > 0 ? " { " + w.call(K, ", ") + " }" : "")
                }
                if (W(t)) {
                    var ee = O ? y.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : P.call(t);
                    return "object" != typeof t || O ? ee : Y(ee)
                }
                if (function(e) {
                        if (!e || "object" != typeof e) return !1;
                        if ("undefined" != typeof HTMLElement && e instanceof HTMLElement) return !0;
                        return "string" == typeof e.nodeName && "function" == typeof e.getAttribute
                    }(t)) {
                    for (var te = "<" + I.call(String(t.nodeName)), ne = t.attributes || [], re = 0; re < ne.length; re++) te += " " + ne[re].name + "=" + F(j(ne[re].value), "double", a);
                    return te += ">", t.childNodes && t.childNodes.length && (te += "..."), te += "</" + I.call(String(t.nodeName)) + ">"
                }
                if (q(t)) {
                    if (0 === t.length) return "[]";
                    var ie = Z(t, L);
                    return R && ! function(e) {
                        for (var t = 0; t < e.length; t++)
                            if (z(e[t], "\n") >= 0) return !1;
                        return !0
                    }(ie) ? "[" + X(ie, R) + "]" : "[ " + w.call(ie, ", ") + " ]"
                }
                if (function(e) {
                        return !("[object Error]" !== G(e) || k && "object" == typeof e && k in e)
                    }(t)) {
                    var oe = Z(t, L);
                    return "cause" in Error.prototype || !("cause" in t) || N.call(t, "cause") ? 0 === oe.length ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + w.call(oe, ", ") + " }" : "{ [" + String(t) + "] " + w.call(S.call("[cause]: " + L(t.cause), oe), ", ") + " }"
                }
                if ("object" == typeof t && c) {
                    if (U && "function" == typeof t[U] && x) return x(t, {
                        depth: T - r
                    });
                    if ("symbol" !== c && "function" == typeof t.inspect) return t.inspect()
                }
                if (function(e) {
                        if (!o || !e || "object" != typeof e) return !1;
                        try {
                            o.call(e);
                            try {
                                u.call(e)
                            } catch (e) {
                                return !0
                            }
                            return e instanceof Map
                        } catch (e) {}
                        return !1
                    }(t)) {
                    var se = [];
                    return s && s.call(t, (function(e, n) {
                        se.push(L(n, t, !0) + " => " + L(e, t))
                    })), Q("Map", o.call(t), se, R)
                }
                if (function(e) {
                        if (!u || !e || "object" != typeof e) return !1;
                        try {
                            u.call(e);
                            try {
                                o.call(e)
                            } catch (e) {
                                return !0
                            }
                            return e instanceof Set
                        } catch (e) {}
                        return !1
                    }(t)) {
                    var ae = [];
                    return l && l.call(t, (function(e) {
                        ae.push(L(e, t))
                    })), Q("Set", u.call(t), ae, R)
                }
                if (function(e) {
                        if (!d || !e || "object" != typeof e) return !1;
                        try {
                            d.call(e, d);
                            try {
                                h.call(e, h)
                            } catch (e) {
                                return !0
                            }
                            return e instanceof WeakMap
                        } catch (e) {}
                        return !1
                    }(t)) return J("WeakMap");
                if (function(e) {
                        if (!h || !e || "object" != typeof e) return !1;
                        try {
                            h.call(e, h);
                            try {
                                d.call(e, d)
                            } catch (e) {
                                return !0
                            }
                            return e instanceof WeakSet
                        } catch (e) {}
                        return !1
                    }(t)) return J("WeakSet");
                if (function(e) {
                        if (!p || !e || "object" != typeof e) return !1;
                        try {
                            return p.call(e), !0
                        } catch (e) {}
                        return !1
                    }(t)) return J("WeakRef");
                if (function(e) {
                        return !("[object Number]" !== G(e) || k && "object" == typeof e && k in e)
                    }(t)) return Y(L(Number(t)));
                if (function(e) {
                        if (!e || "object" != typeof e || !A) return !1;
                        try {
                            return A.call(e), !0
                        } catch (e) {}
                        return !1
                    }(t)) return Y(L(A.call(t)));
                if (function(e) {
                        return !("[object Boolean]" !== G(e) || k && "object" == typeof e && k in e)
                    }(t)) return Y(f.call(t));
                if (function(e) {
                        return !("[object String]" !== G(e) || k && "object" == typeof e && k in e)
                    }(t)) return Y(L(String(t)));
                if (! function(e) {
                        return !("[object Date]" !== G(e) || k && "object" == typeof e && k in e)
                    }(t) && !H(t)) {
                    var ce = Z(t, L),
                        ue = D ? D(t) === Object.prototype : t instanceof Object || t.constructor === Object,
                        le = t instanceof Object ? "" : "null prototype",
                        de = !ue && k && Object(t) === t && k in t ? v.call(G(t), 8, -1) : le ? "Object" : "",
                        he = (ue || "function" != typeof t.constructor ? "" : t.constructor.name ? t.constructor.name + " " : "") + (de || le ? "[" + w.call(S.call([], de || [], le || []), ": ") + "] " : "");
                    return 0 === ce.length ? he + "{}" : R ? he + "{" + X(ce, R) + "}" : he + "{ " + w.call(ce, ", ") + " }"
                }
                return String(t)
            };
            var B = Object.prototype.hasOwnProperty || function(e) {
                return e in this
            };

            function V(e, t) {
                return B.call(e, t)
            }

            function G(e) {
                return m.call(e)
            }

            function z(e, t) {
                if (e.indexOf) return e.indexOf(t);
                for (var n = 0, r = e.length; n < r; n++)
                    if (e[n] === t) return n;
                return -1
            }

            function $(e, t) {
                if (e.length > t.maxStringLength) {
                    var n = e.length - t.maxStringLength,
                        r = "... " + n + " more character" + (n > 1 ? "s" : "");
                    return $(v.call(e, 0, t.maxStringLength), t) + r
                }
                return F(y.call(y.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, K), "single", t)
            }

            function K(e) {
                var t = e.charCodeAt(0),
                    n = {
                        8: "b",
                        9: "t",
                        10: "n",
                        12: "f",
                        13: "r"
                    }[t];
                return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + b.call(t.toString(16))
            }

            function Y(e) {
                return "Object(" + e + ")"
            }

            function J(e) {
                return e + " { ? }"
            }

            function Q(e, t, n, r) {
                return e + " (" + t + ") {" + (r ? X(n, r) : w.call(n, ", ")) + "}"
            }

            function X(e, t) {
                if (0 === e.length) return "";
                var n = "\n" + t.prev + t.base;
                return n + w.call(e, "," + n) + "\n" + t.prev
            }

            function Z(e, t) {
                var n = q(e),
                    r = [];
                if (n) {
                    r.length = e.length;
                    for (var i = 0; i < e.length; i++) r[i] = V(e, i) ? t(e[i], e) : ""
                }
                var o, s = "function" == typeof R ? R(e) : [];
                if (O) {
                    o = {};
                    for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a]
                }
                for (var c in e) V(e, c) && (n && String(Number(c)) === c && c < e.length || O && o["$" + c] instanceof Symbol || (E.call(/[^\w$]/, c) ? r.push(t(c, e) + ": " + t(e[c], e)) : r.push(c + ": " + t(e[c], e))));
                if ("function" == typeof R)
                    for (var u = 0; u < s.length; u++) N.call(e, s[u]) && r.push("[" + t(s[u]) + "]: " + t(e[s[u]], e));
                return r
            }
        },
        52490: function(e) {
            "use strict";
            var t = String.prototype.replace,
                n = /%20/g,
                r = "RFC1738",
                i = "RFC3986";
            e.exports = {
                default: i,
                formatters: {
                    RFC1738: function(e) {
                        return t.call(e, n, "+")
                    },
                    RFC3986: function(e) {
                        return String(e)
                    }
                },
                RFC1738: r,
                RFC3986: i
            }
        },
        33348: function(e, t, n) {
            "use strict";
            var r = n(97530),
                i = n(18429),
                o = n(52490);
            e.exports = {
                formats: o,
                parse: i,
                stringify: r
            }
        },
        18429: function(e, t, n) {
            "use strict";
            var r = n(33422),
                i = Object.prototype.hasOwnProperty,
                o = Array.isArray,
                s = {
                    allowDots: !1,
                    allowPrototypes: !1,
                    allowSparse: !1,
                    arrayLimit: 20,
                    charset: "utf-8",
                    charsetSentinel: !1,
                    comma: !1,
                    decoder: r.decode,
                    delimiter: "&",
                    depth: 5,
                    ignoreQueryPrefix: !1,
                    interpretNumericEntities: !1,
                    parameterLimit: 1e3,
                    parseArrays: !0,
                    plainObjects: !1,
                    strictNullHandling: !1
                },
                a = function(e) {
                    return e.replace(/&#(\d+);/g, (function(e, t) {
                        return String.fromCharCode(parseInt(t, 10))
                    }))
                },
                c = function(e, t) {
                    return e && "string" == typeof e && t.comma && e.indexOf(",") > -1 ? e.split(",") : e
                },
                u = function(e, t, n, r) {
                    if (e) {
                        var o = n.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                            s = /(\[[^[\]]*])/g,
                            a = n.depth > 0 && /(\[[^[\]]*])/.exec(o),
                            u = a ? o.slice(0, a.index) : o,
                            l = [];
                        if (u) {
                            if (!n.plainObjects && i.call(Object.prototype, u) && !n.allowPrototypes) return;
                            l.push(u)
                        }
                        for (var d = 0; n.depth > 0 && null !== (a = s.exec(o)) && d < n.depth;) {
                            if (d += 1, !n.plainObjects && i.call(Object.prototype, a[1].slice(1, -1)) && !n.allowPrototypes) return;
                            l.push(a[1])
                        }
                        return a && l.push("[" + o.slice(a.index) + "]"),
                            function(e, t, n, r) {
                                for (var i = r ? t : c(t, n), o = e.length - 1; o >= 0; --o) {
                                    var s, a = e[o];
                                    if ("[]" === a && n.parseArrays) s = [].concat(i);
                                    else {
                                        s = n.plainObjects ? Object.create(null) : {};
                                        var u = "[" === a.charAt(0) && "]" === a.charAt(a.length - 1) ? a.slice(1, -1) : a,
                                            l = parseInt(u, 10);
                                        n.parseArrays || "" !== u ? !isNaN(l) && a !== u && String(l) === u && l >= 0 && n.parseArrays && l <= n.arrayLimit ? (s = [])[l] = i : "__proto__" !== u && (s[u] = i) : s = {
                                            0: i
                                        }
                                    }
                                    i = s
                                }
                                return i
                            }(l, t, n, r)
                    }
                };
            e.exports = function(e, t) {
                var n = function(e) {
                    if (!e) return s;
                    if (null !== e.decoder && void 0 !== e.decoder && "function" != typeof e.decoder) throw new TypeError("Decoder has to be a function.");
                    if (void 0 !== e.charset && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                    var t = void 0 === e.charset ? s.charset : e.charset;
                    return {
                        allowDots: void 0 === e.allowDots ? s.allowDots : !!e.allowDots,
                        allowPrototypes: "boolean" == typeof e.allowPrototypes ? e.allowPrototypes : s.allowPrototypes,
                        allowSparse: "boolean" == typeof e.allowSparse ? e.allowSparse : s.allowSparse,
                        arrayLimit: "number" == typeof e.arrayLimit ? e.arrayLimit : s.arrayLimit,
                        charset: t,
                        charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : s.charsetSentinel,
                        comma: "boolean" == typeof e.comma ? e.comma : s.comma,
                        decoder: "function" == typeof e.decoder ? e.decoder : s.decoder,
                        delimiter: "string" == typeof e.delimiter || r.isRegExp(e.delimiter) ? e.delimiter : s.delimiter,
                        depth: "number" == typeof e.depth || !1 === e.depth ? +e.depth : s.depth,
                        ignoreQueryPrefix: !0 === e.ignoreQueryPrefix,
                        interpretNumericEntities: "boolean" == typeof e.interpretNumericEntities ? e.interpretNumericEntities : s.interpretNumericEntities,
                        parameterLimit: "number" == typeof e.parameterLimit ? e.parameterLimit : s.parameterLimit,
                        parseArrays: !1 !== e.parseArrays,
                        plainObjects: "boolean" == typeof e.plainObjects ? e.plainObjects : s.plainObjects,
                        strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : s.strictNullHandling
                    }
                }(t);
                if ("" === e || null == e) return n.plainObjects ? Object.create(null) : {};
                for (var l = "string" == typeof e ? function(e, t) {
                        var n, u = {
                                __proto__: null
                            },
                            l = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
                            d = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit,
                            h = l.split(t.delimiter, d),
                            p = -1,
                            f = t.charset;
                        if (t.charsetSentinel)
                            for (n = 0; n < h.length; ++n) 0 === h[n].indexOf("utf8=") && ("utf8=%E2%9C%93" === h[n] ? f = "utf-8" : "utf8=%26%2310003%3B" === h[n] && (f = "iso-8859-1"), p = n, n = h.length);
                        for (n = 0; n < h.length; ++n)
                            if (n !== p) {
                                var m, g, _ = h[n],
                                    v = _.indexOf("]="),
                                    y = -1 === v ? _.indexOf("=") : v + 1; - 1 === y ? (m = t.decoder(_, s.decoder, f, "key"), g = t.strictNullHandling ? null : "") : (m = t.decoder(_.slice(0, y), s.decoder, f, "key"), g = r.maybeMap(c(_.slice(y + 1), t), (function(e) {
                                    return t.decoder(e, s.decoder, f, "value")
                                }))), g && t.interpretNumericEntities && "iso-8859-1" === f && (g = a(g)), _.indexOf("[]=") > -1 && (g = o(g) ? [g] : g), i.call(u, m) ? u[m] = r.combine(u[m], g) : u[m] = g
                            }
                        return u
                    }(e, n) : e, d = n.plainObjects ? Object.create(null) : {}, h = Object.keys(l), p = 0; p < h.length; ++p) {
                    var f = h[p],
                        m = u(f, l[f], n, "string" == typeof e);
                    d = r.merge(d, m, n)
                }
                return !0 === n.allowSparse ? d : r.compact(d)
            }
        },
        97530: function(e, t, n) {
            "use strict";
            var r = n(62538),
                i = n(33422),
                o = n(52490),
                s = Object.prototype.hasOwnProperty,
                a = {
                    brackets: function(e) {
                        return e + "[]"
                    },
                    comma: "comma",
                    indices: function(e, t) {
                        return e + "[" + t + "]"
                    },
                    repeat: function(e) {
                        return e
                    }
                },
                c = Array.isArray,
                u = Array.prototype.push,
                l = function(e, t) {
                    u.apply(e, c(t) ? t : [t])
                },
                d = Date.prototype.toISOString,
                h = o.default,
                p = {
                    addQueryPrefix: !1,
                    allowDots: !1,
                    charset: "utf-8",
                    charsetSentinel: !1,
                    delimiter: "&",
                    encode: !0,
                    encoder: i.encode,
                    encodeValuesOnly: !1,
                    format: h,
                    formatter: o.formatters[h],
                    indices: !1,
                    serializeDate: function(e) {
                        return d.call(e)
                    },
                    skipNulls: !1,
                    strictNullHandling: !1
                },
                f = {},
                m = function e(t, n, o, s, a, u, d, h, m, g, _, v, y, b, I, E) {
                    for (var S, w = t, C = E, T = 0, A = !1; void 0 !== (C = C.get(f)) && !A;) {
                        var R = C.get(t);
                        if (T += 1, void 0 !== R) {
                            if (R === T) throw new RangeError("Cyclic object value");
                            A = !0
                        }
                        void 0 === C.get(f) && (T = 0)
                    }
                    if ("function" == typeof h ? w = h(n, w) : w instanceof Date ? w = _(w) : "comma" === o && c(w) && (w = i.maybeMap(w, (function(e) {
                            return e instanceof Date ? _(e) : e
                        }))), null === w) {
                        if (a) return d && !b ? d(n, p.encoder, I, "key", v) : n;
                        w = ""
                    }
                    if ("string" == typeof(S = w) || "number" == typeof S || "boolean" == typeof S || "symbol" == typeof S || "bigint" == typeof S || i.isBuffer(w)) return d ? [y(b ? n : d(n, p.encoder, I, "key", v)) + "=" + y(d(w, p.encoder, I, "value", v))] : [y(n) + "=" + y(String(w))];
                    var P, O = [];
                    if (void 0 === w) return O;
                    if ("comma" === o && c(w)) b && d && (w = i.maybeMap(w, d)), P = [{
                        value: w.length > 0 ? w.join(",") || null : void 0
                    }];
                    else if (c(h)) P = h;
                    else {
                        var k = Object.keys(w);
                        P = m ? k.sort(m) : k
                    }
                    for (var N = s && c(w) && 1 === w.length ? n + "[]" : n, D = 0; D < P.length; ++D) {
                        var M = P[D],
                            x = "object" == typeof M && void 0 !== M.value ? M.value : w[M];
                        if (!u || null !== x) {
                            var L = c(w) ? "function" == typeof o ? o(N, M) : N : N + (g ? "." + M : "[" + M + "]");
                            E.set(t, T);
                            var U = r();
                            U.set(f, E), l(O, e(x, L, o, s, a, u, "comma" === o && b && c(w) ? null : d, h, m, g, _, v, y, b, I, U))
                        }
                    }
                    return O
                };
            e.exports = function(e, t) {
                var n, i = e,
                    u = function(e) {
                        if (!e) return p;
                        if (null !== e.encoder && void 0 !== e.encoder && "function" != typeof e.encoder) throw new TypeError("Encoder has to be a function.");
                        var t = e.charset || p.charset;
                        if (void 0 !== e.charset && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                        var n = o.default;
                        if (void 0 !== e.format) {
                            if (!s.call(o.formatters, e.format)) throw new TypeError("Unknown format option provided.");
                            n = e.format
                        }
                        var r = o.formatters[n],
                            i = p.filter;
                        return ("function" == typeof e.filter || c(e.filter)) && (i = e.filter), {
                            addQueryPrefix: "boolean" == typeof e.addQueryPrefix ? e.addQueryPrefix : p.addQueryPrefix,
                            allowDots: void 0 === e.allowDots ? p.allowDots : !!e.allowDots,
                            charset: t,
                            charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : p.charsetSentinel,
                            delimiter: void 0 === e.delimiter ? p.delimiter : e.delimiter,
                            encode: "boolean" == typeof e.encode ? e.encode : p.encode,
                            encoder: "function" == typeof e.encoder ? e.encoder : p.encoder,
                            encodeValuesOnly: "boolean" == typeof e.encodeValuesOnly ? e.encodeValuesOnly : p.encodeValuesOnly,
                            filter: i,
                            format: n,
                            formatter: r,
                            serializeDate: "function" == typeof e.serializeDate ? e.serializeDate : p.serializeDate,
                            skipNulls: "boolean" == typeof e.skipNulls ? e.skipNulls : p.skipNulls,
                            sort: "function" == typeof e.sort ? e.sort : null,
                            strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : p.strictNullHandling
                        }
                    }(t);
                "function" == typeof u.filter ? i = (0, u.filter)("", i) : c(u.filter) && (n = u.filter);
                var d, h = [];
                if ("object" != typeof i || null === i) return "";
                d = t && t.arrayFormat in a ? t.arrayFormat : t && "indices" in t ? t.indices ? "indices" : "repeat" : "indices";
                var f = a[d];
                if (t && "commaRoundTrip" in t && "boolean" != typeof t.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
                var g = "comma" === f && t && t.commaRoundTrip;
                n || (n = Object.keys(i)), u.sort && n.sort(u.sort);
                for (var _ = r(), v = 0; v < n.length; ++v) {
                    var y = n[v];
                    u.skipNulls && null === i[y] || l(h, m(i[y], y, f, g, u.strictNullHandling, u.skipNulls, u.encode ? u.encoder : null, u.filter, u.sort, u.allowDots, u.serializeDate, u.format, u.formatter, u.encodeValuesOnly, u.charset, _))
                }
                var b = h.join(u.delimiter),
                    I = !0 === u.addQueryPrefix ? "?" : "";
                return u.charsetSentinel && ("iso-8859-1" === u.charset ? I += "utf8=%26%2310003%3B&" : I += "utf8=%E2%9C%93&"), b.length > 0 ? I + b : ""
            }
        },
        33422: function(e, t, n) {
            "use strict";
            var r = n(52490),
                i = Object.prototype.hasOwnProperty,
                o = Array.isArray,
                s = function() {
                    for (var e = [], t = 0; t < 256; ++t) e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
                    return e
                }(),
                a = function(e, t) {
                    for (var n = t && t.plainObjects ? Object.create(null) : {}, r = 0; r < e.length; ++r) void 0 !== e[r] && (n[r] = e[r]);
                    return n
                };
            e.exports = {
                arrayToObject: a,
                assign: function(e, t) {
                    return Object.keys(t).reduce((function(e, n) {
                        return e[n] = t[n], e
                    }), e)
                },
                combine: function(e, t) {
                    return [].concat(e, t)
                },
                compact: function(e) {
                    for (var t = [{
                            obj: {
                                o: e
                            },
                            prop: "o"
                        }], n = [], r = 0; r < t.length; ++r)
                        for (var i = t[r], s = i.obj[i.prop], a = Object.keys(s), c = 0; c < a.length; ++c) {
                            var u = a[c],
                                l = s[u];
                            "object" == typeof l && null !== l && -1 === n.indexOf(l) && (t.push({
                                obj: s,
                                prop: u
                            }), n.push(l))
                        }
                    return function(e) {
                        for (; e.length > 1;) {
                            var t = e.pop(),
                                n = t.obj[t.prop];
                            if (o(n)) {
                                for (var r = [], i = 0; i < n.length; ++i) void 0 !== n[i] && r.push(n[i]);
                                t.obj[t.prop] = r
                            }
                        }
                    }(t), e
                },
                decode: function(e, t, n) {
                    var r = e.replace(/\+/g, " ");
                    if ("iso-8859-1" === n) return r.replace(/%[0-9a-f]{2}/gi, unescape);
                    try {
                        return decodeURIComponent(r)
                    } catch (e) {
                        return r
                    }
                },
                encode: function(e, t, n, i, o) {
                    if (0 === e.length) return e;
                    var a = e;
                    if ("symbol" == typeof e ? a = Symbol.prototype.toString.call(e) : "string" != typeof e && (a = String(e)), "iso-8859-1" === n) return escape(a).replace(/%u[0-9a-f]{4}/gi, (function(e) {
                        return "%26%23" + parseInt(e.slice(2), 16) + "%3B"
                    }));
                    for (var c = "", u = 0; u < a.length; ++u) {
                        var l = a.charCodeAt(u);
                        45 === l || 46 === l || 95 === l || 126 === l || l >= 48 && l <= 57 || l >= 65 && l <= 90 || l >= 97 && l <= 122 || o === r.RFC1738 && (40 === l || 41 === l) ? c += a.charAt(u) : l < 128 ? c += s[l] : l < 2048 ? c += s[192 | l >> 6] + s[128 | 63 & l] : l < 55296 || l >= 57344 ? c += s[224 | l >> 12] + s[128 | l >> 6 & 63] + s[128 | 63 & l] : (u += 1, l = 65536 + ((1023 & l) << 10 | 1023 & a.charCodeAt(u)), c += s[240 | l >> 18] + s[128 | l >> 12 & 63] + s[128 | l >> 6 & 63] + s[128 | 63 & l])
                    }
                    return c
                },
                isBuffer: function(e) {
                    return !(!e || "object" != typeof e) && !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
                },
                isRegExp: function(e) {
                    return "[object RegExp]" === Object.prototype.toString.call(e)
                },
                maybeMap: function(e, t) {
                    if (o(e)) {
                        for (var n = [], r = 0; r < e.length; r += 1) n.push(t(e[r]));
                        return n
                    }
                    return t(e)
                },
                merge: function e(t, n, r) {
                    if (!n) return t;
                    if ("object" != typeof n) {
                        if (o(t)) t.push(n);
                        else {
                            if (!t || "object" != typeof t) return [t, n];
                            (r && (r.plainObjects || r.allowPrototypes) || !i.call(Object.prototype, n)) && (t[n] = !0)
                        }
                        return t
                    }
                    if (!t || "object" != typeof t) return [t].concat(n);
                    var s = t;
                    return o(t) && !o(n) && (s = a(t, r)), o(t) && o(n) ? (n.forEach((function(n, o) {
                        if (i.call(t, o)) {
                            var s = t[o];
                            s && "object" == typeof s && n && "object" == typeof n ? t[o] = e(s, n, r) : t.push(n)
                        } else t[o] = n
                    })), t) : Object.keys(n).reduce((function(t, o) {
                        var s = n[o];
                        return i.call(t, o) ? t[o] = e(t[o], s, r) : t[o] = s, t
                    }), s)
                }
            }
        },
        36107: function(e, t, n) {
            "use strict";

            function r(e, t) {
                return e === t
            }

            function i(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r,
                    n = null,
                    i = null;
                return function() {
                    return function(e, t, n) {
                        if (null === t || null === n || t.length !== n.length) return !1;
                        for (var r = t.length, i = 0; i < r; i++)
                            if (!e(t[i], n[i])) return !1;
                        return !0
                    }(t, n, arguments) || (i = e.apply(null, arguments)), n = arguments, i
                }
            }

            function o(e) {
                for (var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                return function() {
                    for (var t = arguments.length, r = Array(t), i = 0; i < t; i++) r[i] = arguments[i];
                    var o = 0,
                        s = r.pop(),
                        a = function(e) {
                            var t = Array.isArray(e[0]) ? e[0] : e;
                            if (!t.every((function(e) {
                                    return "function" == typeof e
                                }))) {
                                var n = t.map((function(e) {
                                    return typeof e
                                })).join(", ");
                                throw new Error("Selector creators expect all input-selectors to be functions, instead received the following types: [" + n + "]")
                            }
                            return t
                        }(r),
                        c = e.apply(void 0, [function() {
                            return o++, s.apply(null, arguments)
                        }].concat(n)),
                        u = e((function() {
                            for (var e = [], t = a.length, n = 0; n < t; n++) e.push(a[n].apply(null, arguments));
                            return c.apply(null, e)
                        }));
                    return u.resultFunc = s, u.dependencies = a, u.recomputations = function() {
                        return o
                    }, u.resetRecomputations = function() {
                        return o = 0
                    }, u
                }
            }
            n.d(t, {
                PW: function() {
                    return i
                },
                wN: function() {
                    return o
                },
                P1: function() {
                    return s
                }
            });
            var s = o(i)
        },
        62538: function(e, t, n) {
            "use strict";
            var r = n(91528),
                i = n(47737),
                o = n(13970),
                s = r("%TypeError%"),
                a = r("%WeakMap%", !0),
                c = r("%Map%", !0),
                u = i("WeakMap.prototype.get", !0),
                l = i("WeakMap.prototype.set", !0),
                d = i("WeakMap.prototype.has", !0),
                h = i("Map.prototype.get", !0),
                p = i("Map.prototype.set", !0),
                f = i("Map.prototype.has", !0),
                m = function(e, t) {
                    for (var n, r = e; null !== (n = r.next); r = n)
                        if (n.key === t) return r.next = n.next, n.next = e.next, e.next = n, n
                };
            e.exports = function() {
                var e, t, n, r = {
                    assert: function(e) {
                        if (!r.has(e)) throw new s("Side channel does not contain " + o(e))
                    },
                    get: function(r) {
                        if (a && r && ("object" == typeof r || "function" == typeof r)) {
                            if (e) return u(e, r)
                        } else if (c) {
                            if (t) return h(t, r)
                        } else if (n) return function(e, t) {
                            var n = m(e, t);
                            return n && n.value
                        }(n, r)
                    },
                    has: function(r) {
                        if (a && r && ("object" == typeof r || "function" == typeof r)) {
                            if (e) return d(e, r)
                        } else if (c) {
                            if (t) return f(t, r)
                        } else if (n) return function(e, t) {
                            return !!m(e, t)
                        }(n, r);
                        return !1
                    },
                    set: function(r, i) {
                        a && r && ("object" == typeof r || "function" == typeof r) ? (e || (e = new a), l(e, r, i)) : c ? (t || (t = new c), p(t, r, i)) : (n || (n = {
                            key: {},
                            next: null
                        }), function(e, t, n) {
                            var r = m(e, t);
                            r ? r.value = n : e.next = {
                                key: t,
                                next: e.next,
                                value: n
                            }
                        }(n, r, i))
                    }
                };
                return r
            }
        },
        92435: function(e, t, n) {
            "use strict";
            n.d(t, {
                Z: function() {
                    return r
                }
            }), e = n.hmd(e);
            var r = function(e) {
                var t, n = e.Symbol;
                return "function" == typeof n ? n.observable ? t = n.observable : (t = n("observable"), n.observable = t) : t = "@@observable", t
            }("undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n.g ? n.g : e)
        },
        45299: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                MimeTypes: function() {
                    return o
                },
                MessageTypes: function() {
                    return s
                },
                MessageDirections: function() {
                    return a
                },
                MessageSendStatus: function() {
                    return r
                },
                MessageOrientation: function() {
                    return c
                },
                SdkExperiment: function() {
                    return i
                },
                experiments: function() {
                    return i
                },
                MediaProviders: function() {
                    return l
                },
                MessagePositionInGroup: function() {
                    return d
                },
                HistorySinceRealtimeConnectionWasEstablished: function() {
                    return h
                },
                IndicationEvent: function() {
                    return u
                },
                FetchChatroomsPageSizeDefaultValue: function() {
                    return p
                },
                FetchChatroomsPageSizeDefaultValueInt: function() {
                    return f
                },
                FetchRoomMessagesPageSize: function() {
                    return m
                },
                STAR_LABEL_ID: function() {
                    return g
                }
            });
            var r, i, o = {
                    Image: "uri/image",
                    PlainText: "text/plain",
                    File: "uri/file"
                },
                s = {
                    Message: "message",
                    Templates: {
                        Standard: "template/standard-event",
                        Form: "template/form",
                        Minimal: "template/minimal",
                        Custom: "template/custom",
                        System: "template/system",
                        Unsupported: "template/unsupported",
                        Deleted: "template/deleted"
                    }
                },
                a = {
                    Outgoing: "right",
                    Incoming: "left",
                    System: "center"
                },
                c = {
                    Portrait: "portrait",
                    Landscape: "landscape"
                };
            ! function(e) {
                e.SENT = "SENT", e.SENDING = "SENDING", e.FAILED = "FAILED"
            }(r || (r = {})),
            function(e) {
                e.CrmmChatRenderOfflineActivity = "specs.woa.CrmmChatRenderOfflineActivity", e.CrmmChatShowCartIndicator = "specs.woa.CrmmChatShowCartIndicator", e.UnseenMessagesButton = "specs.chat.UnseenMessagesButton", e.AvailabilityHours = "specs.chat.AvailabilityHours", e.LazyLoadEmojiPanel = "specs.chat.LazyLoadEmojiPanel", e.UxEnhacements = "specs.chat.UxEnhacements", e.ShowCTAButtonForOldDataFormat = "specs.com.ShowCTAButtonForOldDataFormat", e.ChatDebugMeasureTimeToPush = "specs.woa.ChatDebugMeasureTimeToPush", e.EnrichedChatroom = "specs.chat.ChatroomParticipants", e.NoHistoryOnRealtimeConnect = "specs.chat.NoHistoryOnRealtimeConnect", e.FetchChatroomsPageSize = "specs.chat.FetchChatroomsPageSize", e.FirebaseAtomicServerTime = "specs.chat.FirebaseAtomicServerTime", e.DragNDropUpload = "specs.chat.DragNDropUpload", e.DragNDropUploadInbox = "specs.chat.DragNDropUploadInbox", e.MoveSearchToInbox = "specs.chat.UseNewSearchAPIMobile", e.PresenceNewConvention = "specs.chat.PresenceNewConvention", e.FetchMessageErrorIndication = "specs.chat.InboxFetchMessageErrorIndication"
            }(i || (i = {}));
            var u, l = {
                    WIX_MEDIA: "WixMedia",
                    WIX_MEDIA_PUBLIC: "WixMediaPublic"
                },
                d = {
                    START: "start",
                    MIDDLE: "middle",
                    END: "end",
                    SINGLE: "single"
                },
                h = 3e4,
                p = "30",
                f = parseInt(p),
                m = 50;
            ! function(e) {
                e.SENT = "Sent", e.SEEN = "Seen", e.FAILED = "Failed", e.DELIVERED = "Delivered"
            }(u || (u = {}));
            var g = "7553d8c6-0ba2-424e-8e81-d1f7ea14bfe4"
        },
        90950: function(e, t) {
            "use strict";
            var n = function() {
                function e(e) {
                    this._mimeType = e.mimeType, this._data = e.data
                }
                return Object.defineProperty(e.prototype, "mimeType", {
                    get: function() {
                        return this._mimeType
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "data", {
                    get: function() {
                        return this._data
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }();
            t.Z = n
        },
        77142: function(e, t, n) {
            "use strict";
            n.d(t, {
                Z: function() {
                    return m
                }
            });
            var r = n(92712),
                i = n(45299),
                o = n(90950),
                s = n(86834),
                a = n.n(s);

            function c(e) {
                switch (e.type) {
                    case i.MessageTypes.Templates.Form:
                        var t = e.templateData,
                            n = t.title,
                            r = t.text,
                            o = t.fields.reduce((function(e, t) {
                                return e.concat((n = t, a()(n.name) || a()(n.value) ? "" : n.name + "\n" + n.value + "\n"));
                                var n
                            }), "");
                        return ((a()(n) ? "" : n + "\n") + (a()(r) ? "" : r + "\n") + o).trim();
                    case i.MessageTypes.Message:
                        return e.messageParts[0].data.text;
                    default:
                        return null
                }
            }
            var u = n(31454),
                l = n.n(u),
                d = n(35810);
            var h = function(e) {
                    if ((null == e ? void 0 : e.data) && e.data.length > 0) return "button" === e.data[0].mimeType ? e.data[0].data.cta : void 0
                },
                p = function() {
                    function e(e, t, n, i, s) {
                        void 0 === t && (t = {}), this._messageParts = (e.data || []).map((function(e) {
                            return new o.Z(e)
                        })), this._transit = t;
                        var a = e.summary ? e.summary.slice(0, 250) : "";
                        this._indications = n, this._dto = (0, r.__assign)((0, r.__assign)({}, e), {
                            summary: a
                        }), this._groupPosition = i, this._showSentTime = s, this.messageType = e.messageType, this.isEphemeral = e.isEphemeral || !1, this.messageTypeVersion = e.messageTypeVersion, this.data = e.data
                    }
                    return Object.defineProperty(e.prototype, "indications", {
                        get: function() {
                            return this._indications
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "dto", {
                        get: function() {
                            return this._dto
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isSilent", {
                        get: function() {
                            return this._dto.isSilent
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "cta", {
                        get: function() {
                            return h(this._dto)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "sequence", {
                        get: function() {
                            return this._dto.sequence
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "summary", {
                        get: function() {
                            return this._dto.summary
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "type", {
                        get: function() {
                            return this._dto.messageType
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "messageParts", {
                        get: function() {
                            return this._messageParts
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "mimeTypes", {
                        get: function() {
                            return this._messageParts.map((function(e) {
                                return e.mimeType
                            }))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "templateData", {
                        get: function() {
                            return this._dto.templateData
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "textToCopy", {
                        get: function() {
                            return c(this)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "sender", {
                        get: function() {
                            return this._dto.sender
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "senderDisplayData", {
                        get: function() {
                            return this._dto.senderDisplayData
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "id", {
                        get: function() {
                            return this._dto.id
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "chatroomId", {
                        get: function() {
                            return this._dto.chatroomId
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isTemplate", {
                        get: function() {
                            return Object.values(i.MessageTypes.Templates).includes(this._dto.messageType)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "transit", {
                        get: function() {
                            return this._transit
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isPending", {
                        get: function() {
                            return !!this._transit.isPending
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "createdAt", {
                        get: function() {
                            return this._dto.createdAt
                        },
                        set: function(e) {
                            this._dto.createdAt = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "age", {
                        get: function() {
                            return d.o(this.createdAt)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "createdAtFormatted", {
                        get: function() {
                            return d.$(this.createdAt)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "groupPosition", {
                        get: function() {
                            return this._groupPosition
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "showSentTime", {
                        get: function() {
                            return this._showSentTime
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "badges", {
                        get: function() {
                            return this._dto.badges
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "deliveryMethods", {
                        get: function() {
                            return this._dto.deliveryMethods
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "title", {
                        get: function() {
                            return this._dto.title
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "originMethod", {
                        get: function() {
                            return this._dto.originMethod
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(),
                f = function(e) {
                    var t = e.id,
                        n = e.userId,
                        r = e.userType,
                        i = void 0 === r ? "user" : r,
                        o = e.pluginName,
                        s = e.mimeType,
                        a = e.data,
                        c = void 0 === a ? {} : a,
                        u = e.chatroomId,
                        d = e.summary,
                        h = e.senderDisplayData,
                        p = e.deliveryMethods,
                        f = void 0 === p ? [] : p,
                        m = e.badges,
                        g = void 0 === m ? [] : m,
                        _ = e.isEphemeral,
                        v = void 0 !== _ && _,
                        y = e.isSilent,
                        b = void 0 !== y && y,
                        I = e.title,
                        E = e.originMethod,
                        S = e.appId;
                    return {
                        isAutomated: !1,
                        deliveryMethods: f,
                        badges: g,
                        isEphemeral: v,
                        isSilent: b,
                        sequence: 0,
                        id: t || l()(),
                        chatroomId: u,
                        summary: d,
                        createdAt: (new Date).getTime(),
                        messageType: "message",
                        messageTypeVersion: 1,
                        sender: n ? {
                            type: i,
                            userId: n
                        } : void 0,
                        senderDisplayData: h,
                        pluginName: o,
                        templateData: void 0,
                        title: I,
                        data: [{
                            mimeType: s,
                            data: c
                        }],
                        visibleBy: "EVERYONE",
                        originMethod: E,
                        appId: S
                    }
                };
            p.fromText = function(e) {
                var t = e.text,
                    n = e.id,
                    r = e.summary,
                    o = e.userId,
                    s = e.userType,
                    a = e.pluginName,
                    c = e.chatroomId,
                    u = e.transit,
                    l = e.deliveryMethods,
                    d = e.badges,
                    h = e.isEphemeral,
                    m = e.isSilent,
                    g = e.title,
                    _ = e.originMethod,
                    v = e.appId,
                    y = f({
                        id: n,
                        userId: o,
                        pluginName: a,
                        summary: r,
                        userType: s,
                        mimeType: i.MimeTypes.PlainText,
                        data: {
                            text: t
                        },
                        chatroomId: c,
                        deliveryMethods: l,
                        badges: d,
                        isEphemeral: h,
                        isSilent: m,
                        title: g,
                        originMethod: _,
                        appId: v
                    });
                return new p(y, u)
            }, p.fromImage = function(e) {
                var t = e.id,
                    n = e.uri,
                    r = e.mediaFileId,
                    o = e.width,
                    s = e.height,
                    a = e.fileName,
                    c = e.fileSize,
                    u = e.mediaProvider,
                    l = e.userId,
                    d = e.pluginName,
                    h = e.chatroomId,
                    m = e.transit,
                    g = e.summary,
                    _ = e.deliveryMethods,
                    v = e.badges;
                return new p(f({
                    id: t,
                    summary: g,
                    userId: l,
                    pluginName: d,
                    mimeType: i.MimeTypes.Image,
                    data: {
                        uri: n,
                        mediaFileId: r,
                        width: o,
                        height: s,
                        fileName: a,
                        fileSize: c,
                        mediaProvider: u
                    },
                    chatroomId: h,
                    deliveryMethods: _,
                    badges: v
                }), m)
            }, p.fromFile = function(e) {
                var t = e.id,
                    n = e.uri,
                    r = e.mediaFileId,
                    o = e.width,
                    s = e.height,
                    a = e.fileName,
                    c = e.fileSize,
                    u = e.type,
                    l = e.mediaProvider,
                    d = e.userId,
                    h = e.pluginName,
                    m = e.chatroomId,
                    g = e.transit,
                    _ = e.summary,
                    v = e.deliveryMethods,
                    y = e.badges;
                return new p(f({
                    id: t,
                    summary: _,
                    userId: d,
                    pluginName: h,
                    mimeType: i.MimeTypes.File,
                    data: {
                        uri: n,
                        mediaFileId: r,
                        width: o,
                        height: s,
                        fileName: a,
                        fileSize: c,
                        type: u,
                        mediaProvider: l
                    },
                    chatroomId: m,
                    deliveryMethods: v,
                    badges: y
                }), g)
            }, p.fromData = function(e) {
                var t = e.data,
                    n = e.transit,
                    r = e.userId,
                    o = e.pluginName,
                    s = e.chatroomId,
                    a = e.summary,
                    c = e.userType,
                    u = e.deliveryMethods,
                    l = e.badges,
                    d = e.title,
                    h = e.originMethod;
                if (t) {
                    if (t.text) return p.fromText({
                        text: t.text,
                        summary: a,
                        id: t.id,
                        userId: r,
                        userType: c,
                        pluginName: o,
                        chatroomId: s,
                        transit: n,
                        deliveryMethods: u,
                        badges: l,
                        title: d,
                        originMethod: h
                    });
                    if (t.image) {
                        var m = t.image,
                            g = m.mediaFileId,
                            _ = m.width,
                            v = m.height,
                            y = m.fileName,
                            b = m.fileSize,
                            I = m.mediaProvider;
                        return p.fromImage({
                            id: t.id,
                            uri: t.image.uri || t.image.imageUri,
                            mediaFileId: g,
                            width: _,
                            height: v,
                            fileName: y,
                            fileSize: b,
                            mediaProvider: I,
                            summary: a,
                            userId: r,
                            userType: c,
                            pluginName: o,
                            chatroomId: s,
                            transit: n,
                            deliveryMethods: u,
                            badges: l
                        })
                    }
                }
                return new p(f({
                    id: t.id,
                    userId: r,
                    pluginName: o,
                    mimeType: i.MimeTypes.Image,
                    chatroomId: s,
                    summary: "",
                    deliveryMethods: u,
                    badges: l
                }))
            }, p.fromTemplate = function(e) {
                var t = e.userId,
                    n = e.userType,
                    r = void 0 === n ? "user" : n,
                    i = e.pluginName,
                    o = e.chatroomId,
                    s = e.messageType,
                    a = e.templateData,
                    c = e.summary,
                    u = void 0 === c ? "" : c,
                    d = e.sender,
                    h = e.deliveryMethods,
                    f = void 0 === h ? [] : h,
                    m = e.badges,
                    g = {
                        isAutomated: !1,
                        deliveryMethods: f,
                        badges: void 0 === m ? [] : m,
                        isEphemeral: !1,
                        isSilent: !1,
                        sequence: 0,
                        id: l()(),
                        chatroomId: o,
                        summary: u,
                        createdAt: (new Date).getTime(),
                        messageType: s,
                        messageTypeVersion: 1,
                        sender: d || (t ? {
                            type: r,
                            userId: t
                        } : void 0),
                        pluginName: i,
                        templateData: a.toJSON ? a.toJSON() : a,
                        data: [],
                        visibleBy: "EVERYONE"
                    };
                return new p(g)
            }, p.buildMessage = function(e) {
                var t = e.messageData,
                    n = e.chatroomId,
                    r = e.userId,
                    o = e.summary,
                    s = e.deliveryMethods,
                    a = void 0 === s ? [] : s,
                    c = e.badges,
                    u = void 0 === c ? [] : c,
                    l = e.title,
                    d = e.originMethod;
                if (t.type === i.MessageTypes.Message) return p.fromData({
                    data: t.data,
                    userId: r,
                    chatroomId: n,
                    summary: o,
                    deliveryMethods: a,
                    badges: u,
                    title: l,
                    originMethod: d
                });
                if (t.type === i.MessageTypes.Templates.Standard || t.type === i.MessageTypes.Templates.Custom) return p.fromTemplate({
                    templateData: t.templateData,
                    userId: r,
                    chatroomId: n,
                    messageType: t.type,
                    summary: o,
                    deliveryMethods: a,
                    badges: u
                });
                throw Error("Unable to build message of type " + t.type)
            };
            var m = p
        },
        79750: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                Button: function() {
                    return y
                },
                ChatRoom: function() {
                    return N
                },
                ChatSdkError: function() {
                    return w
                },
                Constants: function() {
                    return l
                },
                CustomTemplateData: function() {
                    return E
                },
                DeliveryMethodId: function() {
                    return i
                },
                DomainTypes: function() {
                    return u
                },
                IMessageTypes: function() {
                    return s
                },
                Message: function() {
                    return _.Z
                },
                MessageGroupingService: function() {
                    return A
                },
                MessageIndicationsService: function() {
                    return r
                },
                MessagePart: function() {
                    return b.Z
                },
                OfflineChannelId: function() {
                    return a
                },
                SdkExperiment: function() {
                    return l.SdkExperiment
                },
                StandardTemplateData: function() {
                    return I
                },
                Types: function() {
                    return o
                },
                UNREAD_CHATROOM_IDS_COUNT_LIMIT_PER_PARTICIPANT: function() {
                    return c
                },
                chatEventEmitter: function() {
                    return j.CI
                },
                chatSdk: function() {
                    return so
                }
            });
            var r = {};
            n.r(r), n.d(r, {
                getSummarizedIndicationsForPrivateChat: function() {
                    return m
                }
            });
            var i, o = n(8075);
            ! function(e) {
                e.Chat = "Chat", e.Email = "Email", e.Facebook = "Facebook", e.SMS = "SMS", e.Whatsapp = "Whatsapp", e.Phone = "Phone", e.Instagram = "Instagram"
            }(i || (i = {}));
            var s, a, c = 100;
            ! function(e) {
                e.message = "message", e.template_standard_event = "template/standard-event", e.template_minimal = "template/minimal", e.template_form = "template/form", e.template_custom = "template/custom", e.template_system = "template/system", e.template_unsupported = "template/unsupported", e.template_deleted = "template/deleted"
            }(s || (s = {})),
            function(e) {
                e.Email = "Email", e.Facebook = "Facebook", e.Instagram = "Instagram", e.SMS = "SMS", e.Whatsapp = "Whatsapp", e.Phone = "Phone"
            }(a || (a = {}));
            var u = n(20880),
                l = n(45299),
                d = n(20520),
                h = n.n(d),
                p = n(86834),
                f = n.n(p),
                m = function(e) {
                    if (!e) return null;
                    var t = h()(e.details, (function(e, t) {
                        return g(t, e) ? {
                            event: l.IndicationEvent.SEEN,
                            method: t.method
                        } : e
                    }), {});
                    return f()(t) ? null : t
                },
                g = function(e, t) {
                    return e.event === l.IndicationEvent.SEEN && t.event !== l.IndicationEvent.SEEN
                },
                _ = n(77142),
                v = n(92712),
                y = function() {
                    function e(e) {
                        this.dto = (0, v.__assign)({}, e)
                    }
                    return Object.defineProperty(e.prototype, "cta", {
                        get: function() {
                            return this.dto.cta
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "payload", {
                        get: function() {
                            return this.dto.payload
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "text", {
                        get: function() {
                            return this.dto.text
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "type", {
                        get: function() {
                            return this.dto.type
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.buildButton = function(t) {
                        return new e(t)
                    }, e
                }(),
                b = n(90950),
                I = function() {
                    function e(e) {
                        var t = e.title,
                            n = e.lines,
                            r = e.buttons,
                            i = e.image,
                            o = e.orientation,
                            s = void 0 === o ? l.MessageOrientation.Landscape : o;
                        this._dto = {
                            title: t,
                            lines: n,
                            buttons: r,
                            image: i,
                            orientation: s
                        }
                    }
                    return Object.defineProperty(e.prototype, "title", {
                        get: function() {
                            return this._dto.title
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "lines", {
                        get: function() {
                            return this._dto.lines
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "buttons", {
                        get: function() {
                            return this._dto.buttons
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "image", {
                        get: function() {
                            return this._dto.image
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "orientation", {
                        get: function() {
                            return this._dto.orientation
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.toJSON = function() {
                        return {
                            title: this.title,
                            image: this.image,
                            lines: this.lines,
                            buttons: this.buttons,
                            orientation: this.orientation
                        }
                    }, e
                }(),
                E = function() {
                    function e(e) {
                        var t = e.appName,
                            n = e.appData;
                        this._appName = t, this._appData = n
                    }
                    return Object.defineProperty(e.prototype, "appName", {
                        get: function() {
                            return this._appName
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "appData", {
                        get: function() {
                            return this._appData
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.toJSON = function() {
                        return {
                            appName: this.appName,
                            appData: this.appData
                        }
                    }, e
                }(),
                S = function(e) {
                    function t(n, r) {
                        var i, o, s, a, c, u, l, d = e.call(this, r) || this;
                        Object.setPrototypeOf(d, t.prototype), d._error = n, d.cause = n, d._type = r;
                        var h = (null === (i = n.config) || void 0 === i ? void 0 : i.url) || (null === (o = n.request) || void 0 === o ? void 0 : o.url) || (null === (a = null === (s = null == n ? void 0 : n.response) || void 0 === s ? void 0 : s.config) || void 0 === a ? void 0 : a.url),
                            p = h && h.split("?")[0],
                            f = p ? p.replace(/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/, "{id}") : "General",
                            m = null === (c = null == n ? void 0 : n.response) || void 0 === c ? void 0 : c.status;
                        return d._requestId = (null === (u = null == n ? void 0 : n.response) || void 0 === u ? void 0 : u.headers) && (null === (l = null == n ? void 0 : n.response) || void 0 === l ? void 0 : l.headers["x-wix-request-id"]), d.message = "Chat SDK Error of name '" + f + "'" + (m ? " " + m : ""), d._fingerprint = d.message, d
                    }
                    return (0, v.__extends)(t, e), Object.defineProperty(t.prototype, "isHttpError", {
                        get: function() {
                            return this._type === t.TYPES.HTTP_REQUEST
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fingerprint", {
                        get: function() {
                            return this._fingerprint
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "requestId", {
                        get: function() {
                            return this._requestId
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "httpError", {
                        get: function() {
                            if (this.isHttpError) {
                                if (this._error.response) {
                                    var e = this._error.response,
                                        t = e.config,
                                        n = e.data,
                                        r = e.status;
                                    return {
                                        method: t && t.method.toUpperCase(),
                                        url: null == t ? void 0 : t.url,
                                        status: r,
                                        data: n,
                                        error: this._error
                                    }
                                }
                                if (this._error.request) {
                                    var i = this._error,
                                        o = (t = i.config, i.request);
                                    return {
                                        method: (null == t ? void 0 : t.method) && t.method.toUpperCase(),
                                        url: null == t ? void 0 : t.url,
                                        status: 0,
                                        data: o,
                                        error: this._error
                                    }
                                }
                                return {
                                    method: (null == (t = this._error.config) ? void 0 : t.method) && t.method.toUpperCase(),
                                    url: null == t ? void 0 : t.url,
                                    status: 0,
                                    data: "no response/request",
                                    error: this._error
                                }
                            }
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "is401Error", {
                        get: function() {
                            return this.isHttpError && 401 === this.httpError.status
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t, "TYPES", {
                        get: function() {
                            return {
                                HTTP_REQUEST: "http-error"
                            }
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(Error),
                w = S,
                C = n(72083),
                T = function(e) {
                    var t = e.message,
                        n = e.groupPosition,
                        r = e.showSentTime,
                        i = Object.assign({}, t.dto),
                        o = Object.assign({}, t.transit);
                    return new _.Z(i, o, t.indications, n, r)
                };
            T = (0, C.Z)(500, (function(e, t) {
                return e.message === t.message && e.groupPosition === t.groupPosition && e.showSentTime === t.showSentTime
            }))(T);
            var A = function() {
                function e(e, t) {
                    this._thresholdMillis = 60 * (e || 180) * 1e3, this._lastReadSequence = t
                }
                return e.prototype.setLastReadSequence = function(e) {
                    this._lastReadSequence = e
                }, e.prototype.addGroups = function(e) {
                    var t = this;
                    return e.map((function(n, r) {
                        var i = t._strategy(e[r - 1], n, e[r + 1]),
                            o = i.groupPosition,
                            s = i.showSentTime;
                        return T({
                            message: n,
                            groupPosition: o,
                            showSentTime: s
                        })
                    }))
                }, e.prototype.getPartsGrouping = function(e) {
                    var t = this,
                        n = e.messageParts.length,
                        r = e.groupPosition,
                        i = e.showSentTime;
                    return e.messageParts.map((function(e, o) {
                        return {
                            groupPosition: t._classifyPart(r, o, n),
                            showSentTime: t._showPartSentTime(i, o)
                        }
                    }))
                }, e.prototype.isFirstMessage = function(e) {
                    return e.groupPosition === l.MessagePositionInGroup.SINGLE || e.groupPosition === l.MessagePositionInGroup.START
                }, e.prototype._classifyPart = function(e, t, n) {
                    return 1 === n ? e : this._isFirstPartOfStartingMessage(t, e) ? l.MessagePositionInGroup.START : this._isLastPartOfClosingMessage(t, n, e) ? l.MessagePositionInGroup.END : l.MessagePositionInGroup.MIDDLE
                }, e.prototype._isLastPartOfClosingMessage = function(e, t, n) {
                    return e === t - 1 && (n === l.MessagePositionInGroup.END || n === l.MessagePositionInGroup.SINGLE)
                }, e.prototype._isFirstPartOfStartingMessage = function(e, t) {
                    return 0 === e && (t === l.MessagePositionInGroup.START || t === l.MessagePositionInGroup.SINGLE)
                }, e.prototype._isBreakingMessage = function(e) {
                    return this._lastReadSequence && e.sequence === this._lastReadSequence || (null == e ? void 0 : e.messageType) === l.MessageTypes.Templates.System
                }, e.prototype._strategy = function(e, t, n) {
                    return {
                        groupPosition: this._position({
                            olderMessage: e,
                            currentMessage: t,
                            newerMessage: n
                        }),
                        showSentTime: this._showSentTime(e, t)
                    }
                }, e.prototype._isSameTimeWindow = function(e, t) {
                    var n = new Date(e.createdAt),
                        r = new Date(t.createdAt);
                    return Math.abs(r.getTime() - n.getTime()) < this._thresholdMillis
                }, e.prototype._isSameSender = function(e, t) {
                    var n, r;
                    return (null === (n = e.sender) || void 0 === n ? void 0 : n.userId) === (null === (r = t.sender) || void 0 === r ? void 0 : r.userId)
                }, e.prototype._position = function(e) {
                    var t = e.olderMessage,
                        n = e.currentMessage,
                        r = e.newerMessage,
                        i = !this._isInSameGroup(n, t) || this._isBreakingMessage(t),
                        o = !this._isInSameGroup(n, r) || this._isBreakingMessage(n),
                        s = l.MessagePositionInGroup.MIDDLE;
                    return i && o ? s = l.MessagePositionInGroup.SINGLE : o ? s = l.MessagePositionInGroup.END : i && (s = l.MessagePositionInGroup.START), s
                }, e.prototype._isInSameGroup = function(e, t) {
                    if (!e || !t) return !1;
                    var n = this._isSameSender(e, t),
                        r = this._isSameTimeWindow(e, t);
                    return n && r
                }, e.prototype._showSentTime = function(e, t) {
                    return e && t && this._isSameTimeWindow(e, t) && e.messageType !== l.MessageTypes.Templates.System ? "on-click" : "always"
                }, e.prototype._showPartSentTime = function(e, t) {
                    return 0 === t ? e : "on-click"
                }, e
            }();

            function R(e) {
                return void 0 !== e
            }

            function P(e, t, n) {
                var r = {};
                return e.forEach((function(i) {
                    i ? r[i[t]] = Object.assign({}, i, n) : console.warn("toStateObj: array contained an undefined", e)
                })), r
            }! function(e) {
                function t() {
                    return null !== e && e.apply(this, arguments) || this
                }(0, v.__extends)(t, e)
            }(Error);
            var O = n(33795),
                k = n.n(O),
                N = function() {
                    function e(e, t) {
                        this._chatroom = e, this._lastMessage = (null == e ? void 0 : e.lastMessage) ? new _.Z(e.lastMessage) : null, this._online = !!t
                    }
                    return Object.defineProperty(e.prototype, "id", {
                        get: function() {
                            return this._chatroom.id
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "participantId", {
                        get: function() {
                            return this._chatroom.participantId
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "name", {
                        get: function() {
                            var e;
                            return null === (e = this._chatroom.displayData) || void 0 === e ? void 0 : e.name
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "fullName", {
                        get: function() {
                            var e;
                            return null === (e = this._chatroom.displayData) || void 0 === e ? void 0 : e.fullName
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "initials", {
                        get: function() {
                            var e;
                            return null === (e = this._chatroom.displayData) || void 0 === e ? void 0 : e.initials
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "timestamp", {
                        get: function() {
                            return this._lastMessage && this._lastMessage.age || void 0
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "text", {
                        get: function() {
                            if (!this.lastMessage) return "";
                            var e = this.lastMessage.summary || "",
                                t = k()(this.lastMessage, "senderDisplayData.name"),
                                n = t ? t + ": " : "";
                            return this.isPrivate ? e : "" + n + e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "lastMessage", {
                        get: function() {
                            return this._lastMessage
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "thumbnail", {
                        get: function() {
                            var e, t, n;
                            return null === (n = null === (t = null === (e = this._chatroom) || void 0 === e ? void 0 : e.displayData) || void 0 === t ? void 0 : t.image) || void 0 === n ? void 0 : n.url
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "count", {
                        get: function() {
                            return this._chatroom.unreadCount
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "online", {
                        get: function() {
                            return this._online
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isPrivate", {
                        get: function() {
                            return this._chatroom.isPrivate
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "otherParticipantId", {
                        get: function() {
                            var e;
                            return null === (e = this._chatroom.displayData) || void 0 === e ? void 0 : e.id
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "clientReference", {
                        get: function() {
                            return this._chatroom.clientReference
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "clientReferenceType", {
                        get: function() {
                            return this._chatroom.clientReferenceType
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "siteUserType", {
                        get: function() {
                            var e;
                            return null === (e = this._chatroom.displayData) || void 0 === e ? void 0 : e.type
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "participantCount", {
                        get: function() {
                            return this._chatroom.participantCount
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "createdBy", {
                        get: function() {
                            return this._chatroom.createdBy
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "createdAt", {
                        get: function() {
                            return this._chatroom.createdAt
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "error", {
                        get: function() {
                            return this._chatroom.error
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "messageDeliveryError", {
                        get: function() {
                            return this._chatroom.messageDeliveryError
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "archived", {
                        get: function() {
                            ! function(e) {
                                var t = "DEPRECATED (chat-sdk): " + e;
                                throw console.warn(t), new Error(t)
                            }("archive property on chatroom is deprecated, use isArchived instead")
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isArchived", {
                        get: function() {
                            return this._chatroom.isArchived
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isTemporary", {
                        get: function() {
                            return this._chatroom.isTemporary
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "offlineChannels", {
                        get: function() {
                            return k()(this._chatroom, "offlineChannels.channels")
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "offlineChannel", {
                        get: function() {
                            var e = this._chatroom.offlineChannels;
                            return e && e.channels.some((function(e) {
                                return !!e.type
                            })) ? e.channels[0].type : ""
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "siteName", {
                        get: function() {
                            return this._chatroom.businessContext && this._chatroom.businessContext.name
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "businessContext", {
                        get: function() {
                            return this._chatroom.businessContext
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "labelIds", {
                        get: function() {
                            return this._chatroom.labelIds
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isStarred", {
                        get: function() {
                            var e;
                            return null === (e = this._chatroom.labelIds) || void 0 === e ? void 0 : e.includes(l.STAR_LABEL_ID)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(),
                D = n(80340),
                M = n.n(D),
                x = n(484),
                L = n.n(x),
                U = {},
                F = function(e, t) {
                    var n = function(e, t) {
                        var n = void 0 === U[t] && void 0 !== e[t];
                        return n && (U[t] = e[t]), n
                    }(e, t);
                    return function(e, t) {
                        return {
                            value: U[e],
                            dontUpdate: !t
                        }
                    }(t, n)
                },
                j = n(63017),
                q = n(36107),
                H = n(86330),
                W = n.n(H),
                B = n(79922),
                V = n.n(B),
                G = n(89793),
                z = n.n(G),
                $ = n(50403),
                K = n.n($),
                Y = n(35810),
                J = function(e) {
                    return e.messages
                },
                Q = function(e) {
                    return e.messagesIndications
                },
                X = function(e) {
                    return e.participants
                },
                Z = function(e) {
                    return e.chatrooms
                },
                ee = function(e) {
                    return ie(Z, (function(t) {
                        var n = t.byId[e];
                        return null == n ? void 0 : n.enrichedChatroomLoaded
                    }))
                },
                te = function(e, t) {
                    return new _.Z(e, e.transit, t)
                };

            function ne(e) {
                return e.sort((function(e, t) {
                    return e.createdAt - t.createdAt
                }))
            }

            function re(e) {
                return e.sort((function(e, t) {
                    return e.sequence - t.sequence
                }))
            }
            te = (0, C.Z)(500)(te);
            var ie = (0, q.wN)(q.PW, z()),
                oe = function(e) {
                    return ie(J, (function(t) {
                        return function(e, t) {
                            return W()(e.byId, (function(e) {
                                return e.chatroomId === t
                            }))
                        }(t, e)
                    }))
                },
                se = function(e) {
                    return ie(Q, J, (function(t, n) {
                        return function(e, t, n) {
                            return V()(e.byId, (function(e, r) {
                                return t.byId[r] && t.byId[r].chatroomId === n
                            }))
                        }(t, n, e)
                    }))
                },
                ae = function(e, t) {
                    return void 0 === t && (t = ne), ie(oe(e), t)
                },
                ce = function(e, t) {
                    return h()(e, (function(e, n, r) {
                        var i = ue(n),
                            o = t.byId[r];
                        return o ? K()(e, {
                            participant: {
                                id: r,
                                displayData: o.displayData
                            },
                            details: i
                        }) : e
                    }), [])
                },
                ue = function(e) {
                    return h()(e, (function(e, t) {
                        return K()(e, {
                            code: t.code,
                            event: t.event,
                            method: t.method,
                            formattedTimestamp: Y.$(t.timestamp)
                        })
                    }), [])
                },
                le = [],
                de = function(e, t, n, r) {
                    return e.map((function(e) {
                        var i = t[e.id];
                        if (!i) return n ? te(e, le) : te(e);
                        var o = ce(i, r);
                        return te(e, o)
                    }))
                },
                he = function(e) {
                    return ie(ae(e), se(e), ee(e), X, de)
                },
                pe = function(e, t) {
                    return ie(function(e) {
                        return ie(Q, (function(t) {
                            return function(e, t) {
                                return e.byId[t]
                            }(t, e)
                        }))
                    }(t), ee(e), function(e) {
                        return ie(J, (function(t) {
                            return t.byId[e]
                        }))
                    }(t), X, (function(e, t, n, r) {
                        return n ? e ? {
                            indications: ce(e, r)
                        } : t ? {
                            indications: []
                        } : {
                            indications: void 0
                        } : {
                            indications: void 0
                        }
                    }))
                },
                fe = function(e, t) {
                    return e.chatrooms.byId[t] || {}
                },
                me = function(e, t) {
                    var n = fe(e, t),
                        r = he(t)(e),
                        i = F(e.messageDraft.byId, t),
                        o = n.cursor,
                        s = n.cursorDown,
                        a = n.typingStatus,
                        c = void 0 === a ? [] : a,
                        u = n.unreadCount,
                        l = void 0 === u ? 0 : u,
                        d = n.lastReadMessageSequence,
                        h = e.chatrooms ? e.chatrooms.status : {
                            isFetchingRoom: !1
                        },
                        p = {
                            messages: r,
                            initialMessageDraft: i.value,
                            status: h,
                            cursor: o,
                            cursorDown: s,
                            typingStatus: c,
                            unreadCount: l,
                            lastReadMessageSequence: d
                        };
                    return ge(n, p)
                },
                ge = function(e, t) {
                    var n = new _e(e, t);
                    return {
                        id: n.id,
                        name: n.name,
                        fullName: n.fullName,
                        thumbnail: n.thumbnail,
                        initials: n.initials,
                        isPrivate: n.isPrivate,
                        isArchived: n.isArchived,
                        otherParticipantId: n.otherParticipantId,
                        participantId: n.participantId,
                        participantCount: n.participantCount,
                        clientReferenceType: n.clientReferenceType,
                        createdBy: n.createdBy,
                        createdAt: n.createdAt,
                        messages: n.messages,
                        error: n.error,
                        cursor: n.cursor,
                        cursorDown: n.cursorDown,
                        typingStatus: n.typingStatus,
                        unreadCount: n.unreadCount,
                        lastReadMessageSequence: n.lastReadMessageSequence,
                        status: n.status,
                        initialMessageDraft: n.initialMessageDraft,
                        offlineChannels: n.offlineChannels,
                        participants: e.participants || [],
                        labelIds: e.labelIds || [],
                        siteUserType: n.siteUserType,
                        isStarred: n.isStarred
                    }
                },
                _e = function(e) {
                    function t(t, n) {
                        var r = e.call(this, t) || this;
                        return r._messages = n.messages, r._initialMessageDraft = n.initialMessageDraft, r._status = n.status, r._cursor = n.cursor, r._cursorDown = n.cursorDown, r._typingStatus = n.typingStatus, r._unreadCount = n.unreadCount, r._lastReadMessageSequence = n.lastReadMessageSequence, r._participants = t.participants || [], r
                    }
                    return (0, v.__extends)(t, e), Object.defineProperty(t.prototype, "messages", {
                        get: function() {
                            return this._messages
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "initialMessageDraft", {
                        get: function() {
                            return this._initialMessageDraft
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "status", {
                        get: function() {
                            return this._status
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "cursor", {
                        get: function() {
                            return this._cursor
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "cursorDown", {
                        get: function() {
                            return this._cursorDown
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "typingStatus", {
                        get: function() {
                            return this._typingStatus
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "unreadCount", {
                        get: function() {
                            return this._unreadCount
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "lastReadMessageSequence", {
                        get: function() {
                            return this._lastReadMessageSequence
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "participants", {
                        get: function() {
                            return this._participants
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(N),
                ve = function(e) {
                    var t, n, r, i = he(e),
                        o = se(e);
                    return function(s) {
                        var a = s.store,
                            c = s.onChange,
                            u = s.onNewMessage,
                            l = s.onError,
                            d = a.getState(),
                            h = fe(d, e),
                            p = i(d),
                            m = o(d),
                            g = F(d.messageDraft.byId, e);
                        if (!(h && p && t === h && n === p && r === m && g.dontUpdate)) {
                            var _ = function(e, t) {
                                var n = e ? Math.max.apply(Math, e.map((function(e) {
                                        return e.sequence || -2
                                    }))) : -1,
                                    r = t ? Math.max.apply(Math, t.map((function(e) {
                                        return e.sequence || -2
                                    }))) : -1;
                                return !f()(t) && n > r
                            }(p, n);
                            t = h, n = p, r = m;
                            var v, y = me(d, e);
                            y.error && l && (v = "Instead of onError callback in subscribeToChatroom, rely on the error field in the Chatroom object", console.warn("DEPRECATED (chat-sdk): " + v), l(y.error)), c(y), _ && u && u(y)
                        }
                    }
                },
                ye = function(e) {
                    var t = so.store.getState();
                    return W()(e, (function(e) {
                        return !t.participants.byId[e]
                    }))
                },
                be = 0,
                Ie = function(e, t, n) {
                    return V()(e, (function(e) {
                        return Ee(e, t, n)
                    }))
                };

            function Ee(e, t, n) {
                var r;
                if (!t || f()(t)) return !e.isArchived;
                var i = null == n ? void 0 : n.includes(e.id);
                return !(!i || !Se(e, t)) || (!(!(null === (r = t.labelIds) || void 0 === r ? void 0 : r.includes(l.STAR_LABEL_ID)) || !i) || [Se, Ce, Te, Ae, we].every((function(n) {
                    return n(e, t)
                })))
            }

            function Se(e, t) {
                return t.isArchived ? !!e.isArchived : !e.isArchived
            }

            function we(e, t) {
                return !t.isUnread || !!Re(e)
            }

            function Ce(e, t) {
                var n;
                return !(null === (n = t.participantIds) || void 0 === n ? void 0 : n.length) || t.participantIds.some((function(t) {
                    return t === e.participantId
                }))
            }

            function Te(e, t) {
                if ("business" === t.participantType) return e.participantId === k()(e, "businessContext.id") && "Engage" === e.pluginName;
                if ("siteMember" === t.participantType) {
                    var n = e.participantId !== k()(e, "businessContext.id");
                    return "Social" === e.pluginName || "Engage" === e.pluginName && n
                }
                return !0
            }

            function Ae(e, t) {
                return !(t.labelIds && t.labelIds.length && e.labelIds) || t.labelIds.some((function(t) {
                    return e.labelIds.includes(t)
                }))
            }

            function Re(e) {
                var t = e.lastMessage,
                    n = e.lastReadMessageSequence;
                if (t) return (void 0 === n ? be : n) < t.sequence
            }
            var Pe = {
                    maxUnreadsCount: 50,
                    maxTrackableUnreads: 60
                },
                Oe = n(17612),
                ke = n(92435),
                Ne = {
                    INIT: "@@redux/INIT"
                };

            function De(e, t, n) {
                var r;
                if ("function" == typeof t && void 0 === n && (n = t, t = void 0), void 0 !== n) {
                    if ("function" != typeof n) throw new Error("Expected the enhancer to be a function.");
                    return n(De)(e, t)
                }
                if ("function" != typeof e) throw new Error("Expected the reducer to be a function.");
                var i = e,
                    o = t,
                    s = [],
                    a = s,
                    c = !1;

                function u() {
                    a === s && (a = s.slice())
                }

                function l() {
                    return o
                }

                function d(e) {
                    if ("function" != typeof e) throw new Error("Expected listener to be a function.");
                    var t = !0;
                    return u(), a.push(e),
                        function() {
                            if (t) {
                                t = !1, u();
                                var n = a.indexOf(e);
                                a.splice(n, 1)
                            }
                        }
                }

                function h(e) {
                    if (!(0, Oe.Z)(e)) throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
                    if (void 0 === e.type) throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
                    if (c) throw new Error("Reducers may not dispatch actions.");
                    try {
                        c = !0, o = i(o, e)
                    } finally {
                        c = !1
                    }
                    for (var t = s = a, n = 0; n < t.length; n++) {
                        (0, t[n])()
                    }
                    return e
                }
                return h({
                    type: Ne.INIT
                }), (r = {
                    dispatch: h,
                    subscribe: d,
                    getState: l,
                    replaceReducer: function(e) {
                        if ("function" != typeof e) throw new Error("Expected the nextReducer to be a function.");
                        i = e, h({
                            type: Ne.INIT
                        })
                    }
                })[ke.Z] = function() {
                    var e, t = d;
                    return (e = {
                        subscribe: function(e) {
                            if ("object" != typeof e) throw new TypeError("Expected the observer to be an object.");

                            function n() {
                                e.next && e.next(l())
                            }
                            return n(), {
                                unsubscribe: t(n)
                            }
                        }
                    })[ke.Z] = function() {
                        return this
                    }, e
                }, r
            }

            function Me(e, t) {
                var n = t && t.type;
                return "Given action " + (n && '"' + n.toString() + '"' || "an action") + ', reducer "' + e + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.'
            }

            function xe(e) {
                for (var t = Object.keys(e), n = {}, r = 0; r < t.length; r++) {
                    var i = t[r];
                    0, "function" == typeof e[i] && (n[i] = e[i])
                }
                var o = Object.keys(n);
                var s = void 0;
                try {
                    ! function(e) {
                        Object.keys(e).forEach((function(t) {
                            var n = e[t];
                            if (void 0 === n(void 0, {
                                    type: Ne.INIT
                                })) throw new Error('Reducer "' + t + "\" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.");
                            if (void 0 === n(void 0, {
                                    type: "@@redux/PROBE_UNKNOWN_ACTION_" + Math.random().toString(36).substring(7).split("").join(".")
                                })) throw new Error('Reducer "' + t + "\" returned undefined when probed with a random type. Don't try to handle " + Ne.INIT + ' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.')
                        }))
                    }(n)
                } catch (e) {
                    s = e
                }
                return function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        t = arguments[1];
                    if (s) throw s;
                    for (var r = !1, i = {}, a = 0; a < o.length; a++) {
                        var c = o[a],
                            u = n[c],
                            l = e[c],
                            d = u(l, t);
                        if (void 0 === d) {
                            var h = Me(c, t);
                            throw new Error(h)
                        }
                        i[c] = d, r = r || d !== l
                    }
                    return r ? i : e
                }
            }

            function Le() {
                for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return 0 === t.length ? function(e) {
                    return e
                } : 1 === t.length ? t[0] : t.reduce((function(e, t) {
                    return function() {
                        return e(t.apply(void 0, arguments))
                    }
                }))
            }
            var Ue = Object.assign || function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            };

            function Fe() {
                for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return function(e) {
                    return function(n, r, i) {
                        var o, s = e(n, r, i),
                            a = s.dispatch,
                            c = {
                                getState: s.getState,
                                dispatch: function(e) {
                                    return a(e)
                                }
                            };
                        return o = t.map((function(e) {
                            return e(c)
                        })), a = Le.apply(void 0, o)(s.dispatch), Ue({}, s, {
                            dispatch: a
                        })
                    }
                }
            }
            var je = {
                    RESET_STORE: "RESET_STORE",
                    FETCH_ROOMS: "FETCH_ROOMS",
                    FETCH_ROOM: "FETCH_ROOM",
                    FETCH_ENRICHED_ROOM: "FETCH_ENRICHED_ROOM",
                    DELETE_ROOM: "DELETE_ROOM",
                    DELETE_ROOMS: "DELETE_ROOMS",
                    ARCHIVE_ROOM: "ARCHIVE_ROOM",
                    ARCHIVE_ROOMS: "ARCHIVE_ROOMS",
                    UNARCHIVE_ROOMS: "UNARCHIVE_ROOMS",
                    HANDLE_ROOM_ARCHIVED: "HANDLE_ROOM_ARCHIVED",
                    UNARCHIVE_ROOM: "UNARCHIVE_ROOM",
                    HANDLE_ROOM_UNARCHIVED: "HANDLE_ROOM_UNARCHIVED",
                    FETCH_ROOM_MESSAGES: "FETCH_ROOM_MESSAGES",
                    FETCH_MESSAGES_ERRORS_INDICATIONS: "FETCH_MESSAGES_ERRORS_INDICATIONS",
                    ADD_ROOMS: "ADD_ROOMS",
                    REMOVE_ROOM: "REMOVE_ROOM",
                    ADD_MESSAGE: "ADD_MESSAGE",
                    UPDATE_MESSAGE: "UPDATE_MESSAGE",
                    SEND_MESSAGE: "SEND_MESSAGE",
                    DELETE_MESSAGE: "DELETE_MESSAGE",
                    RESEND_MESSAGE: "RESEND_MESSAGE",
                    TYPING: "TYPING",
                    FETCH_MESSAGE_DRAFTS: "FETCH_MESSAGE_DRAFTS",
                    TYPING_STATUS_CHANGE: "TYPING_STATUS_CHANGE",
                    SET_MESSAGES_READ: "SET_MESSAGES_READ",
                    SET_MESSAGES_READ_FOR_SELF: "SET_MESSAGES_READ_FOR_SELF",
                    SET_ROOMS_MESSAGES_READ: "SET_ROOMS_MESSAGES_READ",
                    SET_ROOMS_MESSAGES_UNREAD: "SET_ROOMS_MESSAGES_UNREAD",
                    SET_LAST_MESSAGE_UNREAD: "SET_LAST_MESSAGE_UNREAD",
                    UPDATE_MESSAGES_INDICATIONS: "UPDATE_MESSAGES_INDICATIONS",
                    FETCH_PARTICIPANTS_DISPLAY_DATA: "FETCH_PARTICIPANTS_DISPLAY_DATA",
                    FETCH_DRILL_IN_MESSAGE_INDICATIONS: "FETCH_DRILL_IN_MESSAGE_INDICATIONS",
                    SET_UNSEEN_CHATROOMS: "SET_UNSEEN_CHATROOMS",
                    SET_UNREAD_CHATROOMS_MAP: "SET_UNREAD_CHATROOMS_MAP",
                    MARK_CHATROOM_SEEN: "MARK_CHATROOM_SEEN",
                    MARK_CHATROOM_READ: "MARK_CHATROOM_READ",
                    MARK_CHATROOMS_SEEN: "MARK_CHATROOMS_SEEN",
                    UPDATE_PRESENCE: "UPDATE_PRESENCE",
                    FETCH_PRESENCE: "FETCH_PRESENCE",
                    FETCH_VISITORS_PRESENCE: "FETCH_VISITORS_PRESENCE",
                    CLEAR_PRESENCE: "CLEAR_PRESENCE",
                    PRESENCE_CLEAR_STALE: "PRESENCE_CLEAR_STALE",
                    UPDATE_ROOM_LABELS: "UPDATE_ROOM_LABELS",
                    UPDATE_ROOM_LABEL: "UPDATE_ROOM_LABEL",
                    REMOVE_ROOM_LABELS: "REMOVE_ROOM_LABELS",
                    SET_CURRENT_FILTER: "SET_CURRENT_FILTER",
                    SET_FILTERED_ROOMS_IDS: "SET_CURRENT_FILTERED_ROOMS_IDS"
                },
                qe = function(e) {
                    return e + "_FULFILLED"
                },
                He = function(e) {
                    return e + "_PENDING"
                },
                We = function(e) {
                    return e + "_REJECTED"
                },
                Be = function(e) {
                    return "participantType" in e ? e.participantType : e.participantId
                },
                Ve = function(e) {
                    return "business" === e || "siteMember" === e ? {
                        participantType: e
                    } : {
                        participantId: e
                    }
                },
                Ge = function(e, t) {
                    return Object.keys(e).map(Ve).filter((function(e) {
                        return Ee(t, "participantId" in e ? {
                            participantIds: [e.participantId]
                        } : {
                            participantType: e.participantType
                        })
                    })).map(Be)
                },
                ze = function(e) {
                    return "resyncCountdown" in e
                },
                $e = function(e, t) {
                    if (!t) return e;
                    var n = Ge(e, t),
                        r = (0, v.__assign)({}, e);
                    return n.forEach((function(n) {
                        r[n] = function(e, t) {
                            var n;
                            return ze(e) ? e : Object.keys(e.chatrooms).length === Pe.maxTrackableUnreads ? {
                                resyncCountdown: Pe.maxTrackableUnreads - Pe.maxUnreadsCount
                            } : {
                                chatrooms: (0, v.__assign)((0, v.__assign)({}, e.chatrooms), (n = {}, n[t] = !0, n))
                            }
                        }(e[n], t.id)
                    })), r
                },
                Ke = function(e, t) {
                    if (ze(e)) return {
                        resyncCountdown: Math.max(0, e.resyncCountdown - 1)
                    };
                    if (e.chatrooms[t]) {
                        var n = (0, v.__assign)({}, e.chatrooms);
                        return delete n[t], {
                            chatrooms: n
                        }
                    }
                    return e
                },
                Ye = function(e, t) {
                    if (!t) return e;
                    var n = Ge(e, t),
                        r = (0, v.__assign)({}, e);
                    return n.forEach((function(n) {
                        r[n] = Ke(e[n], t.id)
                    })), r
                },
                Je = xe({
                    byFilter: function(e, t) {
                        var n;
                        switch (void 0 === e && (e = {}), t.type) {
                            case qe(je.SET_UNSEEN_CHATROOMS):
                                return function(e, t) {
                                    var n, r, i = t.payload;
                                    return (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[Be(t.meta.filter)] = i.length > Pe.maxTrackableUnreads ? {
                                        resyncCountdown: Pe.maxTrackableUnreads - Pe.maxUnreadsCount
                                    } : {
                                        chatrooms: (r = i, r.reduce((function(e, t) {
                                            return e[t.chatroomId] = !0, e
                                        }), {}))
                                    }, n))
                                }(e, t);
                            case je.ADD_MESSAGE:
                                var r = t.meta.chatroom,
                                    i = void 0 === r ? {} : r,
                                    o = i.lastSeenMessageSequence,
                                    s = void 0 === o ? 0 : o,
                                    a = i.lastReadMessageSequence,
                                    c = void 0 === a ? 0 : a,
                                    u = Math.max(s, c);
                                return t.messageSentByCurrentUser || t.message.isSilent || t.message.sequence <= u ? e : $e(e, t.meta.chatroom);
                            case je.HANDLE_ROOM_UNARCHIVED:
                            case je.UNARCHIVE_ROOM:
                            case je.SET_LAST_MESSAGE_UNREAD:
                                return $e(e, t.meta.chatroom);
                            case je.UNARCHIVE_ROOMS:
                                return t.meta.chatrooms.reduce((function(e, t) {
                                    return $e(e, t)
                                }), e);
                            case je.MARK_CHATROOM_SEEN:
                                return Ye(e, t.meta.chatroom);
                            case He(je.MARK_CHATROOMS_SEEN):
                                var l = t.meta,
                                    d = l.filter,
                                    h = l.filteredChatrooms,
                                    p = Be(d),
                                    f = e[p],
                                    m = ze(f) ? [] : Object.keys(f.chatrooms);
                                return (0, v.__assign)((0, v.__assign)((0, v.__assign)({}, h.reduce((function(e, t) {
                                    return Ye(e, t)
                                }), e)), m.reduce((function(e, t) {
                                    return function(e, t) {
                                        var n = Object.keys(e),
                                            r = (0, v.__assign)({}, e);
                                        return n.forEach((function(n) {
                                            r[n] = Ke(e[n], t)
                                        })), r
                                    }(e, t)
                                }), e)), ((n = {})[p] = {
                                    chatrooms: {}
                                }, n));
                            default:
                                return e
                        }
                    }
                }),
                Qe = function(e) {
                    var t = e.lastMessage,
                        n = e.lastReadMessageSequence,
                        r = void 0 === n ? 0 : n,
                        i = e.lastSeenMessageSequence,
                        o = void 0 === i ? 0 : i;
                    return !!t && Math.max(r, o) < t.sequence
                },
                Xe = function(e) {
                    return e.presence.participantsById
                },
                Ze = function(e) {
                    return e.chatrooms.byId
                },
                et = function(e) {
                    var t = e.stateRoom,
                        n = e.roomsById,
                        r = e.stateRoomIsOnline;
                    return new N(n[t.id], r)
                };

            function tt(e, t) {
                var n = [];
                return Object.keys(t).sort((function(e, n) {
                    var r = k()(t[e], "lastMessage.createdAt"),
                        i = k()(t[n], "lastMessage.createdAt");
                    return r === i ? 0 : r > i || !i ? -1 : 1
                })).forEach((function(r) {
                    var i, o = new N(t[r]).otherParticipantId,
                        s = !!o && (null === (i = e[o]) || void 0 === i ? void 0 : i.online),
                        a = et({
                            stateRoom: t[r],
                            roomsById: t,
                            stateRoomIsOnline: s
                        });
                    a.lastMessage && !a.isTemporary && n.push(a)
                })), n
            }

            function nt(e) {
                return !e.isArchived && !e.isTemporary
            }
            et = (0, C.Z)(500, (function(e, t) {
                return e.stateRoom === t.stateRoom && e.stateRoomIsOnline === t.stateRoomIsOnline
            }))(et);
            (0, q.P1)(Xe, Ze, tt);
            var rt = (0, q.wN)(q.PW, z()),
                it = function(e, t) {
                    return (0, q.P1)(Ze, function(e) {
                        return function(t) {
                            var n;
                            return null === (n = t.chatrooms.filter[e]) || void 0 === n ? void 0 : n.filteredRoomsIds
                        }
                    }(e), (function(e, n) {
                        return Ie(e, t, n)
                    }))
                },
                ot = ((0, q.P1)(Ze, (function(e) {
                    return Object.values(e).filter(Re).filter(nt).map((function(e) {
                        return e.id
                    }))
                })), function(e) {
                    var t = e.chatrooms.byId,
                        n = Object.values(t).map((function(e) {
                            var t;
                            return (null === (t = e.lastMessage) || void 0 === t ? void 0 : t.sequence) || -1
                        })),
                        r = Math.max.apply(Math, n);
                    if (r > 0 && !isNaN(r)) return r
                }),
                st = function() {
                    function e(e) {
                        this.dto = {
                            chatAction: e.chatAction
                        }
                    }
                    return Object.defineProperty(e.prototype, "chatAction", {
                        get: function() {
                            return this.dto.chatAction
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }();
            var at = function() {
                    function e(e) {
                        var t = e.store,
                            n = e.chatroomsActions,
                            r = e.subscriptionService,
                            i = e.currentUser,
                            o = e.enrichedChatroom;
                        this.store = t, this.chatroomsActions = n, this.subscriptionService = r, this.currentUser = i, this.enrichedChatroom = o
                    }
                    return e.prototype.subscribeToChatRoom = function(e) {
                        var t = this,
                            n = e.chatroomId,
                            r = e.onChange,
                            i = e.onNewMessage,
                            o = e.onInitialFetchDone,
                            s = e.onError,
                            a = e.initialCursor,
                            c = e.cursorStrategy,
                            u = this.store,
                            l = this.chatroomsActions;
                        ! function(e) {
                            delete U[e]
                        }(n);
                        var d = ve(n);
                        d({
                            store: u,
                            onChange: r,
                            onNewMessage: i,
                            onError: s
                        });
                        var h = u.subscribe((function() {
                                return d({
                                    store: u,
                                    onChange: r,
                                    onNewMessage: i,
                                    onError: s
                                })
                            })),
                            p = this._createDataFetcher(n, o, a, c);
                        setTimeout((function() {
                            return p()
                        }), 0);
                        var m = this._registerSubscription(n, p),
                            g = function(e) {
                                var t = e.indications.lastMessageIndications.map((function(e) {
                                        return e.participantId
                                    })),
                                    r = e.participants.items.map((function(e) {
                                        return e.id
                                    }));
                                if (!f()(L()(t, r))) {
                                    var i = ye(t);
                                    f()(i) || u.dispatch(l.action$fetchRoomParticipantsDisplayData(n, i))
                                }
                            };
                        j.NH(j.xc.FETCH_ENRICHED_CHATROOM_COMPLETED, g);
                        return {
                            fetchMore: function(e, r) {
                                u.dispatch(l.fetchRoomMessages(n, e, r)).then((function() {
                                    t.store.dispatch(t.chatroomsActions.fetchMessageErrorIndications(n))
                                }))
                            },
                            unsubscribe: function() {
                                h(), m(), j.ys(j.xc.FETCH_ENRICHED_CHATROOM_COMPLETED, g)
                            }
                        }
                    }, e.prototype._registerSubscription = function(e, t) {
                        var n = {
                            chatroomId: e
                        };
                        return this.subscriptionService.registerSubscription(n, t)
                    }, e.prototype._createDataFetcher = function(e, t, n, r) {
                        var i = this;
                        return function() {
                            return Promise.all([i.store.dispatch(i.chatroomsActions.action$fetchRoom(e, i.enrichedChatroom)), i.store.dispatch(i.chatroomsActions.fetchRoomMessages(e, n, r))]).then((function() {
                                if (i.store.dispatch(i.chatroomsActions.fetchMessageErrorIndications(e)), t) {
                                    var n = i.store.getState(),
                                        r = me(n, e);
                                    t(r)
                                }
                            })).catch((function(e) {
                                console.error("CHAT4893 Error on room initial fetch", e)
                            }))
                        }
                    }, e.prototype.getChatroom = function(e) {
                        var t = e.chatroomId;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return e = fe(this.store.getState(), t), f()(e) ? [4, this.store.dispatch(this.chatroomsActions.action$fetchRoom(t, this.enrichedChatroom))] : [3, 2];
                                    case 1:
                                        n.sent(), e = fe(this.store.getState(), t), n.label = 2;
                                    case 2:
                                        return [2, new N(e)]
                                }
                            }))
                        }))
                    }, e.prototype.setMessagesRead = function(e) {
                        var t = e.chatroomId,
                            n = function(e, t) {
                                var n = he(t)(e);
                                if (n.length) {
                                    var r = e.chatrooms.byId[t] || {},
                                        i = r.lastMessage,
                                        o = Math.max((null == i ? void 0 : i.sequence) || -1, n[n.length - 1].sequence);
                                    if (o !== r.lastReadMessageSequence) return o
                                }
                            }(this.store.getState(), t);
                        if (n) return this.store.dispatch(this.chatroomsActions.action$setMessagesRead(t, n))
                    }, e.prototype.setRoomsMessagesRead = function(e) {
                        var t = this.store.getState(),
                            n = M()(e, (function(e) {
                                return k()(fe(t, e), "lastMessage.sequence")
                            })),
                            r = n && k()(fe(t, n), "lastMessage.sequence");
                        r && this.store.dispatch(this.chatroomsActions.action$setRoomsMessagesRead(e, r))
                    }, e.prototype.setLastMessageUnread = function(e) {
                        var t = e.chatroomId,
                            n = this.store.getState(),
                            r = he(t)(n),
                            i = function(e, t, n) {
                                var r = t.filter((function(t) {
                                    var r;
                                    return !t.isSilent && (!e || t.sequence <= e) && (null === (r = t.sender) || void 0 === r ? void 0 : r.userId) !== n
                                }));
                                if (r.length > 0) return r[r.length - 1].sequence - 1
                            }(fe(n, t).lastReadMessageSequence, r, this.currentUser.userId);
                        if (i) return this.store.dispatch(this.chatroomsActions.action$setLastMessageUnread(t, i))
                    }, e.prototype.getMessageWithSender = function(e) {
                        var t = e.dto,
                            n = this.currentUser,
                            r = (0, v.__assign)((0, v.__assign)({}, t), {
                                sender: t.sender || {
                                    userId: n.userId,
                                    type: n.type
                                },
                                senderDisplayData: n.displayData,
                                appId: so.appId
                            });
                        return new _.Z(r)
                    }, e.prototype.sendMessage = function(e) {
                        var t = e.dto,
                            n = this.store,
                            r = this.chatroomsActions,
                            i = this.getMessageWithSender({
                                dto: t
                            }),
                            o = r.action$sendMessage(i);
                        return n.dispatch(o)
                    }, e.prototype.addMessage = function(e) {
                        var t, n = e.dto,
                            r = e.transit;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e, i, o, s, a, c, u, d, h;
                            return (0, v.__generator)(this, (function(p) {
                                switch (p.label) {
                                    case 0:
                                        return i = (e = this).currentUser, o = e.store, s = e.chatroomsActions, a = !(null === (t = n.sender) || void 0 === t ? void 0 : t.userId) || n.sender.userId == i.userId, c = Object.assign(n, {
                                            transit: r
                                        }, a ? {
                                            senderDisplayData: i.displayData,
                                            sender: {
                                                userId: i.userId
                                            }
                                        } : {}), u = n.chatroomId, (d = o.getState().chatrooms.byId[u]) && d.id ? [3, 2] : (h = so.isExperimentOn(l.SdkExperiment.EnrichedChatroom), [4, o.dispatch(s.action$fetchRoom(u, h))]);
                                    case 1:
                                        p.sent(), p.label = 2;
                                    case 2:
                                        return [2, o.dispatch(s.action$addMessage(c, !0, o.getState().chatrooms.byId[u]))]
                                }
                            }))
                        }))
                    }, e.prototype.deleteMessage = function(e, t) {
                        void 0 === t && (t = !1);
                        var n = this.store,
                            r = this.chatroomsActions.action$deleteMessage(e, t);
                        return n.dispatch(r)
                    }, e.prototype.resendMessage = function(e) {
                        var t = this.store,
                            n = this.chatroomsActions.action$resendMessage(e);
                        return t.dispatch(n)
                    }, e.prototype.deleteLabel = function(e) {
                        var t = e.chatroomId,
                            n = e.labelId,
                            r = this.store,
                            i = this.chatroomsActions.action$removeRoomLabels([{
                                chatroomId: t,
                                labelId: n
                            }], !0);
                        return r.dispatch(i)
                    }, e.prototype.unstarRoom = function(e) {
                        return this.deleteLabel({
                            chatroomId: e,
                            labelId: l.STAR_LABEL_ID
                        })
                    }, e.prototype.starRoom = function(e) {
                        var t = this.store,
                            n = this.chatroomsActions.action$updateRoomLabel({
                                chatroomId: e,
                                labelId: l.STAR_LABEL_ID
                            });
                        return t.dispatch(n)
                    }, e.prototype.buttonInteraction = function(e, t) {
                        var n = this,
                            r = n.store,
                            i = n.currentUser,
                            o = n.chatroomsActions;
                        if (e.payload) {
                            var s = _.Z.fromText({
                                    text: e.text,
                                    chatroomId: t,
                                    userId: i.userId,
                                    userType: i.type,
                                    summary: e.text,
                                    isEphemeral: !0,
                                    isSilent: !0,
                                    appId: so.appId
                                }),
                                a = new st({
                                    chatAction: (0, v.__assign)({
                                        actionType: "BUTTON_INTERACTION"
                                    }, e.payload)
                                });
                            return r.dispatch(o.action$sendPostbackMessage(s, a))
                        }
                    }, e
                }(),
                ct = function(e, t) {
                    var n = e[t];
                    return "string" == typeof n ? "true" === n : !!n
                },
                ut = {
                    evid: 1101
                },
                lt = new(function() {
                    function e() {}
                    return e.prototype.setAppName = function(e) {
                        this._appName = e
                    }, Object.defineProperty(e.prototype, "appName", {
                        get: function() {
                            return this._appName
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }()),
                dt = n(31454),
                ht = n.n(dt),
                pt = n(79937),
                ft = n.n(pt),
                mt = n(22972),
                gt = n.n(mt),
                _t = function() {
                    function e(e, t, n, r, i, o) {
                        this.serverApi = e, this.persistence = t, this.eventHooks = n, this.unseenChatroomCountActions = r, this.unreadChatroomCountActions = i, this.experiments = o
                    }
                    return e.prototype.action$resetStore = function() {
                        return {
                            type: je.RESET_STORE
                        }
                    }, e.prototype.fetchRoomMessages = function(e, t, n) {
                        var r = this;
                        return function(i) {
                            return (0, v.__awaiter)(r, void 0, void 0, (function() {
                                var r, o;
                                return (0, v.__generator)(this, (function(s) {
                                    switch (s.label) {
                                        case 0:
                                            return r = {
                                                chatroomId: e,
                                                cursor: t,
                                                cursorStrategy: n,
                                                pageSize: l.FetchRoomMessagesPageSize
                                            }, o = "Window" === n ? this.serverApi.http$fetchRoomMessagesWindow(r) : this.serverApi.http$fetchRoomMessages(r), [4, i({
                                                type: je.FETCH_ROOM_MESSAGES,
                                                payload: o,
                                                meta: {
                                                    chatroomId: e,
                                                    isFetchMore: !!t,
                                                    cursorStrategy: n
                                                }
                                            })];
                                        case 1:
                                            return s.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.fetchMessageErrorIndications = function(e) {
                        var t = this;
                        return function(n, r) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                var t, i, o, s, a, c;
                                return (0, v.__generator)(this, (function(u) {
                                    switch (u.label) {
                                        case 0:
                                            return t = r(), i = ct(this.experiments, l.SdkExperiment.FetchMessageErrorIndication), o = ae(e, re)(t), i ? o && o.length ? (s = ft()(o).sequence, a = gt()(o).sequence, c = this.serverApi.http$fetchMessagesErrorIndications({
                                                chatroomId: e,
                                                from: s,
                                                to: a
                                            }), [4, n({
                                                type: je.FETCH_MESSAGES_ERRORS_INDICATIONS,
                                                payload: c,
                                                meta: {
                                                    chatroomId: e
                                                }
                                            })]) : [2, null] : [2, null];
                                        case 1:
                                            return u.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$fetchRoom = function(e, t, n) {
                        if (void 0 === t && (t = !1), void 0 === n && (n = !1), !e) {
                            var r = {
                                tag: "error",
                                description: "Attempting to fetch chatroom with undefined chatroomId."
                            };
                            j.j8(j.X3.MONITORING_BI, r), this.eventHooks.reportMonitoringBi(r), console.error("[Troubleshoot] called fetchRoom w/o chatroomId", new Error)
                        }
                        return t ? {
                            type: je.FETCH_ENRICHED_ROOM,
                            payload: this.serverApi.http$fetchEnrichedChatroom({
                                chatroomId: e,
                                force: n
                            }).then((function(e) {
                                return j.j8(j.xc.FETCH_ENRICHED_CHATROOM_COMPLETED, e), e
                            }))
                        } : {
                            type: je.FETCH_ROOM,
                            payload: this.serverApi.http$fetchRoom({
                                chatroomId: e
                            })
                        }
                    }, e.prototype.action$deleteRoom = function(e) {
                        var t = this;
                        return function(n) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.decrementCounters(n, e)];
                                        case 1:
                                            return t.sent(), [4, n({
                                                type: je.DELETE_ROOM,
                                                payload: this.serverApi.http$deleteChatroom({
                                                    chatroomId: e
                                                }),
                                                meta: {
                                                    chatroomId: e
                                                }
                                            })];
                                        case 2:
                                            return t.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$removeRoom = function(e) {
                        var t = this;
                        return function(n) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.decrementCounters(n, e)];
                                        case 1:
                                            return t.sent(), [2, n({
                                                type: je.REMOVE_ROOM,
                                                meta: {
                                                    chatroomId: e
                                                }
                                            })]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$updateRoomLabels = function(e) {
                        return {
                            type: je.UPDATE_ROOM_LABELS,
                            payload: e
                        }
                    }, e.prototype.action$updateRoomLabel = function(e) {
                        var t = this;
                        return function(n) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    return [2, n({
                                        type: je.UPDATE_ROOM_LABEL,
                                        payload: this.serverApi.http$updateLabel(e),
                                        meta: {
                                            updateLabel: e
                                        }
                                    })]
                                }))
                            }))
                        }
                    }, e.prototype.action$removeRoomLabels = function(e, t) {
                        var n = this;
                        return void 0 === t && (t = !1),
                            function(r, i) {
                                return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                    var n = this;
                                    return (0, v.__generator)(this, (function(o) {
                                        return t && e.map((function(e) {
                                            var t, r = e.chatroomId,
                                                o = e.labelId,
                                                s = i().chatrooms.byId[r];
                                            return (null === (t = null == s ? void 0 : s.labelIds) || void 0 === t ? void 0 : t.includes(o)) ? n.serverApi.http$deleteLabel({
                                                chatroomId: r,
                                                labelId: o
                                            }) : Promise.resolve()
                                        })), r({
                                            type: je.REMOVE_ROOM_LABELS,
                                            payload: e
                                        }), [2]
                                    }))
                                }))
                            }
                    }, e.prototype.action$handleRoomArchived = function(e) {
                        var t = this;
                        return function(n) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, this.decrementCounters(n, e)];
                                        case 1:
                                            return t.sent(), n({
                                                type: je.HANDLE_ROOM_ARCHIVED,
                                                meta: {
                                                    chatroomId: e
                                                }
                                            }), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$handleRoomUnarchived = function(e) {
                        var t = this;
                        return function(n, r) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    return n({
                                        type: je.HANDLE_ROOM_UNARCHIVED,
                                        meta: {
                                            chatroomId: e,
                                            chatroom: r().chatrooms.byId[e]
                                        }
                                    }), [2]
                                }))
                            }))
                        }
                    }, e.prototype.archiveRoom = function(e) {
                        var t = this;
                        return function(n) {
                            return Promise.all([t.decrementCounters(n, e), n({
                                type: je.ARCHIVE_ROOM,
                                payload: t.serverApi.http$archiveChatroom({
                                    chatroomId: e
                                }),
                                meta: {
                                    chatroomId: e
                                }
                            })])
                        }
                    }, e.prototype.unarchiveRoom = function(e) {
                        var t = this;
                        return function(n, r) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return [4, n({
                                                type: je.UNARCHIVE_ROOM,
                                                payload: this.serverApi.http$unarchiveChatroom({
                                                    chatroomId: e
                                                }),
                                                meta: {
                                                    chatroomId: e,
                                                    chatroom: r().chatrooms.byId[e]
                                                }
                                            })];
                                        case 1:
                                            return t.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.fetchRooms = function(e) {
                        var t = this,
                            n = void 0 === e ? {
                                filter: {},
                                cursor: void 0,
                                isSilent: !1
                            } : e,
                            r = n.filter,
                            i = n.cursor,
                            o = n.isSilent,
                            s = void 0 !== o && o;
                        return function(e) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                var t, n, o, a;
                                return (0, v.__generator)(this, (function(c) {
                                    switch (c.label) {
                                        case 0:
                                            return t = this.getPageSize(this.experiments, l.SdkExperiment.FetchChatroomsPageSize, l.FetchChatroomsPageSizeDefaultValue), n = {
                                                nextPointer: i,
                                                filter: r,
                                                pageSize: t
                                            }, o = this.serverApi.http$fetchChatrooms(n), a = ht()(), [4, e({
                                                type: je.FETCH_ROOMS,
                                                payload: o,
                                                meta: {
                                                    filter: r,
                                                    isSilent: s,
                                                    isFetchMore: !!i,
                                                    actionClusterId: a
                                                }
                                            })];
                                        case 1:
                                            return c.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.addRooms = function(e) {
                        return {
                            type: je.ADD_ROOMS,
                            rooms: e
                        }
                    }, e.prototype.action$addMessage = function(e, t, n) {
                        return function(r) {
                            r({
                                type: je.ADD_MESSAGE,
                                message: e,
                                messageSentByCurrentUser: t,
                                meta: {
                                    chatroom: n
                                }
                            })
                        }
                    }, e.prototype.action$sendMessage = function(e) {
                        return this.serverApi.http$notifyTyping(e.chatroomId, "stop"), {
                            type: je.SEND_MESSAGE,
                            payload: this.serverApi.http$sendMessage(e.chatroomId, e),
                            meta: {
                                message: e.dto
                            }
                        }
                    }, e.prototype.action$updateMessage = function(e) {
                        return function(t) {
                            t({
                                type: je.UPDATE_MESSAGE,
                                message: e
                            })
                        }
                    }, e.prototype.action$sendPostbackMessage = function(e, t) {
                        e.createdAt = e.createdAt || Date.now();
                        var n = e.type,
                            r = e.sender,
                            i = e.id;
                        j.j8(j.X3.MESSAGE_SENT, e), j.j8(j.X3.BI, (0, v.__assign)((0, v.__assign)({}, ut), {
                            messageId: i,
                            chatRoomId: e.chatroomId,
                            messageType: n,
                            uuid: null == r ? void 0 : r.userId,
                            mimeType: e.mimeTypes,
                            hostName: lt.appName
                        }));
                        var o = this.serverApi.http$sendMessageV2(e, t).catch((function(e) {
                            throw j.j8(j.X3.BI_ERROR, {
                                tag: "send-message",
                                description: "failed to send message",
                                errorName: e
                            }), e
                        }));
                        return {
                            type: je.SEND_MESSAGE,
                            payload: o,
                            meta: {
                                message: e.dto
                            }
                        }
                    }, e.prototype.action$deleteMessage = function(e, t) {
                        var n = this;
                        return void 0 === t && (t = !1),
                            function(r, i) {
                                return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                    var n, o, s;
                                    return (0, v.__generator)(this, (function(a) {
                                        switch (a.label) {
                                            case 0:
                                                return t && (n = i().messages.byId[e]) && (o = n.sequence, s = n.chatroomId, this.serverApi.http$deleteMessage({
                                                    chatroomId: s,
                                                    messageSequenceToDelete: o
                                                })), [4, r({
                                                    type: je.DELETE_MESSAGE,
                                                    meta: {
                                                        messageId: e
                                                    }
                                                })];
                                            case 1:
                                                return a.sent(), [2]
                                        }
                                    }))
                                }))
                            }
                    }, e.prototype.action$resendMessage = function(e) {
                        var t = this;
                        return function(n, r) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                var t, i, o;
                                return (0, v.__generator)(this, (function(s) {
                                    switch (s.label) {
                                        case 0:
                                            return (t = r().messages.byId[e]) && (i = t.sequence, o = t.chatroomId, this.serverApi.http$resendMessage({
                                                chatroomId: o,
                                                messageSequenceToReSend: i
                                            })), [4, n({
                                                type: je.RESEND_MESSAGE,
                                                meta: {
                                                    messageId: e
                                                }
                                            })];
                                        case 1:
                                            return s.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$setMessagesRead = function(e, t) {
                        var n = this;
                        return function(r, i) {
                            return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return [4, r({
                                                type: je.SET_MESSAGES_READ,
                                                payload: this.serverApi.http$setMessagesRead({
                                                    chatroomId: e,
                                                    lastReadMessageSequence: t
                                                }),
                                                meta: {
                                                    chatroomId: e,
                                                    lastReadMessageSequence: t,
                                                    chatroom: i().chatrooms.byId[e]
                                                }
                                            })];
                                        case 1:
                                            return n.sent(), [4, this.decrementUnseenCounter(r, e)];
                                        case 2:
                                            return n.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$setMessagesReadForSelf = function(e, t) {
                        var n = this;
                        return function(r, i) {
                            return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                var n;
                                return (0, v.__generator)(this, (function(o) {
                                    switch (o.label) {
                                        case 0:
                                            return n = function(e, t) {
                                                return (e.chatrooms.byId[t] || {}).lastReadMessageSequence
                                            }(i(), e), !n || t > n ? [4, r({
                                                type: je.SET_MESSAGES_READ_FOR_SELF,
                                                meta: {
                                                    chatroomId: e,
                                                    lastReadMessageSequence: t
                                                }
                                            })] : [3, 3];
                                        case 1:
                                            return o.sent(), [4, this.decrementCounters(r, e)];
                                        case 2:
                                            o.sent(), o.label = 3;
                                        case 3:
                                            return [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$setRoomsMessagesRead = function(e, t) {
                        var n = this;
                        return function(r) {
                            return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                var n = this;
                                return (0, v.__generator)(this, (function(i) {
                                    return [2, Promise.all((0, v.__spreadArrays)([r({
                                        type: je.SET_ROOMS_MESSAGES_READ,
                                        payload: this.serverApi.http$markRoomsAsRead(e, t),
                                        meta: {
                                            chatroomIds: e
                                        }
                                    })], e.map((function(e) {
                                        return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                            return (0, v.__generator)(this, (function(t) {
                                                switch (t.label) {
                                                    case 0:
                                                        return [4, this.decrementUnseenCounter(r, e)];
                                                    case 1:
                                                        return t.sent(), [2]
                                                }
                                            }))
                                        }))
                                    }))))]
                                }))
                            }))
                        }
                    }, e.prototype.action$setRoomsMessagesUnread = function(e, t) {
                        var n = this;
                        return void 0 === t && (t = !0),
                            function(r) {
                                return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                    return (0, v.__generator)(this, (function(n) {
                                        return [2, [r({
                                            type: je.SET_ROOMS_MESSAGES_UNREAD,
                                            payload: t ? this.serverApi.http$markRoomsAsUnread(e) : Promise.resolve(!0),
                                            meta: {
                                                chatroomIdsAndLastReadMessageSequences: e
                                            }
                                        })]]
                                    }))
                                }))
                            }
                    }, e.prototype.action$setLastMessageUnread = function(e, t, n) {
                        var r = this;
                        return void 0 === n && (n = !0),
                            function(i, o) {
                                return (0, v.__awaiter)(r, void 0, void 0, (function() {
                                    return (0, v.__generator)(this, (function(r) {
                                        switch (r.label) {
                                            case 0:
                                                return [4, i({
                                                    type: je.SET_LAST_MESSAGE_UNREAD,
                                                    payload: n ? this.serverApi.http$setMessagesUnread({
                                                        chatroomId: e,
                                                        lastReadMessageSequence: t
                                                    }) : Promise.resolve(!0),
                                                    meta: {
                                                        chatroomId: e,
                                                        lastReadMessageSequence: t,
                                                        chatroom: o().chatrooms.byId[e]
                                                    }
                                                })];
                                            case 1:
                                                return r.sent(), [2]
                                        }
                                    }))
                                }))
                            }
                    }, e.prototype.typing = function(e, t) {
                        return {
                            type: je.TYPING,
                            text: t,
                            meta: {
                                chatroomId: e
                            }
                        }
                    }, e.prototype.fetchMessageDrafts = function() {
                        return {
                            type: je.FETCH_MESSAGE_DRAFTS,
                            payload: this.persistence.loadMessageDrafts()
                        }
                    }, e.prototype.action$changeTypingStatus = function(e) {
                        return {
                            type: je.TYPING_STATUS_CHANGE,
                            payload: e
                        }
                    }, e.prototype.action$fetchRoomParticipantsDisplayData = function(e, t) {
                        return {
                            type: je.FETCH_PARTICIPANTS_DISPLAY_DATA,
                            payload: this.serverApi.http$fetchParticipantsDisplayData({
                                chatroomId: e,
                                participantIds: t
                            })
                        }
                    }, e.prototype.decrementCounters = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return [4, this.decrementUnseenCounter(e, t)];
                                    case 1:
                                        return n.sent(), [2]
                                }
                            }))
                        }))
                    }, e.prototype.decrementUnseenCounter = function(e, t) {
                        return e(this.unreadChatroomCountActions.markChatroomAsRead(t)), e(this.unseenChatroomCountActions.markChatroomAsSeen(t))
                    }, e.prototype.action$deleteRooms = function(e) {
                        var t = this;
                        return function(n) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                var t = this;
                                return (0, v.__generator)(this, (function(r) {
                                    return [2, Promise.all((0, v.__spreadArrays)([n({
                                        type: je.DELETE_ROOMS,
                                        payload: this.serverApi.http$deleteChatrooms(e),
                                        meta: {
                                            chatroomIds: e
                                        }
                                    })], e.map((function(e) {
                                        return t.decrementCounters(n, e)
                                    }))))]
                                }))
                            }))
                        }
                    }, e.prototype.archiveRooms = function(e) {
                        var t = this;
                        return function(n) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                var t = this;
                                return (0, v.__generator)(this, (function(r) {
                                    return [2, Promise.all((0, v.__spreadArrays)([n({
                                        type: je.ARCHIVE_ROOMS,
                                        payload: this.serverApi.http$archiveChatrooms(e),
                                        meta: {
                                            chatroomIds: e
                                        }
                                    })], e.map((function(e) {
                                        return t.decrementCounters(n, e)
                                    }))))]
                                }))
                            }))
                        }
                    }, e.prototype.unarchiveRooms = function(e) {
                        var t = this;
                        return function(n, r) {
                            return (0, v.__awaiter)(t, void 0, void 0, (function() {
                                var t;
                                return (0, v.__generator)(this, (function(i) {
                                    switch (i.label) {
                                        case 0:
                                            return [4, n({
                                                type: je.UNARCHIVE_ROOMS,
                                                payload: this.serverApi.http$unarchiveChatrooms(e),
                                                meta: {
                                                    chatroomIds: e,
                                                    chatrooms: e.map((function(e) {
                                                        return r().chatrooms.byId[e]
                                                    }))
                                                }
                                            })];
                                        case 1:
                                            return i.sent(), t = [], [4, Promise.all(t)];
                                        case 2:
                                            return i.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e.prototype.action$handleFilterChanged = function(e, t, n) {
                        var r = this;
                        return function(i) {
                            i(r.action$setCurrentFilter(e, t)), i(r.action$setFilteredRoomsIds(e, !0, n))
                        }
                    }, e.prototype.action$setCurrentFilter = function(e, t) {
                        return {
                            type: je.SET_CURRENT_FILTER,
                            meta: {
                                subscriberId: e,
                                filter: t
                            }
                        }
                    }, e.prototype.action$setFilteredRoomsIds = function(e, t, n) {
                        return {
                            type: je.SET_FILTERED_ROOMS_IDS,
                            meta: {
                                subscriberId: e,
                                filteredRoomsIds: n,
                                shouldOverride: t
                            }
                        }
                    }, e.prototype.getPageSize = function(e, t, n) {
                        var r = parseInt(function(e, t, n) {
                            var r = e[t];
                            return void 0 === r ? n : r
                        }(e, t, n));
                        return isNaN(r) ? parseInt(n) : r
                    }, e
                }(),
                vt = function(e, t, n, r, i, o) {
                    return new _t(e, t, n, r, i, o)
                },
                yt = function() {
                    function e(e) {
                        this.serverApi = e
                    }
                    return e.prototype.action$fetchDrillInMessageIndications = function(e, t) {
                        return {
                            type: je.FETCH_DRILL_IN_MESSAGE_INDICATIONS,
                            payload: this.serverApi.http$fetchDrillInMessageIndications(e, t).then((function(e) {
                                return j.j8(j.xc.FETCH_DRILL_IN_MESSAGE_INDICATIONS_COMPLETED, e), e
                            }))
                        }
                    }, e.prototype.action$updateMessagesIndications = function(e) {
                        return {
                            type: je.UPDATE_MESSAGES_INDICATIONS,
                            payload: e
                        }
                    }, e.prototype.action$fetchRoomParticipantsDisplayData = function(e, t) {
                        return {
                            type: je.FETCH_PARTICIPANTS_DISPLAY_DATA,
                            payload: this.serverApi.http$fetchParticipantsDisplayData({
                                chatroomId: e,
                                participantIds: t
                            })
                        }
                    }, e
                }(),
                bt = function(e) {
                    return new yt(e)
                },
                It = function() {
                    function e(e) {
                        this.chatAgent = e
                    }
                    return e.prototype.updateHttpHeaders = function(e) {
                        this.chatAgent.updateHttpHeaders(e)
                    }, e.prototype.http$fetchChatrooms = function(t) {
                        var n = t.nextPointer,
                            r = t.filter,
                            i = void 0 === r ? {} : r,
                            o = t.pageSize,
                            s = void 0 === o ? 100 : o,
                            a = t.unreadChatroomLimit,
                            c = {
                                nextPointer: n,
                                pageSize: s,
                                archived: i.isArchived,
                                onlyUnread: i.isUnread,
                                lastMessageLimit: e.LAST_MESSAGES_COUNT_LIMIT,
                                unreadChatroomLimit: a || e.DEFAULT_UNREAD_CHATROOM_IDS_COUNT_LIMIT
                            },
                            u = {
                                participantIds: i.participantIds || [],
                                labelIds: i.labelIds || []
                            },
                            l = "chatrooms-for-list-view" + (i.participantType ? "/" + i.participantType : "");
                        return this.chatAgent.post({
                            urlSuffix: l,
                            data: u,
                            query: c
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$search = function(t) {
                        var n = t.searchTerm,
                            r = t.participantIds,
                            i = t.chatroomsPageSize,
                            o = t.chatroomsNextPointer,
                            s = t.messagesPageSize,
                            a = t.messagesNextPointer,
                            c = {
                                query: n,
                                participantIds: r,
                                chatroomsPaginator: {
                                    pageSize: i,
                                    lastMessageLimit: e.LAST_MESSAGES_COUNT_LIMIT,
                                    nextPointer: o
                                },
                                messagesPaginator: {
                                    pageSize: s,
                                    nextPointer: a
                                }
                            };
                        return this.chatAgent.post({
                            urlPrefix: "_serverless/",
                            urlSuffix: "chat-search/search",
                            data: c
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchRoomMessages = function(e) {
                        var t = e.chatroomId,
                            n = e.cursor,
                            r = e.pageSize,
                            i = {
                                pageSize: void 0 === r ? 50 : r,
                                ordering: e.cursorStrategy || "Desc"
                            },
                            o = n || 0 === n ? (0, v.__assign)((0, v.__assign)({}, i), {
                                nextPointer: n
                            }) : i;
                        return this.chatAgent.get({
                            urlSuffix: "chatrooms/" + t + "/messages",
                            query: o
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchRoomMessagesWindow = function(e) {
                        var t = e.chatroomId,
                            n = e.cursor,
                            r = e.pageSize,
                            i = {
                                pageSize: void 0 === r ? 50 : r,
                                pointer: n
                            };
                        return this.chatAgent.get({
                            urlSuffix: "chatrooms/" + t + "/messages/page",
                            query: i
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$deleteMessage = function(e) {
                        var t = e.chatroomId,
                            n = e.messageSequenceToDelete;
                        return this.chatAgent.zdelete({
                            urlSuffix: "chatrooms/" + t + "/messages",
                            data: {
                                messageSequenceToDelete: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$resendMessage = function(e) {
                        var t = e.chatroomId,
                            n = e.messageSequenceToReSend;
                        return this.chatAgent.post({
                            urlSuffix: "chatrooms/" + t + "/messages/resend",
                            data: {
                                messageSequenceToReSend: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$deleteLabel = function(e) {
                        var t = e.chatroomId,
                            n = e.labelId;
                        return this.chatAgent.zdelete({
                            urlSuffix: "chatrooms/label",
                            data: {
                                chatroomId: t,
                                labelId: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$updateLabel = function(e) {
                        var t = e.chatroomId,
                            n = e.labelId;
                        return this.chatAgent.post({
                            urlSuffix: "chatrooms/label",
                            data: {
                                chatroomId: t,
                                labelId: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchMessagesErrorIndications = function(e) {
                        var t = e.chatroomId,
                            n = e.from,
                            r = e.to;
                        return this.chatAgent.get({
                            urlSuffix: "indications/" + t + "/failed",
                            query: {
                                from: n,
                                to: r
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchRoomMessagesPage = function(e) {
                        var t = e.chatroomId,
                            n = e.messageSequence,
                            r = e.pageSize,
                            i = void 0 === r ? 30 : r;
                        return this.chatAgent.get({
                            urlSuffix: "chatrooms/" + t + "/messages/page",
                            query: {
                                pageSize: i,
                                pointer: n
                            }
                        }).then((function(e) {
                            return e.data.items
                        }))
                    }, e.prototype.http$fetchRoom = function(e) {
                        var t = e.chatroomId;
                        return this.chatAgent.get({
                            urlSuffix: "chatrooms/" + t
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchEnrichedChatroom = function(e) {
                        var t = e.chatroomId,
                            n = e.force,
                            r = void 0 !== n && n;
                        return this.chatAgent.get({
                            urlSuffix: "chatrooms/" + t + "/enriched",
                            force: r
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchUnreadChatroomIds = function(t) {
                        var n = void 0 === t ? {} : t,
                            r = n.unreadChatroomLimit,
                            i = void 0 === r ? e.DEFAULT_UNREAD_CHATROOM_IDS_COUNT_LIMIT : r,
                            o = n.filter;
                        if (o) {
                            var s = o.participantIds;
                            return this.chatAgent.post({
                                urlSuffix: "unread-chatrooms",
                                data: {
                                    participantIds: s
                                },
                                query: {
                                    unreadChatroomLimit: i
                                }
                            }).then((function(e) {
                                return e.data
                            }))
                        }
                        return this.chatAgent.get({
                            urlSuffix: "unread-chatrooms",
                            query: {
                                unreadChatroomLimit: i
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchUnreadChatroomIdsMap = function(e) {
                        var t = void 0 === e ? {} : e,
                            n = t.unreadChatroomLimit,
                            r = void 0 === n ? c : n,
                            i = (t.filter || {}).participantIds;
                        return this.chatAgent.post({
                            urlSuffix: "unread-chatrooms-per-participant",
                            data: {
                                participantIds: i
                            },
                            query: {
                                unreadChatroomLimit: r
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$setMessagesRead = function(e) {
                        var t = e.chatroomId,
                            n = e.lastReadMessageSequence;
                        return j.j8(j.X3.MESSAGES_READ, t), this.chatAgent.put({
                            urlSuffix: "chatrooms/" + t + "/users",
                            data: {
                                lastReadMessageSequence: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$setMessagesUnread = function(e) {
                        var t = e.chatroomId,
                            n = e.lastReadMessageSequence;
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/" + t + "/unread",
                            data: {
                                lastReadMessageSequence: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$deleteChatroom = function(e) {
                        var t = e.chatroomId;
                        return this.chatAgent.zdelete({
                            urlSuffix: "chatrooms/" + t
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$deleteChatrooms = function(e) {
                        return this.chatAgent.zdelete({
                            urlSuffix: "chatrooms",
                            data: {
                                chatroomIds: e
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$archiveChatroom = function(e) {
                        var t = e.chatroomId;
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/" + t + "/archive"
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$archiveChatrooms = function(e) {
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/archive",
                            data: {
                                chatroomIds: e
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$unarchiveChatrooms = function(e) {
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/unarchive",
                            data: {
                                chatroomIds: e
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$unarchiveChatroom = function(e) {
                        var t = e.chatroomId;
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/" + t + "/unarchive"
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$initRealtimeToken = function(e) {
                        return this.chatAgent.post({
                            urlSuffix: "real-time-tokens",
                            data: {
                                token: e
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$sendMessage = function(e, t) {
                        t.createdAt = t.createdAt || Date.now();
                        var n = t.type,
                            r = t.sender,
                            i = t.id;
                        return j.j8(j.X3.MESSAGE_SENT, t), j.j8(j.X3.BI, (0, v.__assign)((0, v.__assign)({}, ut), {
                            messageId: i,
                            chatRoomId: e,
                            messageType: n,
                            uuid: null == r ? void 0 : r.userId,
                            mimeType: t.mimeTypes,
                            hostName: lt.appName
                        })), this.chatAgent.post({
                            urlSuffix: "chatrooms/" + e + "/messages",
                            data: t.dto
                        }).then((function(e) {
                            return e.data
                        })).catch((function(e) {
                            throw j.j8(j.X3.BI_ERROR, {
                                tag: "send-message",
                                description: "failed to send message",
                                errorName: e
                            }), e
                        }))
                    }, e.prototype.http$sendMessageV2 = function(e, t) {
                        return this.chatAgent.post({
                            urlPrefix: "_api/chat-web/v2/",
                            urlSuffix: "chatrooms/" + e.chatroomId + "/messages",
                            data: {
                                sendMessageBody: e.dto,
                                sendMessageOptions: t.dto
                            }
                        })
                    }, e.prototype.http$fetchCurrentUserDisplayData = function() {
                        return this.chatAgent.get({
                            urlSuffix: "display-data/current-user"
                        }).then((function(e) {
                            return e.data ? e.data.content : void 0
                        }))
                    }, e.prototype.http$notifyTyping = function(e, t, n) {
                        return this.chatAgent.post({
                            urlSuffix: "chatrooms/" + e + "/typing-events",
                            data: {
                                type: t,
                                expiryDuration: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$markRoomsAsRead = function(e, t) {
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/read",
                            data: {
                                chatroomIds: e,
                                lastMessageSequence: t
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$markAllRoomsAsRead = function(e) {
                        var t = {
                            participantId: e.participantIds,
                            participantType: e.participantType
                        };
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/mark-all-read",
                            query: t
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$markRoomsAsUnread = function(e) {
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/unread",
                            data: {
                                chatroomIdsAndLastReadMessageSequences: e
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchParticipantsDisplayData = function(e) {
                        var t = e.chatroomId,
                            n = e.participantIds;
                        return this.chatAgent.post({
                            urlSuffix: "display-data/" + t,
                            data: {
                                participantIds: n
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchDrillInMessageIndications = function(e, t) {
                        return this.chatAgent.get({
                            urlSuffix: "indications/" + e + "/detailed",
                            query: {
                                sequence: t
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$fetchUnseenChatroomCount = function(t, n) {
                        return void 0 === n && (n = e.DEFAULT_UNREAD_CHATROOM_IDS_COUNT_LIMIT), this.chatAgent.get({
                            urlSuffix: "unseen-chatrooms",
                            query: (0, v.__assign)((0, v.__assign)({}, t), {
                                limit: n
                            })
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$markChatroomsAsSeen = function(e, t) {
                        return this.chatAgent.put({
                            urlSuffix: "chatrooms/seen",
                            data: {
                                lastSeenMessageSequence: t
                            },
                            query: e
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$watch = function(e) {
                        return this.chatAgent.put({
                            urlSuffix: "chat-presence/watch/group",
                            data: {
                                useNewConvention: e
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.prototype.http$setPresence = function(e, t) {
                        return this.chatAgent.post({
                            urlPrefix: "_api/chat-presence-server/v1/",
                            urlSuffix: "presence/user-presence",
                            data: {
                                userPresence: e,
                                token: t,
                                context: {
                                    operation: "UPDATE"
                                }
                            }
                        }).then((function(e) {
                            return e.data
                        }))
                    }, e.LAST_MESSAGES_COUNT_LIMIT = 10, e.DEFAULT_UNREAD_CHATROOM_IDS_COUNT_LIMIT = 100, e
                }(),
                Et = It,
                St = n(88144),
                wt = n.n(St),
                Ct = function() {
                    function e() {
                        this._decodedToken = {}
                    }
                    return e.prototype.loadJwtChatToken = function(e) {
                        try {
                            var t = e.split(".")[1];
                            this._decodedToken = JSON.parse(wt().decode(t) || "{}")
                        } catch (e) {
                            this._decodedToken = {}
                        }
                    }, Object.defineProperty(e.prototype, "token", {
                        get: function() {
                            return this._token
                        },
                        set: function(e) {
                            this._token = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "displayData", {
                        get: function() {
                            return this._displayData
                        },
                        set: function(e) {
                            this._displayData = e
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "type", {
                        get: function() {
                            return this._decodedToken.type
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "participantIds", {
                        get: function() {
                            return this._decodedToken.participantIds
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "userId", {
                        get: function() {
                            return this._decodedToken.userId
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "tokenExpirationTime", {
                        get: function() {
                            return this._decodedToken.exp
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isExpiredToken", {
                        get: function() {
                            return 1e3 * (this.tokenExpirationTime || 0) - (new Date).getTime() < 1e3
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(),
                Tt = n(33259),
                At = n.n(Tt),
                Rt = {
                    serverApiThrottlingTimout: 2e3,
                    localStateThrottlingTimout: 1e3
                },
                Pt = function() {
                    function e(e, t, n, r, i) {
                        var o = this;
                        void 0 === i && (i = Rt), this.store = e, this.chatroomsActions = t, this.serverApi = n, this.persistenceService = r, this.config = i, this.sendTypingEventToServerThrottled = At()((function(e) {
                            return (0, v.__awaiter)(o, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    return [2, this.serverApi.http$notifyTyping(e, "start", 5e3)]
                                }))
                            }))
                        }), this.config.serverApiThrottlingTimout, {
                            leading: !0,
                            trailing: !1
                        }), this.sendTypingEventThrottled = At()((function(e) {
                            var t = e.chatroomId,
                                n = e.text;
                            return (0, v.__awaiter)(o, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(e) {
                                    return this.store.dispatch(this.chatroomsActions.typing(t, n)), this.persistMessageDraft({
                                        chatroomId: t,
                                        text: n
                                    }), [2]
                                }))
                            }))
                        }), this.config.localStateThrottlingTimout, {
                            leading: !0,
                            trailing: !0
                        })
                    }
                    return e.prototype.notifyTextChange = function(e, t, n) {
                        void 0 === n && (n = !1), void 0 !== t && this.sendTypingEventThrottled({
                            chatroomId: e,
                            text: t
                        }), n && this.sendTypingEventToServerThrottled(e)
                    }, e.prototype.notifyTyping = function(e, t) {
                        this.notifyTextChange(e, t, !0)
                    }, e.prototype.persistMessageDraft = function(e) {
                        var t = e.chatroomId,
                            n = e.text;
                        this.canPersist() && this.sendMessageDraftToPersistence({
                            chatroomId: t,
                            text: n
                        })
                    }, e.prototype.canPersist = function() {
                        return !this.store.getState().messageDraft.isFetching
                    }, e.prototype.sendMessageDraftToPersistence = function(e) {
                        var t, n = e.chatroomId,
                            r = e.text,
                            i = this.store.getState().messageDraft.byId,
                            o = (0, v.__assign)((0, v.__assign)({}, i), ((t = {})[n] = r, t));
                        this.persistenceService.saveMessageDrafts(o)
                    }, e
                }(),
                Ot = Pt,
                kt = {
                    setItem: function() {
                        return Promise.resolve()
                    },
                    getItem: function() {
                        return Promise.resolve(JSON.stringify({}))
                    },
                    removeItem: function() {
                        return Promise.resolve("remove")
                    }
                },
                Nt = "crm.chat.MESSAGE_DRAFT_PERSISTENCE_KEY",
                Dt = "crm.chat.CHAT_TOKEN_PERSISTENCE_KEY",
                Mt = function(e) {
                    return e ? JSON.parse(e) : e
                },
                xt = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = kt), void 0 === t && (t = ""), void 0 === n && (n = []), this.persistenceEngine = e, this.userBasedPrefix = t + "_" + n.join("_")
                    }
                    return e.prototype.saveMessageDrafts = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(t) {
                                return [2, this.setItemForUserId(Nt, JSON.stringify(e))]
                            }))
                        }))
                    }, e.prototype.loadMessageDrafts = function() {
                        return this.getItemForUserId(Nt).then(Mt).catch((function(e) {
                            return console.warn("Error while loading message draft data from persistence " + e), {}
                        }))
                    }, e.prototype.clearMessageDrafts = function() {
                        return this.removeItemForUserId(Nt).catch((function(e) {
                            return console.warn("Error while removing message draft from persistence " + e), {}
                        }))
                    }, e.prototype.saveToken = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(t) {
                                return [2, this.persistenceEngine.setItem(Dt, e)]
                            }))
                        }))
                    }, e.prototype.getChatToken = function() {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(e) {
                                return [2, this.persistenceEngine.getItem(Dt)]
                            }))
                        }))
                    }, e.prototype.clearToken = function() {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(e) {
                                return [2, this.persistenceEngine.removeItem(Dt)]
                            }))
                        }))
                    }, e.prototype.removeItemForUserId = function(e) {
                        return this.persistenceEngine.removeItem(this.userBasedPrefix + "_" + e)
                    }, e.prototype.getItemForUserId = function(e) {
                        return this.persistenceEngine.getItem(this.userBasedPrefix + "_" + e)
                    }, e.prototype.setItemForUserId = function(e, t) {
                        return this.persistenceEngine.setItem(this.userBasedPrefix + "_" + e, t)
                    }, e
                }(),
                Lt = xt,
                Ut = n(56786),
                Ft = n.n(Ut),
                jt = function() {
                    function e() {
                        this.reset()
                    }
                    return e.prototype.registerSubscription = function(e, t, n) {
                        var r = this;
                        f()(e) && (e = {
                            isArchived: !1
                        });
                        var i = ht()(),
                            o = Ft()(Object.values(this.refreshDataCallbacks), (function(t) {
                                return z()(e, t.identifier)
                            }));
                        return o ? function() {
                            return o
                        } : (n && n(), this.refreshDataCallbacks[i] = {
                            identifier: e,
                            refreshDataCallback: t
                        }, function() {
                            delete r.refreshDataCallbacks[i]
                        })
                    }, e.prototype.refreshSubscribedData = function() {
                        var e = Object.values(this.refreshDataCallbacks, (function(e) {
                            return e.identifier
                        })).map((function(e) {
                            return (0, e.refreshDataCallback)()
                        }));
                        return Promise.all(e)
                    }, e.prototype.reset = function() {
                        this.refreshDataCallbacks = {}
                    }, e
                }(),
                qt = function() {
                    function e(e) {
                        this.baseURL = e.baseURL, this.requestHandler = so.getRequestHandler()
                    }
                    return e.prototype.get = function(e, t) {
                        return void 0 === t && (t = {}), this._request("get", e, t)
                    }, e.prototype.post = function(e, t, n) {
                        return void 0 === n && (n = {}), this._request("post", e, n, {
                            data: t
                        })
                    }, e.prototype.zdelete = function(e, t) {
                        return this._request("delete", e, {}, {
                            data: t
                        })
                    }, e.prototype.put = function(e, t, n) {
                        return void 0 === t && (t = {}), void 0 === n && (n = {}), this._request("put", e, n, {
                            data: t
                        })
                    }, e.prototype._request = function(e, t, n, r) {
                        void 0 === n && (n = {}), void 0 === r && (r = {});
                        var i = this._getRequestConfig(e, t, n, r);
                        return this.requestHandler(i)
                    }, e.prototype._getRequestConfig = function(e, t, n, r) {
                        var i = this._getRelativeUrl(t, n, r),
                            o = this.baseURL,
                            s = this._getHeaders(t, n, r);
                        return Object.assign({
                            url: i,
                            method: e,
                            baseURL: o
                        }, s ? {
                            headers: s
                        } : void 0, r)
                    }, e
                }(),
                Ht = function(e) {
                    function t(t) {
                        var n = t.baseURL,
                            r = t.isForUnifiedList,
                            i = t.authorization,
                            o = e.call(this, {
                                baseURL: n
                            }) || this;
                        return o.isForUnifiedList = r, o.authorization = i, o
                    }
                    return (0, v.__extends)(t, e), t.prototype._getHeaders = function() {
                        var e = {
                            Accept: "application/json",
                            "Content-Type": "application/json"
                        };
                        return this.authorization && (e.Authorization = this.authorization), e
                    }, t.prototype._getRelativeUrl = function(e) {
                        return "/wix-chat-tokens-server/v1/" + e + "?isForUnifiedList=" + this.isForUnifiedList
                    }, t
                }(qt);

            function Wt(e) {
                return (0, v.__awaiter)(this, void 0, void 0, (function() {
                    var t, n, r, i, o;
                    return (0, v.__generator)(this, (function(s) {
                        switch (s.label) {
                            case 0:
                                return t = e.url, n = e.authorization, r = e.isForUnifiedList, i = new Ht({
                                    baseURL: t,
                                    authorization: n,
                                    isForUnifiedList: r
                                }), o = function(e) {
                                    var t = e.handshakeAgent;
                                    return {
                                        http$getToken: function() {
                                            return (0, v.__awaiter)(this, void 0, void 0, (function() {
                                                var e, n;
                                                return (0, v.__generator)(this, (function(r) {
                                                    switch (r.label) {
                                                        case 0:
                                                            return [4, t.post("chat-tokens")];
                                                        case 1:
                                                            if (e = r.sent(), n = k()(e, ["data", "chatToken"])) return [2, n];
                                                            throw Error("no token: " + e)
                                                    }
                                                }))
                                            }))
                                        }
                                    }
                                }({
                                    handshakeAgent: i
                                }), [4, o.http$getToken()];
                            case 1:
                                return [2, s.sent()]
                        }
                    }))
                }))
            }

            function Bt(e) {
                return (0, v.__awaiter)(this, void 0, void 0, (function() {
                    var t;
                    return (0, v.__generator)(this, (function(n) {
                        switch (n.label) {
                            case 0:
                                return e ? [4, new Lt(e).getChatToken()] : [3, 2];
                            case 1:
                                if ((t = n.sent()) && !Gt(t)) return [2, t];
                                n.label = 2;
                            case 2:
                                return [2]
                        }
                    }))
                }))
            }

            function Vt(e, t) {
                return (0, v.__awaiter)(this, void 0, void 0, (function() {
                    return (0, v.__generator)(this, (function(n) {
                        switch (n.label) {
                            case 0:
                                return t ? [4, new Lt(t).saveToken(e)] : [3, 2];
                            case 1:
                                return [2, n.sent()];
                            case 2:
                                return [2]
                        }
                    }))
                }))
            }

            function Gt(e) {
                var t = new Ct;
                return t.loadJwtChatToken(e), t.isExpiredToken
            }
            var zt = n(33348),
                $t = n.n(zt),
                Kt = "_api/chat-web/v1/",
                Yt = "_api/chat-web/v2/",
                Jt = function(e) {
                    function t(t) {
                        var n = this,
                            r = t.baseURL,
                            i = t.currentUser,
                            o = t.httpHeaders,
                            s = t.tokenServer;
                        return (n = e.call(this, {
                            baseURL: r
                        }) || this).currentUser = i, n.headers = o, n.tokenServer = s, n
                    }
                    return (0, v.__extends)(t, e), t.prototype.updateHttpHeaders = function(e) {
                        this.headers = (0, v.__assign)((0, v.__assign)({}, this.headers), e)
                    }, t.prototype._getRelativeUrl = function(e, t) {
                        var n = (null == e ? void 0 : e.startsWith(Yt)) ? {} : {
                                chatToken: this.currentUser.token
                            },
                            r = Object.assign(n, t);
                        return "/" + e + "?" + $t().stringify(r, {
                            indices: !1
                        })
                    }, t.prototype._getHeaders = function(e) {
                        var t = (null == e ? void 0 : e.startsWith(Yt)) ? {
                            chatToken: this.currentUser.token
                        } : {};
                        return Object.assign(t, this.headers)
                    }, t.prototype._issueNewTokenIfNeeded = function() {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e;
                            return (0, v.__generator)(this, (function(t) {
                                switch (t.label) {
                                    case 0:
                                        return this.tokenServer && this.currentUser.isExpiredToken ? [4, Wt(this.tokenServer)] : [3, 2];
                                    case 1:
                                        e = t.sent(), this.currentUser = new Ct, this.currentUser.loadJwtChatToken(e), this.currentUser.token = e, t.label = 2;
                                    case 2:
                                        return [2]
                                }
                            }))
                        }))
                    }, t.prototype.post = function(t) {
                        var n = t.urlPrefix,
                            r = void 0 === n ? Kt : n,
                            i = t.urlSuffix,
                            o = t.data,
                            s = t.query,
                            a = void 0 === s ? {} : s;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return [4, this._issueNewTokenIfNeeded()];
                                    case 1:
                                        return n.sent(), t = "" + r + i, [2, e.prototype.post.call(this, t, o, a)]
                                }
                            }))
                        }))
                    }, t.prototype.get = function(t) {
                        var n = t.urlPrefix,
                            r = void 0 === n ? Kt : n,
                            i = t.urlSuffix,
                            o = t.query,
                            s = void 0 === o ? {} : o,
                            a = t.force,
                            c = void 0 !== a && a;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return [4, this._issueNewTokenIfNeeded()];
                                    case 1:
                                        return n.sent(), t = "" + r + i, c && (s.cache_buster = (new Date).getTime().toString()), [2, e.prototype.get.call(this, t, s)]
                                }
                            }))
                        }))
                    }, t.prototype.put = function(t) {
                        var n = t.urlPrefix,
                            r = void 0 === n ? Kt : n,
                            i = t.urlSuffix,
                            o = t.data,
                            s = t.query,
                            a = void 0 === s ? {} : s;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return [4, this._issueNewTokenIfNeeded()];
                                    case 1:
                                        return n.sent(), t = "" + r + i, [2, e.prototype.put.call(this, t, o, a)]
                                }
                            }))
                        }))
                    }, t.prototype.zdelete = function(t) {
                        var n = t.urlPrefix,
                            r = void 0 === n ? Kt : n,
                            i = t.urlSuffix,
                            o = t.data;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return [4, this._issueNewTokenIfNeeded()];
                                    case 1:
                                        return n.sent(), t = "" + r + i, [2, e.prototype.zdelete.call(this, t, o)]
                                }
                            }))
                        }))
                    }, t
                }(qt),
                Qt = n(9086),
                Xt = n.n(Qt),
                Zt = n(86205),
                en = n.n(Zt),
                tn = n(53079),
                nn = function(e) {
                    void 0 === e && (e = []);
                    var t, n = (t = so.store.getState(), t.messages || {}).byId;
                    return e.every((function(e) {
                        return void 0 === n[e.id]
                    }))
                },
                rn = {},
                on = {},
                sn = [],
                an = function(e, t, n) {
                    return void 0 === n && (n = !1), n ? e : Math.max(e || be, t || be)
                },
                cn = function(e, t, n, r) {
                    return e[t] ? void 0 === e[t][n] ? r : e[t][n] : r
                },
                un = {
                    enrichedChatroomLoaded: !1,
                    typingEvent: {},
                    overrideRegardlessOfSequenceComparison: !1
                },
                ln = function(e, t, n, r) {
                    var i;
                    void 0 === n && (n = []), void 0 === r && (r = un);
                    var o, s, a, c, u, l = t.id,
                        d = (0, v.__assign)((0, v.__assign)({}, un), r),
                        h = d.enrichedChatroomLoaded,
                        p = d.typingEvent,
                        f = d.overrideRegardlessOfSequenceComparison,
                        m = t.participantId,
                        g = t.lastMessage,
                        _ = t.unreadCount,
                        y = void 0 === _ ? cn(e, l, "unreadCount", 0) : _,
                        b = t.lastReadMessageSequence,
                        I = void 0 === b ? cn(e, l, "lastReadMessageSequence", be) : b,
                        E = t.lastSeenMessageSequence,
                        S = void 0 === E ? cn(e, l, "lastSeenMessageSequence", 0) : E,
                        w = t.displayData,
                        C = t.isPrivate,
                        T = t.offlineChannels,
                        A = t.clientReferenceType,
                        R = t.clientReference,
                        P = t.participantCount,
                        O = t.isArchived,
                        k = t.isTemporary,
                        N = t.createdBy,
                        D = t.createdAt,
                        M = t.businessContext,
                        x = t.pluginName,
                        L = t.sortRank,
                        U = t.labelIds,
                        F = t.lastMessages,
                        j = e,
                        q = j[l] || {
                            unreadCount: y,
                            lastReadMessageSequence: I,
                            lastSeenMessageSequence: S
                        },
                        H = q.typingStatus || sn,
                        W = En(H, p),
                        B = n && n.length > 0,
                        V = void 0 !== q.participants,
                        G = {
                            displayData: w ? (0, v.__assign)((0, v.__assign)({}, q.displayData), w) : q.displayData,
                            id: l,
                            cursor: q.cursor,
                            lastMessage: g || q.lastMessage,
                            lastMessages: F || q.lastMessages,
                            lastReadMessageSequence: an(I, q.lastReadMessageSequence, f),
                            lastSeenMessageSequence: an(S, q.lastSeenMessageSequence),
                            unreadCount: (o = y, s = q.unreadCount, a = I, c = q.lastReadMessageSequence, u = f, void 0 === u && (u = !1), u ? o : (c || be) > (a || be) ? s : o),
                            typingStatus: W,
                            isPrivate: void 0 !== C ? C : q.isPrivate,
                            clientReferenceType: A || q.clientReferenceType,
                            clientReference: R || q.clientReference,
                            offlineChannels: T || q.offlineChannels,
                            participantCount: void 0 !== P ? P : q.participantCount,
                            isArchived: void 0 !== O ? O : q.isArchived,
                            participantId: void 0 !== m ? m : q.participantId,
                            isTemporary: void 0 !== k ? k : q.isTemporary,
                            createdBy: void 0 !== N ? N : q.createdBy,
                            createdAt: void 0 !== D ? D : q.createdAt,
                            businessContext: M || q.businessContext,
                            enrichedChatroomLoaded: h || q.enrichedChatroomLoaded,
                            pluginName: x || q.pluginName,
                            sortRank: L || q.sortRank,
                            participants: B || !V ? n : q.participants,
                            labelIds: U || q.labelIds,
                            messageDeliveryError: q.messageDeliveryError
                        };
                    ! function(e, t) {
                        t.forEach((function(t) {
                            return void 0 === e[t] && delete e[t]
                        }))
                    }(G, ["image", "enrichedChatroomLoaded", "messageDeliveryError"]);
                    var z = (0, v.__assign)((0, v.__assign)({}, j), ((i = {})[l] = (0, v.__assign)((0, v.__assign)({}, q), G), i));
                    return (0, v.__assign)((0, v.__assign)({}, e), z)
                },
                dn = function(e, t, n) {
                    return void 0 === e && (e = []), void 0 === n && (n = !1), n ? en()(e, t) : e.concat(t)
                },
                hn = function(e, t, n) {
                    void 0 === n && (n = !1);
                    var r = t.reduce((function(t, r) {
                        var i, o = r.chatroomId,
                            s = r.labelId,
                            a = (0, v.__assign)((0, v.__assign)({}, e[o]), t[o] || {});
                        return a ? (0, v.__assign)((0, v.__assign)({}, t), ((i = {})[o] = (0, v.__assign)((0, v.__assign)({}, a), {
                            labelIds: dn(a.labelIds, s, n)
                        }), i)) : t
                    }), {});
                    return (0, v.__assign)((0, v.__assign)({}, e), r)
                },
                pn = function(e, t) {
                    return mn(e, t, !1)
                },
                fn = function(e, t) {
                    return mn(e, t, !0)
                },
                mn = function(e, t, n) {
                    return ln(e, {
                        id: t,
                        isArchived: n
                    })
                },
                gn = function(e, t) {
                    return ln(e, {
                        id: t,
                        unreadCount: (e[t].unreadCount || 0) + 1,
                        lastReadMessageSequence: e[t].lastReadMessageSequence
                    })
                },
                _n = function(e, t) {
                    return ln(e, {
                        id: t.chatroomId,
                        lastMessage: t
                    })
                };

            function vn(e, t) {
                var n = t[e.id];
                return k()(e, "lastMessages.0.sequence") < k()(n, "lastMessages.0.sequence")
            }
            var yn = function(e) {
                var t, n, r, i, o, s, a, c, u, l, d = (null === (t = e.payload.items) || void 0 === t ? void 0 : t.length) && (null === (i = null === (n = e.payload.items) || void 0 === n ? void 0 : n[(null === (r = e.payload.items) || void 0 === r ? void 0 : r.length) - 1]) || void 0 === i ? void 0 : i.sequence),
                    h = null === (s = null === (o = e.payload.items) || void 0 === o ? void 0 : o[0]) || void 0 === s ? void 0 : s.sequence,
                    p = "Window" === e.meta.cursorStrategy ? {
                        cursor: d,
                        cursorDown: h
                    } : null,
                    f = "Asc" === e.meta.cursorStrategy ? {
                        cursorDown: (null === (c = null === (a = e.payload) || void 0 === a ? void 0 : a.next) || void 0 === c ? void 0 : c.since) || null
                    } : null,
                    m = {
                        cursor: (null === (l = null === (u = e.payload) || void 0 === u ? void 0 : u.next) || void 0 === l ? void 0 : l.before) || null
                    };
                return p || f || m
            };
            var bn = function(e, t, n) {
                    var r;
                    return (0, v.__assign)((0, v.__assign)({}, e), ((r = {})[n] = (0, v.__assign)((0, v.__assign)((0, v.__assign)({}, e[n] || {}), {
                        error: void 0
                    }), t || {}), r))
                },
                In = function(e, t) {
                    var n;
                    return (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[t] = (0, v.__assign)((0, v.__assign)({}, e[t]), {
                        error: void 0
                    }), n))
                },
                En = function(e, t) {
                    return t.type === tn.Z.TYPING_STARTED ? Tn(e, t) : Cn(e, t)
                },
                Sn = function(e, t) {
                    return !e.isCurrentUser && !An(t, e)
                },
                wn = function(e) {
                    return !f()(e)
                },
                Cn = function(e, t) {
                    return wn(e) ? e.filter((function(e) {
                        return e.userId !== t.userId
                    })) : sn
                },
                Tn = function(e, t) {
                    var n;
                    return Sn(t, e) ? (n = (0, v.__spreadArrays)(e)).push({
                        userId: t.userId,
                        displayData: t.displayData
                    }) : n = e, n
                },
                An = function(e, t) {
                    return e.some((function(e) {
                        return e.userId === t.userId
                    }))
                };

            function Rn(e, t) {
                var n, r = null === (n = e[t].lastMessage) || void 0 === n ? void 0 : n.sequence;
                return ln(e, {
                    unreadCount: 0,
                    id: t,
                    lastReadMessageSequence: r
                })
            }

            function Pn(e, t) {
                return (0, v.__assign)({}, Xt()(e, t))
            }
            var On = {
                isFetchingRooms: !1,
                isFetchingMoreRooms: !1,
                isFetchingRoom: !1
            };
            var kn = xe({
                    status: function(e, t) {
                        switch (void 0 === e && (e = On), t.type) {
                            case qe(je.FETCH_ROOM):
                            case We(je.FETCH_ROOM):
                                return (0, v.__assign)((0, v.__assign)({}, e), {
                                    isFetchingRoom: !1
                                });
                            case He(je.FETCH_ROOM):
                                return (0, v.__assign)((0, v.__assign)({}, e), {
                                    isFetchingRoom: !0
                                });
                            case qe(je.FETCH_ROOMS):
                                return (0, v.__assign)((0, v.__assign)({}, e), {
                                    isFetchingRooms: !1,
                                    isFetchingMoreRooms: !1,
                                    error: null
                                });
                            case We(je.FETCH_ROOMS):
                                var n = t.payload.is401Error ? null : t.payload;
                                return (0, v.__assign)((0, v.__assign)({}, e), {
                                    isFetchingRooms: !1,
                                    isFetchingMoreRooms: !1,
                                    error: n
                                });
                            case He(je.FETCH_ROOMS):
                                var r = k()(t, "meta.isSilent"),
                                    i = k()(t, "meta.isFetchMore") && !r;
                                return (0, v.__assign)((0, v.__assign)({}, e), {
                                    isFetchingRooms: !r,
                                    isFetchingMoreRooms: i,
                                    error: null
                                });
                            default:
                                return e
                        }
                    },
                    byId: function(e, t) {
                        var n, r, i, o;
                        switch (void 0 === e && (e = rn), t.type) {
                            case je.TYPING_STATUS_CHANGE:
                                return function(e, t, n) {
                                    var r, i, o = null !== (i = null === (r = e[t]) || void 0 === r ? void 0 : r.typingStatus) && void 0 !== i ? i : [],
                                        s = n.type === tn.Z.TYPING_STARTED,
                                        a = !Sn(n, o),
                                        c = !wn(o),
                                        u = s && a || !s && c;
                                    return e[t] && u ? e : ln(e, {
                                        id: t
                                    }, [], {
                                        typingEvent: n
                                    })
                                }(e, t.payload.chatroomId, t.payload);
                            case qe(je.FETCH_ROOM):
                                return vn(t.payload, e) ? e : ln(e, t.payload);
                            case qe(je.FETCH_ENRICHED_ROOM):
                                return vn(t.payload.chatroom, e) ? e : ln(e, t.payload.chatroom, t.payload.participants.items, {
                                    enrichedChatroomLoaded: !0
                                });
                            case je.UPDATE_ROOM_LABELS:
                                return hn(e, t.payload.chatroomParticipantLabel);
                            case He(je.UPDATE_ROOM_LABEL):
                                return hn(e, [t.meta.updateLabel]);
                            case je.REMOVE_ROOM_LABELS:
                                return hn(e, t.payload, !0);
                            case qe(je.FETCH_ROOMS):
                                return function(e, t, n) {
                                    if (f()(t.payload)) return e;
                                    var r = t.payload.chatrooms.items,
                                        i = e;
                                    return r.forEach((function(t) {
                                        e[t.id] && !n || (i = ln(i, t))
                                    })), i
                                }(e, t, !0);
                            case je.ADD_ROOMS:
                                return function(e, t) {
                                    var n = e;
                                    return t.forEach((function(e) {
                                        n = ln(n, e)
                                    })), n
                                }(e, t.rooms);
                            case He(je.SEND_MESSAGE):
                                var s = t.meta.message;
                                return _n(e, s);
                            case je.ADD_MESSAGE:
                                return function(e, t) {
                                    var n = t.message,
                                        r = n.isSilent,
                                        i = e[n.chatroomId];
                                    if (!i || r) return e;
                                    var o = n.sequence > k()(i, "lastMessage.sequence", 0),
                                        s = _n(e, n);
                                    return t.messageSentByCurrentUser ? o ? Rn(s, n.chatroomId) : s : o ? gn(s, n.chatroomId) : e
                                }(e, t);
                            case je.HANDLE_ROOM_ARCHIVED:
                            case He(je.ARCHIVE_ROOM):
                                return fn(e, t.meta.chatroomId);
                            case qe(je.ARCHIVE_ROOMS):
                                return function(e, t) {
                                    var n = (0, v.__assign)({}, e);
                                    return t.meta.chatroomIds.forEach((function(e) {
                                        return n = fn(n, e)
                                    })), n
                                }(e, t);
                            case qe(je.UNARCHIVE_ROOMS):
                                return function(e, t) {
                                    var n = (0, v.__assign)({}, e);
                                    return t.meta.chatroomIds.forEach((function(e) {
                                        return n = pn(n, e)
                                    })), n
                                }(e, t);
                            case qe(je.DELETE_ROOMS):
                                return function(e, t) {
                                    var n = (0, v.__assign)({}, e);
                                    return t.meta.chatroomIds.forEach((function(e) {
                                        return n = Pn(n, e)
                                    })), n
                                }(e, t);
                            case je.HANDLE_ROOM_UNARCHIVED:
                            case He(je.UNARCHIVE_ROOM):
                                return pn(e, t.meta.chatroomId);
                            case He(je.DELETE_ROOM):
                            case je.REMOVE_ROOM:
                                return Pn(e, t.meta.chatroomId);
                            case je.SET_MESSAGES_READ_FOR_SELF:
                            case He(je.SET_MESSAGES_READ):
                                var a = t.meta,
                                    c = a.lastReadMessageSequence,
                                    u = a.chatroomId;
                                return ln(e, {
                                    unreadCount: 0,
                                    lastReadMessageSequence: c,
                                    id: u
                                });
                            case He(je.SET_ROOMS_MESSAGES_READ):
                                var l = (0, v.__assign)({}, e);
                                return t.meta.chatroomIds.forEach((function(e) {
                                    l = Rn(l, e)
                                })), l;
                            case He(je.SET_LAST_MESSAGE_UNREAD):
                                var d = t.meta;
                                c = d.lastReadMessageSequence, u = d.chatroomId;
                                return Nn(e, c, u);
                            case He(je.SET_ROOMS_MESSAGES_UNREAD):
                                var h = (0, v.__assign)({}, e);
                                return t.meta.chatroomIdsAndLastReadMessageSequences.reduce((function(e, t) {
                                    var n = t.chatroomId,
                                        r = t.lastReadMessageSequence;
                                    return Nn(e, r, n)
                                }), h);
                            case qe(je.FETCH_ROOM_MESSAGES):
                                return t.meta.isFetchMore ? function(e, t) {
                                    var n = yn(t),
                                        r = t.meta.chatroomId;
                                    return bn(e, n, r)
                                }(e, t) : function(e, t) {
                                    var n, r, i, o;
                                    if (f()(t.payload)) return e;
                                    var s = null !== (r = null === (n = t.payload.next) || void 0 === n ? void 0 : n.before) && void 0 !== r ? r : null,
                                        a = null !== (o = null === (i = t.payload.next) || void 0 === i ? void 0 : i.since) && void 0 !== o ? o : null,
                                        c = t.meta.chatroomId,
                                        u = nn(t.payload.items),
                                        l = (e[c] || {}).cursor,
                                        d = (e[c] || {}).cursorDown;
                                    return u || null == l && null == d ? bn(e, a ? {
                                        cursorDown: a
                                    } : {
                                        cursor: s
                                    }, c) : In(e, c)
                                }(e, t);
                            case We(je.FETCH_ROOM_MESSAGES):
                                return t.payload.is401Error ? e : (o = t.meta.chatroomId, (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[o] = (0, v.__assign)((0, v.__assign)({}, e[o]), {
                                    error: t.payload
                                }), n)));
                            case We(je.SEND_MESSAGE):
                                return o = t.meta.message.chatroomId, (0, v.__assign)((0, v.__assign)({}, e), ((r = {})[o] = (0, v.__assign)((0, v.__assign)({}, e[o]), {
                                    messageDeliveryError: !0
                                }), r));
                            case qe(je.SEND_MESSAGE):
                                return o = t.meta.message.chatroomId, (0, v.__assign)((0, v.__assign)({}, e), ((i = {})[o] = (0, v.__assign)((0, v.__assign)({}, e[o]), {
                                    messageDeliveryError: void 0
                                }), i));
                            case je.UPDATE_MESSAGE:
                                return function(e, t) {
                                    var n, r = t.isSilent,
                                        i = t.chatroomId,
                                        o = e[i];
                                    if (!o || r) return e;
                                    var s = (null === (n = o.lastMessage) || void 0 === n ? void 0 : n.id) === t.id;
                                    return ln(e, {
                                        id: i,
                                        lastMessage: s ? t : void 0
                                    })
                                }(e, t.message);
                            case qe(je.SET_UNSEEN_CHATROOMS):
                                return t.payload.reduce((function(t, n) {
                                    var r = n.chatroomId,
                                        i = n.lastSeenMessageSequence,
                                        o = e[r];
                                    return o ? ln(t, {
                                        id: r,
                                        lastSeenMessageSequence: Math.max(i, o.lastSeenMessageSequence || 0)
                                    }) : t
                                }), e);
                            case He(je.MARK_CHATROOMS_SEEN):
                                return t.meta.filteredChatrooms.reduce((function(e, t) {
                                    return function(e, t) {
                                        var n = k()(e[t], "lastMessage.sequence");
                                        return ln(e, {
                                            id: t,
                                            lastSeenMessageSequence: n
                                        })
                                    }(e, t.id)
                                }), e);
                            default:
                                return e
                        }
                    },
                    filter: function(e, t) {
                        var n, r, i;
                        switch (void 0 === e && (e = on), t.type) {
                            case je.SET_CURRENT_FILTER:
                                var o = t.meta,
                                    s = o.filter,
                                    a = o.subscriberId;
                                return (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[a] = (0, v.__assign)((0, v.__assign)({}, e[a] || {}), {
                                    currentFilter: s ? (0, v.__assign)({}, s) : {}
                                }), n));
                            case je.SET_FILTERED_ROOMS_IDS:
                                var c = t.meta,
                                    u = c.shouldOverride,
                                    l = c.filteredRoomsIds,
                                    d = (null === (i = e[a = c.subscriberId]) || void 0 === i ? void 0 : i.filteredRoomsIds) || [],
                                    h = u ? (0, v.__spreadArrays)(l) : (0, v.__spreadArrays)(d, l);
                                return (0, v.__assign)((0, v.__assign)({}, e), ((r = {})[a] = (0, v.__assign)((0, v.__assign)({}, e[a] || {}), {
                                    filteredRoomsIds: h
                                }), r));
                            default:
                                return e
                        }
                    }
                }),
                Nn = function(e, t, n) {
                    return ln(e, {
                        unreadCount: 1,
                        lastReadMessageSequence: t,
                        id: n
                    }, [], {
                        overrideRegardlessOfSequenceComparison: !0
                    })
                },
                Dn = function(e) {
                    var t, n = function(e) {
                            return e ? (0, v.__assign)((0, v.__assign)({}, e), {
                                isArchived: !!e.isArchived
                            }) : {
                                isArchived: !1
                            }
                        }(e),
                        r = function(e) {
                            return (0, v.__assign)((0, v.__assign)({}, e), {
                                isUnread: !!e.isUnread
                            })
                        }(n),
                        i = function(e) {
                            e.participantIds && e.participantIds.sort();
                            return e
                        }(r),
                        o = (t = i, Object.keys(t).sort().map((function(e) {
                            return [e, t[e]]
                        })));
                    return JSON.stringify(o)
                };
            var Mn = {},
                xn = {},
                Ln = function(e, t, n) {
                    var r = (0, v.__assign)({}, e);
                    return r[t] = n, r
                },
                Un = xe({
                    byId: function(e, t) {
                        switch (void 0 === e && (e = xn), t.type) {
                            case je.TYPING:
                                return Ln(e, t.meta.chatroomId, t.text);
                            case qe(je.FETCH_MESSAGE_DRAFTS):
                                return (0, v.__assign)((0, v.__assign)({}, t.payload), e);
                            default:
                                return e
                        }
                    },
                    isFetching: function(e, t) {
                        switch (void 0 === e && (e = !1), t.type) {
                            case He(je.FETCH_MESSAGE_DRAFTS):
                                return !0;
                            case qe(je.FETCH_MESSAGE_DRAFTS):
                            case We(je.FETCH_MESSAGE_DRAFTS):
                                return !1;
                            default:
                                return e
                        }
                    }
                }),
                Fn = {};
            var jn = function(e, t, n) {
                    void 0 === n && (n = {});
                    var r = (0, v.__assign)({}, e),
                        i = r[t.id] || {};
                    return r[t.id] = (0, v.__assign)((0, v.__assign)((0, v.__assign)((0, v.__assign)({}, i), t), {
                        sequence: Yn(i.sequence, t.sequence)
                    }), n), r
                },
                qn = function(e, t, n) {
                    var r;
                    if (f()(t.payload)) return e;
                    var i = t.payload.items,
                        o = P(i, "id", {
                            transit: {
                                sendStatus: l.MessageSendStatus.SENT
                            }
                        }),
                        s = "Window" === (null === (r = t.meta) || void 0 === r ? void 0 : r.cursorStrategy) || !n && !!Object.keys(o).length && nn(i);
                    return (0, v.__assign)((0, v.__assign)({}, Hn(e, t.meta.chatroomId, s)), o)
                },
                Hn = function(e, t, n) {
                    return n ? Wn(e, t) : e
                },
                Wn = function(e, t) {
                    return Object.values(e).reduce((function(e, n) {
                        return n.chatroomId !== t && (e[n.id] = n), e
                    }), [])
                },
                Bn = jn,
                Vn = jn,
                Gn = function(e, t) {
                    var n = {
                            sendStatus: l.MessageSendStatus.SENT
                        },
                        r = Xt()(Kn(e, t, n), ["sendError"]);
                    return jn(e, t, {
                        transit: r
                    })
                },
                zn = function(e, t) {
                    var n = {
                            sendStatus: l.MessageSendStatus.SENDING
                        },
                        r = Xt()(Kn(e, t, n), ["sendError"]);
                    return jn(e, t, {
                        transit: r
                    })
                },
                $n = function(e, t, n) {
                    var r = {
                            sendStatus: l.MessageSendStatus.FAILED,
                            sendError: n
                        },
                        i = Kn(e, t, r);
                    return jn(e, t, {
                        transit: i
                    })
                },
                Kn = function(e, t, n) {
                    var r = t ? t.transit : {},
                        i = t && e[t.id] ? e[t.id].transit : {};
                    return (0, v.__assign)((0, v.__assign)((0, v.__assign)({}, i), r), n)
                },
                Yn = function(e, t) {
                    return !t && e ? e : t
                },
                Jn = function(e, t) {
                    var n = (0, v.__assign)({}, e);
                    return delete n[t], n
                },
                Qn = function(e, t) {
                    return Jn(e, t)
                },
                Xn = function(e, t) {
                    if (!t) return e;
                    var n = t.chatrooms.items.reduce((function(e, t) {
                        return Object.assign(e, P(t.lastMessages || [], "id", {
                            transit: {
                                sendStatus: l.MessageSendStatus.SENT
                            }
                        }))
                    }), {});
                    return (0, v.__assign)((0, v.__assign)({}, e), n)
                };

            function Zn(e, t) {
                var n = {};
                return Object.keys(e).forEach((function(r) {
                    e[r].chatroomId !== t && (n[r] = e[r])
                })), n
            }
            var er, tr, nr = xe({
                    byId: function(e, t) {
                        switch (void 0 === e && (e = Fn), t.type) {
                            case qe(je.FETCH_ROOM_MESSAGES):
                                return qn(e, t, t.meta.isFetchMore);
                            case je.ADD_MESSAGE:
                                return Bn(e, t.message);
                            case je.UPDATE_MESSAGE:
                                return Vn(e, t.message);
                            case qe(je.SEND_MESSAGE):
                                return Gn(e, t.meta.message);
                            case He(je.SEND_MESSAGE):
                                return zn(e, t.meta.message);
                            case We(je.SEND_MESSAGE):
                                return $n(e, t.meta.message, t.payload);
                            case je.RESEND_MESSAGE:
                                return Qn(e, t.meta.messageId);
                            case je.DELETE_MESSAGE:
                                return Jn(e, t.meta.messageId);
                            case qe(je.DELETE_ROOM):
                                return Zn(e, t.meta.chatroomId);
                            case qe(je.DELETE_ROOMS):
                                return function(e, t) {
                                    var n = (0, v.__assign)({}, e),
                                        r = t.meta.chatroomIds;
                                    return r.forEach((function(e) {
                                        n = Zn(n, e)
                                    })), n
                                }(e, t);
                            case qe(je.FETCH_ROOMS):
                                return Xn(e, t.payload);
                            default:
                                return e
                        }
                    }
                }),
                rr = {},
                ir = function(e, t) {
                    var n;
                    return (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[t.id] = t, n))
                },
                or = function(e, t) {
                    return t.items.reduce(ir, e)
                },
                sr = xe({
                    byId: function(e, t) {
                        switch (void 0 === e && (e = rr), t.type) {
                            case qe(je.FETCH_ENRICHED_ROOM):
                                return or(e, t.payload.participants);
                            case qe(je.FETCH_PARTICIPANTS_DISPLAY_DATA):
                                return or(e, t.payload);
                            default:
                                return e
                        }
                    }
                }),
                ar = n(86349),
                cr = n.n(ar),
                ur = {},
                lr = function(e, t) {
                    if (f()(t.payload)) return e;
                    var n = t.payload.indications.reduce((function(e, t) {
                        var n, r = t.indications.reduce((function(e, t) {
                            var n, r, i = t.indication;
                            return (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[t.participantId] = (0, v.__assign)((0, v.__assign)({}, e[t.participantId] || {}), ((r = {})[mr(i)] = (0, v.__assign)({}, i), r)), n))
                        }), {});
                        return f()(r) ? e : (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[t.messageId] = (0, v.__assign)((0, v.__assign)({}, e[t.messageId] || {}), r), n))
                    }), {});
                    return (0, v.__assign)((0, v.__assign)({}, e), n)
                },
                dr = function(e, t, n) {
                    return h()(e, (function(e, r) {
                        var i, o = function(e, t, n) {
                            return h()(e.indications, (function(r, i) {
                                var o, s = t[n] ? t[n][e.participantId] : {};
                                return fr(i, s) ? r : (0, v.__assign)((0, v.__assign)({}, r), ((o = {})[mr(i)] = i, o))
                            }), {})
                        }(r, t, n);
                        return f()(o) ? e : cr()({}, e, ((i = {})[r.participantId] = o, i))
                    }), {})
                },
                hr = function(e, t, n) {
                    return h()(e, (function(e, r) {
                        var i, o = function(e, t, n) {
                            var r, i = t[n] ? t[n][e.participantId] : {},
                                o = e.indication;
                            return fr(o, i) ? {} : ((r = {})[mr(o)] = o, r)
                        }(r, t, n);
                        return f()(o) ? e : cr()({}, e, ((i = {})[r.participantId] = o, i))
                    }), {})
                },
                pr = function(e, t, n, r) {
                    return h()(e, (function(e, i) {
                        var o, s, a, c = r[i] ? r[i][t] : {};
                        return fr(n, c) ? {} : cr()({}, e, ((o = {})[i] = (0, v.__assign)((0, v.__assign)({}, r[i]), ((s = {})[t] = ((a = {})[mr(n)] = n, a), s)), o))
                    }), {})
                },
                fr = function(e, t) {
                    return void 0 !== t && !!t[mr(e)]
                },
                mr = function(e) {
                    return e.event + "-" + e.method + "-" + (e.code || "000")
                },
                gr = xe({
                    byId: function(e, t) {
                        switch (void 0 === e && (e = ur), t.type) {
                            case qe(je.FETCH_MESSAGES_ERRORS_INDICATIONS):
                                return lr(e, t);
                            case qe(je.FETCH_ENRICHED_ROOM):
                                return f()(t.payload.indications.lastMessageIndications) ? e : function(e, t, n) {
                                    var r;
                                    if (!n) return e;
                                    var i = hr(t.lastMessageIndications, e, n);
                                    return f()(i) ? e : (0, v.__assign)((0, v.__assign)({}, e), ((r = {})[n] = cr()({}, e[n], i), r))
                                }(e, t.payload.indications, (n = t.payload.chatroom, null === (r = ft()(null == n ? void 0 : n.lastMessages)) || void 0 === r ? void 0 : r.id));
                            case qe(je.FETCH_DRILL_IN_MESSAGE_INDICATIONS):
                                return f()(t.payload.indications) ? e : function(e, t) {
                                    var n, r = t.messageId,
                                        i = dr(t.indications, e, r);
                                    return f()(i) ? e : (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[r] = cr()({}, e[r], i), n))
                                }(e, t.payload);
                            case je.UPDATE_MESSAGES_INDICATIONS:
                                return f()(t.payload.messageIds) ? e : function(e, t) {
                                    var n = pr(t.messageIds, t.participantId, t.indication, e);
                                    return f()(n) ? e : cr()({}, e, n)
                                }(e, t.payload);
                            default:
                                return e
                        }
                        var n, r
                    }
                }),
                _r = function(e, t) {
                    if (!t) return e;
                    var n = (0, v.__assign)({}, e),
                        r = e[t.participantId];
                    if (r) {
                        var i = r.chatrooms;
                        i[t.id] && delete i[t.id]
                    }
                    return n
                },
                vr = function(e, t) {
                    var n, r;
                    return (null === (n = t.lastMessage) || void 0 === n ? void 0 : n.sequence) && (null === (r = t.lastMessage) || void 0 === r ? void 0 : r.sequence) > t.lastReadMessageSequence ? yr(e, t) : e
                },
                yr = function(e, t) {
                    var n;
                    if (!t) return e;
                    var r = (0, v.__assign)({}, e),
                        i = e[t.participantId];
                    return r[t.participantId] = (0, v.__assign)((0, v.__assign)({}, i), {
                        chatrooms: (0, v.__assign)((0, v.__assign)({}, null == i ? void 0 : i.chatrooms), (n = {}, n[t.id] = !0, n))
                    }), r
                },
                br = function(e) {
                    return (0, v.__assign)((0, v.__assign)({}, e), {
                        isArchived: !1
                    })
                },
                Ir = xe({
                    byFilter: function(e, t) {
                        switch (void 0 === e && (e = {}), t.type) {
                            case qe(je.SET_UNREAD_CHATROOMS_MAP):
                                return function(e) {
                                    var t = e.payload.chatroomsForParticipant;
                                    return (e.meta.filter.participantIds || Object.keys(t)).reduce((function(e, n) {
                                        var r, i = (r = t[n]) ? r.reduce((function(e, t) {
                                            return e[t] = !0, e
                                        }), {}) : {};
                                        return e[n] = {
                                            chatrooms: i
                                        }, e
                                    }), {})
                                }(t);
                            case je.ADD_MESSAGE:
                                var n = t.meta.chatroom,
                                    r = (void 0 === n ? {} : n).lastReadMessageSequence,
                                    i = void 0 === r ? 0 : r;
                                return t.messageSentByCurrentUser || t.message.isSilent || t.message.sequence <= i ? e : yr(e, t.meta.chatroom);
                            case je.HANDLE_ROOM_UNARCHIVED:
                                return vr(e, t.meta.chatroom);
                            case qe(je.SET_LAST_MESSAGE_UNREAD):
                                return yr(e, t.meta.chatroom);
                            case qe(je.UNARCHIVE_ROOM):
                                return vr(e, br(t.meta.chatroom));
                            case qe(je.UNARCHIVE_ROOMS):
                                return t.meta.chatrooms.reduce((function(e, t) {
                                    return vr(e, br(t))
                                }), e);
                            case je.MARK_CHATROOM_READ:
                            case qe(je.SET_MESSAGES_READ):
                                return _r(e, t.meta.chatroom);
                            default:
                                return e
                        }
                    }
                }),
                Er = n(43913),
                Sr = n.n(Er),
                wr = n(95492),
                Cr = n.n(wr);
            ! function(e) {
                e.ONLINE = "ONLINE", e.OFFLINE = "OFFLINE"
            }(er || (er = {})),
            function(e) {
                e.UNKNOWN = "UNKNOWN", e.VIEWER = "VIEWER", e.EDITOR_X = "EDITOR_X"
            }(tr || (tr = {}));
            var Tr = {},
                Ar = function(e, t, n) {
                    return n === er.ONLINE ? e.indexOf(t) < 0 ? (0, v.__spreadArrays)(e, [t]) : e : Sr()(e, (function(e) {
                        return e !== t
                    }))
                };

            function Rr(e) {
                if (e.userPresence) return {
                    userId: e.userPresence.userId,
                    group: e.userPresence.group,
                    sessionId: e.userPresence.sessionId,
                    status: e.userPresence.status,
                    data: e.userPresence.data,
                    type: "",
                    timestamp: (new Date).getTime()
                }
            }

            function Pr(e, t) {
                var n = {};
                return e.forEach((function(e) {
                    var r = t[e.userId] ? t[e.userId].onlineSessions : [],
                        i = Ar(r, e.sessionId, e.status);
                    n[e.userId] = {
                        onlineSessions: i,
                        online: i.length > 0,
                        groupId: e.group,
                        data: e.status === er.OFFLINE && t[e.userId] ? t[e.userId].data : e.data,
                        clientSideReceivedAtTimestamp: (new Date).getTime()
                    }
                })), (0, v.__assign)((0, v.__assign)({}, t), n)
            }
            var Or = xe({
                    participantsById: function(e, t) {
                        if (void 0 === e && (e = Tr), t.type === je.CLEAR_PRESENCE) return Tr;
                        var n;
                        if (t.type === je.UPDATE_PRESENCE) return Pr([o = t.meta.data], e);
                        if (t.type === je.PRESENCE_CLEAR_STALE) {
                            var r = (new Date).getTime();
                            return Cr()(e, (function(e) {
                                return r - e.clientSideReceivedAtTimestamp > 3e4
                            }))
                        }
                        if (t.type === qe(je.FETCH_PRESENCE)) {
                            if (i = Rr(o = t.payload)) return Pr([i], e)
                        } else if (t.type === qe(je.FETCH_VISITORS_PRESENCE)) {
                            var i, o = t.payload;
                            if (i = (n = function(e) {
                                    return Rr({
                                        userPresence: e
                                    })
                                }, o.map(n).filter(R))) return Pr(i, e)
                        }
                        return e
                    },
                    didFetchPresence: function(e, t) {
                        return t.type === qe(je.FETCH_PRESENCE) || !!e
                    },
                    didFetchListPresence: function(e, t) {
                        return t.type === qe(je.FETCH_VISITORS_PRESENCE) || !!e
                    }
                }),
                kr = xe({
                    chatrooms: kn,
                    chatroomsLists: function(e, t) {
                        var n;
                        void 0 === e && (e = Mn);
                        var r = t.payload;
                        if (f()(r)) return e;
                        if (t.type === qe(je.FETCH_ROOMS)) {
                            var i = r.chatrooms,
                                o = i.next ? i.next.before : null,
                                s = Dn(t.meta.filter);
                            return f()(k()(e[s], "cursor")) || t.meta.isFetchMore ? (0, v.__assign)((0, v.__assign)({}, e), ((n = {})[s] = {
                                cursor: o
                            }, n)) : e
                        }
                        return e
                    },
                    messages: nr,
                    messageDraft: Un,
                    participants: sr,
                    messagesIndications: gr,
                    unseenChatroomCount: Je,
                    unreadChatroomCount: Ir,
                    presence: Or
                }),
                Nr = function(e, t) {
                    return t.type === je.RESET_STORE ? kr(void 0, t) : kr(e, t)
                },
                Dr = n(50377),
                Mr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                    return typeof e
                } : function(e) {
                    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                };

            function xr(e) {
                return null !== e && "object" === (void 0 === e ? "undefined" : Mr(e)) && (e && "function" == typeof e.then)
            }
            var Lr = n(13158),
                Ur = function(e, t) {
                    if (Array.isArray(e)) return e;
                    if (Symbol.iterator in Object(e)) return function(e, t) {
                        var n = [],
                            r = !0,
                            i = !1,
                            o = void 0;
                        try {
                            for (var s, a = e[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0);
                        } catch (e) {
                            i = !0, o = e
                        } finally {
                            try {
                                !r && a.return && a.return()
                            } finally {
                                if (i) throw o
                            }
                        }
                        return n
                    }(e, t);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                },
                Fr = Object.assign || function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                    }
                    return e
                },
                jr = {
                    Pending: "PENDING",
                    Fulfilled: "FULFILLED",
                    Rejected: "REJECTED"
                };

            function qr() {
                var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).dispatch;
                return "function" == typeof e ? function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        t = [jr.Pending, jr.Fulfilled, jr.Rejected],
                        n = e.promiseTypeSuffixes || t,
                        r = e.promiseTypeDelimiter || "_";
                    return function(e) {
                        var t = e.dispatch;
                        return function(e) {
                            return function(i) {
                                var o = void 0,
                                    s = void 0;
                                if (!i.payload) return e(i);
                                var a = i.payload;
                                if (xr(a)) o = a;
                                else if (xr(a.promise)) o = a.promise, s = a.data;
                                else {
                                    if ("function" != typeof a && "function" != typeof a.promise) return e(i);
                                    if (o = a.promise ? a.promise() : a(), s = a.promise ? a.data : void 0, !xr(o)) return e(Fr({}, i, {
                                        payload: o
                                    }))
                                }
                                var c = i.type,
                                    u = i.meta,
                                    l = Ur(n, 3),
                                    d = l[0],
                                    h = l[1],
                                    p = l[2],
                                    f = function(e, t) {
                                        return Fr({
                                            type: [c, t ? p : h].join(r)
                                        }, null == e ? {} : {
                                            payload: e
                                        }, void 0 !== u ? {
                                            meta: u
                                        } : {}, t ? {
                                            error: !0
                                        } : {})
                                    };
                                return e(Fr({
                                    type: [c, d].join(r)
                                }, void 0 !== s ? {
                                    payload: s
                                } : {}, void 0 !== u ? {
                                    meta: u
                                } : {})), o.then((function() {
                                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                        n = f(e, !1);
                                    return t(n), {
                                        value: e,
                                        action: n
                                    }
                                }), (function(e) {
                                    var n = f(e, !0);
                                    throw t(n), e
                                }))
                            }
                        }
                    }
                }()({
                    dispatch: e
                }) : (Lr && Lr.env, null)
            }
            var Hr = function(e, t, n) {
                    void 0 === n && (n = []);
                    var r = (0, v.__spreadArrays)([qr, Dr.Z], n);
                    return De(e, t, ("object" == typeof window && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
                        name: "chat-sdk"
                    }) : Le)(Fe.apply(void 0, r)))
                },
                Wr = n(59784),
                Br = n.n(Wr);
            var Vr = function() {
                    function e(e) {
                        var t = e.store,
                            n = e.chatroomsActions,
                            r = e.unreadChatroomCountActions,
                            i = e.subscriptionService,
                            o = e.serverApi;
                        this.store = t, this.chatroomsActions = n, this.unreadChatroomCountActions = r, this.subscriptionService = i, this.serverApi = o
                    }
                    return e.prototype.updateFilteredRoomsIdsIfNeeded = function(e, t, n) {
                        if (n) {
                            var r = this.store,
                                i = this.chatroomsActions,
                                o = r.getState(),
                                s = e(o).map((function(e) {
                                    return e.id
                                })),
                                a = (o.chatrooms.filter[t] || {}).filteredRoomsIds;
                            s.some((function(e) {
                                return !(null == a ? void 0 : a.includes(e))
                            })) && r.dispatch(i.action$setFilteredRoomsIds(t, !1, s))
                        }
                    }, e.prototype.getCurrentFilterForSubscriber = function(e) {
                        var t;
                        return (null === (t = this.store.getState().chatrooms.filter[e]) || void 0 === t ? void 0 : t.currentFilter) || {}
                    }, e.prototype.subscribeToChatRoomsList = function(e) {
                        var t, n, r, i = this,
                            o = e.subscriberId,
                            s = e.callback,
                            a = e.filter,
                            c = void 0 === a ? {} : a,
                            u = this.store,
                            d = this.chatroomsActions,
                            h = o || ht()(),
                            p = function(e, t) {
                                return rt(Xe, it(e, t), (function(e, t) {
                                    return tt(e, t)
                                }))
                            }(h, c),
                            f = this._registerSubscriptionV2(c),
                            m = !z()(this.getCurrentFilterForSubscriber(h), c),
                            g = null == c ? void 0 : c.isUnread,
                            _ = null === (t = null == c ? void 0 : c.labelIds) || void 0 === t ? void 0 : t.includes(l.STAR_LABEL_ID),
                            v = g || _;
                        if (m) {
                            var y = u.getState(),
                                b = v ? p(y).map((function(e) {
                                    return e.id
                                })) : [];
                            u.dispatch(d.action$handleFilterChanged(h, c, b))
                        }
                        var I = function() {
                                var e = u.getState(),
                                    t = p(e),
                                    i = e.chatrooms.status,
                                    o = function(e, t) {
                                        return e.chatroomsLists[t]
                                    }(e, Dn(c)),
                                    a = k()(o, "cursor");
                                if (t !== n || i !== r) {
                                    n = t, r = i;
                                    try {
                                        s({
                                            rooms: t,
                                            status: i,
                                            cursor: a
                                        })
                                    } catch (e) {
                                        console.error("Error in subscribe callback", e)
                                    }
                                }
                            },
                            E = u.subscribe((function() {
                                I(), i.updateFilteredRoomsIdsIfNeeded(p, h, g || _)
                            }));
                        return I(), this._activeSubscription(h, E, f, c)
                    }, e.prototype._registerSubscriptionV2 = function(e) {
                        var t = this;
                        return this.subscriptionService.registerSubscription(e, (function() {
                            return t.fetchRooms({
                                isSilent: !0,
                                filter: e
                            })
                        }), (function() {
                            return t.fetchRooms({
                                isSilent: !1,
                                filter: e
                            })
                        }))
                    }, e.prototype._activeSubscription = function(e, t, n, r) {
                        var i = this;
                        return {
                            subscriberId: e,
                            unsubscribe: function() {
                                t(), n()
                            },
                            fetchMore: function(e) {
                                i.fetchRooms({
                                    cursor: e,
                                    filter: r
                                })
                            }
                        }
                    }, e.prototype.deleteChatroom = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t, n, r;
                            return (0, v.__generator)(this, (function(i) {
                                return n = (t = this).store, r = t.chatroomsActions, [2, n.dispatch(r.action$deleteRoom(e))]
                            }))
                        }))
                    }, e.prototype.archiveChatroom = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t, n, r;
                            return (0, v.__generator)(this, (function(i) {
                                return n = (t = this).store, r = t.chatroomsActions, [2, n.dispatch(r.archiveRoom(e))]
                            }))
                        }))
                    }, e.prototype.unarchiveChatroom = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t, n, r;
                            return (0, v.__generator)(this, (function(i) {
                                return n = (t = this).store, r = t.chatroomsActions, [2, n.dispatch(r.unarchiveRoom(e))]
                            }))
                        }))
                    }, e.prototype.fetchRooms = function(e) {
                        var t = e.filter,
                            n = void 0 === t ? {} : t,
                            r = e.cursor,
                            i = void 0 === r ? void 0 : r,
                            o = e.isSilent,
                            s = void 0 !== o && o;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e, t, r;
                            return (0, v.__generator)(this, (function(o) {
                                return t = (e = this).store, r = e.chatroomsActions, [2, t.dispatch(r.fetchRooms({
                                    filter: n,
                                    cursor: i,
                                    isSilent: s
                                }))]
                            }))
                        }))
                    }, e.prototype.addRooms = function(e) {
                        var t = e.rooms,
                            n = this.store,
                            r = this.chatroomsActions;
                        return n.dispatch(r.addRooms(t))
                    }, e.prototype.getUnreadCountForRoom = function(e) {
                        var t = fe(this.store.getState(), e);
                        return new N(t).count
                    }, e.prototype.getUnreadCountForRooms = function(e) {
                        var t = this;
                        return e.reduce((function(e, n) {
                            return e[n] = t.getUnreadCountForRoom(n), e
                        }), {})
                    }, e.prototype.fetchMessageDrafts = function() {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e, t, n;
                            return (0, v.__generator)(this, (function(r) {
                                return t = (e = this).store, n = e.chatroomsActions, t.dispatch(n.fetchMessageDrafts()), [2]
                            }))
                        }))
                    }, e.prototype.markAllRoomsAsRead = function(e, t) {
                        return void 0 === t && (t = !0), (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n, r, i, o, s, a;
                            return (0, v.__generator)(this, (function(c) {
                                switch (c.label) {
                                    case 0:
                                        return r = (n = this).store, i = n.chatroomsActions, o = n.serverApi, t ? [4, o.http$markAllRoomsAsRead(e)] : [3, 2];
                                    case 1:
                                        return a = c.sent(), [3, 3];
                                    case 2:
                                        a = Promise.resolve({
                                            markedAsRead: 0
                                        }), c.label = 3;
                                    case 3:
                                        return s = a, [4, r.dispatch(i.fetchRooms({
                                            filter: e
                                        }))];
                                    case 4:
                                        return c.sent(), e.participantIds ? [4, r.dispatch(this.unreadChatroomCountActions.fetchAndUpdateUnreadChatrooms({
                                            participantIds: e.participantIds
                                        }))] : [3, 6];
                                    case 5:
                                        c.sent(), c.label = 6;
                                    case 6:
                                        return [2, s]
                                }
                            }))
                        }))
                    }, e.prototype.deleteChatrooms = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n, r, i;
                            return (0, v.__generator)(this, (function(o) {
                                switch (o.label) {
                                    case 0:
                                        return r = (n = this).store, i = n.chatroomsActions, [4, r.dispatch(i.action$deleteRooms(e))];
                                    case 1:
                                        return o.sent(), t ? [4, r.dispatch(i.fetchRooms(t))] : [3, 3];
                                    case 2:
                                        o.sent(), o.label = 3;
                                    case 3:
                                        return [2]
                                }
                            }))
                        }))
                    }, e.prototype.archiveChatrooms = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n, r, i;
                            return (0, v.__generator)(this, (function(o) {
                                switch (o.label) {
                                    case 0:
                                        return r = (n = this).store, i = n.chatroomsActions, [4, r.dispatch(i.archiveRooms(e))];
                                    case 1:
                                        return o.sent(), t ? [4, r.dispatch(i.fetchRooms(t))] : [3, 3];
                                    case 2:
                                        o.sent(), o.label = 3;
                                    case 3:
                                        return [2]
                                }
                            }))
                        }))
                    }, e.prototype.unarchiveChatrooms = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n, r, i;
                            return (0, v.__generator)(this, (function(o) {
                                switch (o.label) {
                                    case 0:
                                        return r = (n = this).store, i = n.chatroomsActions, [4, r.dispatch(i.unarchiveRooms(e))];
                                    case 1:
                                        return o.sent(), t ? [4, r.dispatch(i.fetchRooms(t))] : [3, 3];
                                    case 2:
                                        o.sent(), o.label = 3;
                                    case 3:
                                        return [2]
                                }
                            }))
                        }))
                    }, e.prototype.setChatroomsUnread = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n, r, i, o, s = this;
                            return (0, v.__generator)(this, (function(a) {
                                return r = (n = this).store, i = n.chatroomsActions, o = e.map((function(e) {
                                    var n = fe(s.store.getState(), e),
                                        r = n.lastMessages.find((function(e) {
                                            var r;
                                            return !e.isSilent && e.sequence <= n.lastReadMessageSequence && (null === (r = e.sender) || void 0 === r ? void 0 : r.userId) !== t
                                        }));
                                    return {
                                        chatroomId: e,
                                        lastReadMessageSequence: r ? r.sequence - 1 : -1
                                    }
                                })).filter((function(e) {
                                    return -1 !== e.lastReadMessageSequence
                                })), o.length > 0 ? [2, r.dispatch(i.action$setRoomsMessagesUnread(o))] : [2]
                            }))
                        }))
                    }, e.prototype.search = function(e) {
                        var t = e.searchTerm,
                            n = e.participantIds,
                            r = e.chatroomsPageSize,
                            i = e.chatroomsNextPointer,
                            o = e.messagesPageSize,
                            s = e.messagesNextPointer;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e, a, c, u, l = this;
                            return (0, v.__generator)(this, (function(d) {
                                switch (d.label) {
                                    case 0:
                                        return [4, this.serverApi.http$search({
                                            searchTerm: t,
                                            participantIds: n,
                                            chatroomsPageSize: r,
                                            chatroomsNextPointer: i,
                                            messagesPageSize: o,
                                            messagesNextPointer: s
                                        })];
                                    case 1:
                                        return e = d.sent(), a = function(e) {
                                            var t = e.chatroomsPage.chatrooms,
                                                n = e.messagesPage.messages.map((function(e) {
                                                    return e.chatroom
                                                })),
                                                r = t.concat(n);
                                            return Br()(r, "id")
                                        }(e), this.addRooms({
                                            rooms: a
                                        }), c = [], e.chatroomsPage.chatrooms.forEach((function(e) {
                                            var t = fe(l.store.getState(), e.id);
                                            if (!f()(t)) {
                                                var n = new N(t);
                                                c.push(n)
                                            }
                                        })), u = [], e.messagesPage.messages.forEach((function(e) {
                                            var t = fe(l.store.getState(), e.chatroom.id);
                                            if (!f()(t)) {
                                                var n = new N(t),
                                                    r = new _.Z(e.message);
                                                u.push({
                                                    chatroom: n,
                                                    message: r
                                                })
                                            }
                                        })), [2, {
                                            chatroomsPage: {
                                                chatrooms: c,
                                                nextPointer: e.chatroomsPage.nextPage.nextPointer,
                                                total: e.chatroomsPage.nextPage.total
                                            },
                                            messagesPage: {
                                                messages: u,
                                                nextPointer: e.messagesPage.nextPage.nextPointer,
                                                total: e.messagesPage.nextPage.total
                                            }
                                        }]
                                }
                            }))
                        }))
                    }, e
                }(),
                Gr = Vr,
                zr = function(e, t) {
                    var n, r = pe(e, t);
                    return function(e, t) {
                        var i = e.getState(),
                            o = r(i);
                        o && z()(n, o) || (n = o, t(o))
                    }
                },
                $r = function() {
                    function e(e) {
                        var t = e.store,
                            n = e.messagesActions,
                            r = e.subscriptionService;
                        this.store = t, this.messagesActions = n, this.subscriptionService = r
                    }
                    return e.prototype.subscribeToDrillInMessageIndications = function(e) {
                        var t = e.chatroomId,
                            n = e.messageId,
                            r = e.sequence,
                            i = e.callback,
                            o = this.store,
                            s = this.messagesActions,
                            a = zr(t, n);
                        a(o, i);
                        var c = o.subscribe((function() {
                                return a(o, i)
                            })),
                            u = this._createIndicationsDataFetcher(t, r);
                        u();
                        var l = this._registerIndicationsSubscription(t, r, u),
                            d = function(e) {
                                var n = e.indications.map((function(e) {
                                        return e.participantId
                                    })),
                                    r = ye(n);
                                f()(r) || o.dispatch(s.action$fetchRoomParticipantsDisplayData(t, r))
                            };
                        return j.NH(j.xc.FETCH_DRILL_IN_MESSAGE_INDICATIONS_COMPLETED, d), {
                            unsubscribe: function() {
                                c(), l(), j.ys(j.xc.FETCH_DRILL_IN_MESSAGE_INDICATIONS_COMPLETED, d)
                            }
                        }
                    }, e.prototype._registerIndicationsSubscription = function(e, t, n) {
                        var r = {
                            chatroomId: e,
                            sequence: t
                        };
                        return this.subscriptionService.registerSubscription(r, n)
                    }, e.prototype._createIndicationsDataFetcher = function(e, t) {
                        var n = this;
                        return function() {
                            return (0, v.__awaiter)(n, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(n) {
                                    switch (n.label) {
                                        case 0:
                                            return [4, this.store.dispatch(this.messagesActions.action$fetchDrillInMessageIndications(e, t))];
                                        case 1:
                                            return n.sent(), [2]
                                    }
                                }))
                            }))
                        }
                    }, e
                }(),
                Kr = n(18053),
                Yr = n.n(Kr),
                Jr = new(function() {
                    function e() {}
                    return e.prototype.action$updatePresence = function(e) {
                        return {
                            type: je.UPDATE_PRESENCE,
                            meta: {
                                data: e
                            }
                        }
                    }, e.prototype.action$clearStalePresenceSessions = function() {
                        return {
                            type: je.PRESENCE_CLEAR_STALE
                        }
                    }, e.prototype.action$clearPresence = function() {
                        return {
                            type: je.CLEAR_PRESENCE
                        }
                    }, e.prototype.action$fetchPresence = function(e) {
                        return {
                            type: je.FETCH_PRESENCE,
                            payload: e
                        }
                    }, e.prototype.action$fetchListPresence = function(e) {
                        return {
                            type: je.FETCH_VISITORS_PRESENCE,
                            payload: e
                        }
                    }, e
                }()),
                Qr = function(e, t) {
                    var n, r;
                    return null === (r = null === (n = e[t]) || void 0 === n ? void 0 : n.displayData) || void 0 === r ? void 0 : r.name
                },
                Xr = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.data,
                        i = e.currentUser;
                    return (0, v.__awaiter)(void 0, void 0, void 0, (function() {
                        var e, o, s, a, c, u, d, h, p, f;
                        return (0, v.__generator)(this, (function(m) {
                            switch (m.label) {
                                case 0:
                                    return e = r.chatroomId, o = r.message, s = r.connectionEstablishedTimestamp, a = r.timestamp, c = t.getState().chatrooms, u = c.byId, Qr(u, e) ? [3, 2] : (e || console.error("[Troubleshoot] onAddRealtimeMessage calling fetchRoom w/o chatroomId" + JSON.stringify(r)), d = so.isExperimentOn(l.SdkExperiment.EnrichedChatroom), [4, t.dispatch(n.action$fetchRoom(e, d))]);
                                case 1:
                                    m.sent(), m.label = 2;
                                case 2:
                                    return u = t.getState().chatrooms.byId, h = i.userId === o.sender.userId, p = (0, v.__assign)((0, v.__assign)({}, o), {
                                        transit: (0, v.__assign)((0, v.__assign)({}, o.transit), {
                                            sendStatus: l.MessageSendStatus.SENT
                                        })
                                    }), t.dispatch(n.action$addMessage(p, h, u[e])), f = a + l.HistorySinceRealtimeConnectionWasEstablished >= s, !h && f && li(o), [2]
                            }
                        }))
                    }))
                },
                Zr = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.data;
                    r.message && t.dispatch(n.action$updateMessage(r.message))
                },
                ei = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.data;
                    return t.dispatch(n.action$removeRoom(r.chatroomId))
                },
                ti = function(e, t) {
                    return e.dispatch(Jr.action$updatePresence(t))
                },
                ni = function(e, t) {
                    var n = e.store,
                        r = e.chatroomsActions,
                        i = e.chatroomId,
                        o = e.dataForDebug;
                    void 0 === t && (t = !1), i || console.error("[Troubleshoot] refreshChatroom: " + JSON.stringify(o));
                    var s = so.isExperimentOn(l.SdkExperiment.EnrichedChatroom);
                    return n.dispatch(r.action$fetchRoom(i, s, t))
                },
                ri = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.data;
                    return r.chatroomIds.forEach((function(e) {
                        return ni({
                            store: t,
                            chatroomsActions: n,
                            chatroomId: e,
                            dataForDebug: r
                        })
                    }))
                },
                ii = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.data,
                        i = e.currentUser,
                        o = r.chatroomId,
                        s = r.userId,
                        a = r.type,
                        c = r.displayData,
                        u = r.timestamp;
                    if (!(r.connectionEstablishedTimestamp > u)) {
                        var l = null;
                        a === tn.Z.TYPING_STARTED && c && (l = {
                            imageUrl: c.content.image ? c.content.image.url : void 0,
                            initials: c.content.initials,
                            id: c.content.id,
                            name: c.content.name,
                            type: c.content.type
                        });
                        var d = s === i.userId;
                        t.dispatch(n.action$changeTypingStatus({
                            chatroomId: o,
                            userId: s,
                            type: a,
                            displayData: l,
                            isCurrentUser: d
                        }))
                    }
                },
                oi = {},
                si = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.chatroomId,
                        i = e.isArchived,
                        o = t.getState().chatrooms.byId;
                    if (Qr(o, r)) t.dispatch(i ? n.action$handleRoomArchived(r) : n.action$handleRoomUnarchived(r));
                    else {
                        var s = so.isExperimentOn(l.SdkExperiment.EnrichedChatroom);
                        t.dispatch(n.action$fetchRoom(r, s))
                    }
                },
                ai = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.chatroomId,
                        i = e.userId,
                        o = e.sequenceToMarkAsRead;
                    so.getUserId() === i && t.dispatch(n.action$setMessagesReadForSelf(r, o))
                },
                ci = function(e) {
                    var t = e.store,
                        n = e.chatroomsActions,
                        r = e.messagesActions,
                        i = e.data;
                    t.getState().participants.byId[i.participantId] || t.dispatch(n.action$fetchRoomParticipantsDisplayData(i.chatroomId, [i.participantId])), t.dispatch(r.action$updateMessagesIndications({
                        chatroomId: i.chatroomId,
                        messageIds: i.messageIds,
                        participantId: i.participantId,
                        indication: i.indication
                    }))
                };

            function ui(e) {
                var t = e.store,
                    n = e.chatroomsActions,
                    r = e.messagesActions,
                    i = e.data,
                    o = e.currentUser;
                return (0, v.__awaiter)(this, void 0, void 0, (function() {
                    return (0, v.__generator)(this, (function(e) {
                        switch (i.type) {
                            case tn.Z.MESSAGE_SENT:
                                return [2, Xr({
                                    store: t,
                                    chatroomsActions: n,
                                    data: i,
                                    currentUser: o
                                })];
                            case tn.Z.MESSAGE_UPDATED:
                                return [2, Zr({
                                    store: t,
                                    chatroomsActions: n,
                                    data: i
                                })];
                            case tn.Z.MESSAGE_DELETED:
                                return [2, t.dispatch(n.action$deleteMessage(i.messageId))];
                            case tn.Z.CHATROOM_DELETED:
                                return [2, ei({
                                    store: t,
                                    chatroomsActions: n,
                                    data: i
                                })];
                            case tn.Z.CHATROOOM_DISPLAY_DATA_UPDATED:
                                return [2, ri({
                                    store: t,
                                    chatroomsActions: n,
                                    data: i
                                })];
                            case tn.Z.LABEL_ADDED:
                                return [2, t.dispatch(n.action$updateRoomLabels(i))];
                            case tn.Z.LABEL_REMOVED:
                                return [2, t.dispatch(n.action$removeRoomLabels(i.chatroomParticipantLabel))];
                            case tn.Z.CHATROOM_CREATED:
                                return [2, ni({
                                    store: t,
                                    chatroomsActions: n,
                                    chatroomId: i.chatroomId,
                                    dataForDebug: i
                                })];
                            case tn.Z.OFFLINE_CHANNEL_UPDATED:
                                return j.j8(j.X3.OFFLINE_CHANNEL_UPDATED, i), [2, ni({
                                    store: t,
                                    chatroomsActions: n,
                                    chatroomId: i.chatroomId,
                                    dataForDebug: i
                                })];
                            case tn.Z.CHATROOM_MERGED:
                                return [2, ni({
                                    store: t,
                                    chatroomsActions: n,
                                    chatroomId: i.toChatroomId,
                                    dataForDebug: i
                                }, !0)];
                            case tn.Z.TYPING_STARTED:
                                ! function(e) {
                                    var t = e.data,
                                        n = e.store,
                                        r = e.chatroomsActions,
                                        i = t.userId,
                                        o = t.chatroomId,
                                        s = t.expiryDuration;
                                    if (s) {
                                        var a = i + "|" + o;
                                        oi[a] && clearTimeout(oi[a]), oi[a] = setTimeout((function() {
                                            n.dispatch(r.action$changeTypingStatus({
                                                chatroomId: o,
                                                userId: i,
                                                type: tn.Z.TYPING_STOPPED
                                            }))
                                        }), s)
                                    }
                                }({
                                    store: t,
                                    chatroomsActions: n,
                                    data: i
                                });
                            case tn.Z.TYPING_STOPPED:
                                return [2, ii({
                                    store: t,
                                    chatroomsActions: n,
                                    data: i,
                                    currentUser: o
                                })];
                            case tn.Z.CHATROOM_ARCHIVED:
                                return [2, si({
                                    store: t,
                                    chatroomsActions: n,
                                    chatroomId: i.chatroomId,
                                    isArchived: !0
                                })];
                            case tn.Z.CHATROOM_UNARCHIVED:
                                return [2, si({
                                    store: t,
                                    chatroomsActions: n,
                                    chatroomId: i.chatroomId,
                                    isArchived: !1
                                })];
                            case tn.Z.CHATROOM_READ:
                                return [2, ai({
                                    store: t,
                                    chatroomsActions: n,
                                    chatroomId: i.chatroomId,
                                    userId: i.userId,
                                    sequenceToMarkAsRead: i.lastReadMessageSequence
                                })];
                            case tn.Z.CHATROOMS_ALL_READ:
                                return [2, so.setAllRoomsAsRead({
                                    participantIds: i.participantIds
                                }, !1)];
                            case tn.Z.CHATROOM_UNREAD:
                                return [2, t.dispatch(n.action$setLastMessageUnread(i.chatroomId, i.lastReadMessageSequence, !1))];
                            case tn.Z.MESSAGE_INDICATION_UPDATE:
                                if (j.j8(j.X3.MESSAGE_INDICATION_UPDATE, i), so.isExperimentOn(l.SdkExperiment.EnrichedChatroom)) return [2, ci({
                                    store: t,
                                    chatroomsActions: n,
                                    messagesActions: r,
                                    data: i
                                })];
                                break;
                            case tn.Z.PRESENCE_EVENT:
                                return [2, ti(t, i)];
                            case tn.Z.EXTERNAL_HOST:
                                j.j8(j.X3.EXTERNAL_HOST, i);
                                break;
                            default:
                                return [2]
                        }
                        return [2]
                    }))
                }))
            }
            var li = function(e) {
                    j.j8(j.X3.NEW_REALTIME_MESSAGE, e)
                },
                di = function() {
                    function e() {}
                    return e.setConnectivityProvider = function(e) {
                        this.connectivityProvider = e, e.addEventListener(this.listener.bind(this))
                    }, e.executeEveryTimeOnBackToOnline = function(e) {
                        var t = this;
                        if (this.connectivityProvider) return this.networkResumeCallbacks.push(e),
                            function() {
                                return t.removeFromBackToOnline(e)
                            }
                    }, Object.defineProperty(e, "online", {
                        get: function() {
                            var e, t;
                            return null === (t = null === (e = this.connectivityProvider) || void 0 === e ? void 0 : e.fetch()) || void 0 === t || t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.executeEveryTimeOnOffline = function(e) {
                        var t = this;
                        if (this.connectivityProvider) return this.networkPauseCallbacks.push(e),
                            function() {
                                return t.removeFromOnOffline(e)
                            }
                    }, Object.defineProperty(e, "waitForOnline", {
                        get: function() {
                            var e = this;
                            return !this.connectivityProvider || this.connectivityProvider.fetch() ? Promise.resolve() : new Promise((function(t) {
                                return e.resolveOnOnline.push(t)
                            }))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.removeFromBackToOnline = function(e) {
                        this.networkResumeCallbacks.splice(this.networkResumeCallbacks.indexOf(e), 1)
                    }, e.removeFromOnOffline = function(e) {
                        this.networkPauseCallbacks.splice(this.networkResumeCallbacks.indexOf(e), 1)
                    }, e.listener = function(e) {
                        var t = this,
                            n = function(e) {
                                return e()
                            };
                        return e ? Promise.all((0, v.__spreadArrays)(this.resolveOnOnline.map(n), this.networkResumeCallbacks.map(n))).then((function() {
                            return t.resolveOnOnline = []
                        })) : Promise.all(this.networkPauseCallbacks.map(n))
                    }, e.resolveOnOnline = [], e.networkResumeCallbacks = [], e.networkPauseCallbacks = [], e
                }(),
                hi = function() {
                    function e(e) {
                        var t = e.store,
                            n = e.actions;
                        this.store = t, this.actions = n
                    }
                    return e.prototype.subscribe = function(e, t) {
                        var n, r = this,
                            i = function() {
                                var i = function(e, t) {
                                    var n = k()(e, ["unseenChatroomCount", "byFilter", Be(t)]);
                                    return !n || f()(n) ? null : "resyncCountdown" in n ? {
                                        count: Pe.maxUnreadsCount,
                                        overflow: !0
                                    } : {
                                        count: Math.min(Pe.maxUnreadsCount, Object.keys(n.chatrooms).length),
                                        overflow: Object.keys(n.chatrooms).length > Pe.maxUnreadsCount
                                    }
                                }(r.store.getState(), t);
                                i && !z()(n, i) && (n = i, e(i))
                            };
                        return i(), di.waitForOnline.then((function() {
                            return r.store.dispatch(r.actions.updateUnseenChatrooms(t))
                        })), {
                            unsubscribe: this.store.subscribe(i)
                        }
                    }, e.prototype.markChatroomsAsSeen = function(e) {
                        return this.store.dispatch(this.actions.markChatroomsAsSeen(e))
                    }, e
                }(),
                pi = function(e, t, n) {
                    return Br()(t.chatrooms.filter((function(e) {
                        var t = e.chatroomId,
                            r = n.chatrooms.byId[t];
                        return !r || Qe(r)
                    })), function(e, t) {
                        return Object.values(Ie(e.chatrooms.byId, "participantId" in t ? {
                            participantIds: [t.participantId]
                        } : {
                            participantType: t.participantType
                        })).filter(Qe).map((function(e) {
                            var t = e.id,
                                n = e.lastSeenMessageSequence;
                            return n ? {
                                chatroomId: t,
                                lastSeenMessageSequence: n
                            } : {
                                chatroomId: t,
                                lastSeenMessageSequence: 0
                            }
                        }))
                    }(n, e), (function(e) {
                        return e.chatroomId
                    }))
                },
                fi = function() {
                    function e(e) {
                        this.serverApi = e
                    }
                    return e.prototype.updateUnseenChatrooms = function(e) {
                        var t = this;
                        return function(n, r) {
                            return n({
                                type: je.SET_UNSEEN_CHATROOMS,
                                payload: (0, v.__awaiter)(t, void 0, void 0, (function() {
                                    var t, n;
                                    return (0, v.__generator)(this, (function(i) {
                                        switch (i.label) {
                                            case 0:
                                                return t = pi, n = [e], [4, this.serverApi.http$fetchUnseenChatroomCount(e, Pe.maxTrackableUnreads + 1)];
                                            case 1:
                                                return [2, t.apply(void 0, n.concat([i.sent(), r()]))]
                                        }
                                    }))
                                })),
                                meta: {
                                    filter: e
                                }
                            })
                        }
                    }, e.prototype.markChatroomAsSeen = function(e) {
                        var t = this;
                        return function(n, r) {
                            var i = r();
                            return n({
                                type: je.MARK_CHATROOM_SEEN,
                                payload: e,
                                meta: {
                                    chatroom: r().chatrooms.byId[e]
                                }
                            }), Promise.all(Object.keys(i.unseenChatroomCount.byFilter).filter((function(e) {
                                return function(e, t) {
                                    return e && t && "resyncCountdown" in e && "resyncCountdown" in t && 1 === e.resyncCountdown && 0 === t.resyncCountdown
                                }(i.unseenChatroomCount.byFilter[e], r().unseenChatroomCount.byFilter[e])
                            })).map((function(e) {
                                return n(t.updateUnseenChatrooms(Ve(e)))
                            })))
                        }
                    }, e.prototype.markChatroomsAsSeen = function(e) {
                        var t = this;
                        return function(n, r) {
                            return n({
                                type: je.MARK_CHATROOMS_SEEN,
                                payload: t.serverApi.http$markChatroomsAsSeen(e, ot(r())),
                                meta: {
                                    filter: e,
                                    filteredChatrooms: Object.values(Ie(r().chatrooms.byId, "participantId" in e ? {
                                        participantIds: [e.participantId]
                                    } : {
                                        participantType: e.participantType
                                    }))
                                }
                            })
                        }
                    }, e
                }(),
                mi = fi,
                gi = function() {
                    function e(e) {
                        this.serverApi = e
                    }
                    return e.prototype.fetchAndUpdateUnreadChatrooms = function(e) {
                        var t = this;
                        return function(n) {
                            var r = t.serverApi.http$fetchUnreadChatroomIdsMap({
                                filter: e,
                                unreadChatroomLimit: c
                            });
                            return n({
                                type: je.SET_UNREAD_CHATROOMS_MAP,
                                payload: r,
                                meta: {
                                    filter: e
                                }
                            })
                        }
                    }, e.prototype.markChatroomAsRead = function(e) {
                        return function(t, n) {
                            t({
                                type: je.MARK_CHATROOM_READ,
                                payload: e,
                                meta: {
                                    chatroom: n().chatrooms.byId[e]
                                }
                            })
                        }
                    }, e
                }(),
                _i = gi,
                vi = n(37213),
                yi = n.n(vi);
            var bi = (0, q.P1)([function(e) {
                    return e.presence.participantsById
                }], (function(e) {
                    var t = {};
                    return yi()(e, (function(e, n) {
                        e.online && (t[e.groupId] = (0, v.__spreadArrays)(t[e.groupId] || [], [n]))
                    })), t
                })),
                Ii = function() {
                    function e(e, t, n) {
                        this.currentUser = e, this.serverApi = t, this.store = n
                    }
                    return e.prototype.watch = function(e) {
                        return void 0 === e && (e = !1), this.serverApi.http$watch(e)
                    }, e.prototype.subscribeToPresenceChanges = function(e) {
                        var t, n = this,
                            r = e.callback,
                            i = e.preFetchPresence,
                            o = e.preFetchPresenceList;
                        o && this.store.dispatch(Jr.action$fetchListPresence(o)), i && this.store.dispatch(Jr.action$fetchPresence(i));
                        var s = function() {
                            var e = n.store.getState(),
                                s = e.presence,
                                a = void 0 === i && void 0 === o,
                                c = void 0 !== i && s.didFetchPresence || void 0 !== o && s.didFetchListPresence;
                            if (s && !z()(t, s)) {
                                if (!a && !c) return;
                                t = s;
                                var u = {
                                    participantsById: s.participantsById,
                                    participantsByGroupId: bi(e)
                                };
                                r(u)
                            }
                        };
                        return this.hasParticipants() && s(), {
                            unsubscribe: this.store.subscribe(s)
                        }
                    }, e.prototype.set = function(e, t, n) {
                        var r = {
                            userId: this.currentUser.userId,
                            sessionId: e,
                            group: t,
                            data: n,
                            status: er.ONLINE
                        };
                        return this.currentUser.token ? this.serverApi.http$setPresence(r, this.currentUser.token) : Promise.reject("Unable to setPresence without chatToken")
                    }, e.prototype.hasParticipants = function() {
                        return !f()(this.store.getState().presence.participantsById)
                    }, e
                }(),
                Ei = {
                    reportMonitoringBi: function() {}
                };

            function Si(e) {
                return e - l.HistorySinceRealtimeConnectionWasEstablished
            }
            var wi = n(91815),
                Ci = n.n(wi),
                Ti = {
                    count: 0,
                    overflow: !1
                },
                Ai = function(e, t) {
                    if (f()(null == e ? void 0 : e.unreadChatroomCount.byFilter)) return Ti;
                    if (!(null == t ? void 0 : t.participantIds)) return function(e) {
                        var t = Object.values(e).reduce((function(e, t) {
                            var n = t.chatrooms;
                            return e.push.apply(e, Object.keys(n)), e
                        }), []);
                        return {
                            count: Math.min(Pe.maxUnreadsCount, Object.keys(Ci()(t)).length),
                            overflow: !1
                        }
                    }(e.unreadChatroomCount.byFilter);
                    var n = function(e, t) {
                        return e.reduce((function(e, n) {
                            var r = ((null == t ? void 0 : t.unreadChatroomCount.byFilter[n]) || {
                                chatrooms: {}
                            }).chatrooms;
                            return {
                                chatrooms: (0, v.__assign)((0, v.__assign)({}, e.chatrooms), r)
                            }
                        }), {
                            chatrooms: {}
                        })
                    }(null == t ? void 0 : t.participantIds, e).chatrooms;
                    return {
                        count: Math.min(Pe.maxUnreadsCount, Object.keys(n).length),
                        overflow: !1
                    }
                },
                Ri = n(98978),
                Pi = n.n(Ri),
                Oi = function() {
                    function e(e) {
                        var t = e.store,
                            n = e.actions;
                        this.store = t, this.actions = n
                    }
                    return e.prototype.subscribe = function(e, t) {
                        var n, r = this,
                            i = function() {
                                var i = r.store.getState(),
                                    o = Ai(i, t);
                                n || 0 !== (null == o ? void 0 : o.count) || (n = o), o && !z()(n, o) && (n = o, e(o))
                            };
                        return i(), di.waitForOnline.then((function() {
                            return r.store.dispatch(r.actions.fetchAndUpdateUnreadChatrooms(t))
                        })), {
                            unsubscribe: this.store.subscribe(i)
                        }
                    }, e.prototype.subscribeToBreakdown = function(e, t) {
                        var n, r = this;
                        return di.waitForOnline.then((function() {
                            return r.store.dispatch(r.actions.fetchAndUpdateUnreadChatrooms(t))
                        })), {
                            unsubscribe: this.store.subscribe((function() {
                                var i = function(e) {
                                        var t = null == e ? void 0 : e.unreadChatroomCount.byFilter;
                                        return Object.keys(t).reduce((function(e, n) {
                                            return e[n] = {
                                                count: Object.keys(t[n].chatrooms).length
                                            }, e
                                        }), {})
                                    }(r.store.getState()),
                                    o = z()(Pi()(null == t ? void 0 : t.participantIds), Pi()(Object.keys(i))),
                                    s = i && !z()(n, i);
                                o && s && (n = i, e(i))
                            }))
                        }
                    }, e
                }(),
                ki = Oi,
                Ni = n(99779),
                Di = n.n(Ni),
                Mi = n(64133),
                xi = JSON.parse('["wix.com","editorx.com","wix-code.com","wixapps.net","wixprod.net"]'),
                Li = n(13158);

            function Ui() {
                var e;
                return void 0 !== Li && null != (null === (e = null == Li ? void 0 : Li.versions) || void 0 === e ? void 0 : e.node)
            }
            var Fi = "www.wix.com",
                ji = "http",
                qi = n(13158);

            function Hi(e) {
                if ("string" != typeof e) throw new TypeError("Expected a `string`, got `".concat(typeof e, "`"));
                return /(^https?:)|(^\/\/)/.test(e)
            }

            function Wi(e, t) {
                return t.split(".").filter((function(e) {
                    return e
                })).reduce((function(e, t) {
                    return e[t]
                }), e)
            }

            function Bi(e) {
                try {
                    return new URL(e).protocol
                } catch (e) {
                    return "http:"
                }
            }

            function Vi(e) {
                var t;
                try {
                    t = new URL(e)
                } catch (n) {
                    t = new URL("http:".concat(e))
                }
                return t.host
            }

            function Gi(e, t) {
                var n;
                try {
                    (n = new URL(e)).host = t, n.protocol = "http"
                } catch (r) {
                    (n = new URL("http://".concat(t))).pathname = e
                }
                return n.toString()
            }

            function zi() {
                var e, t;
                if (Ui() && qi.env.HTTP_CLIENT_GLOBAL_CONFIG) try {
                    e = JSON.parse(qi.env.HTTP_CLIENT_GLOBAL_CONFIG)
                } catch (e) {}
                return e || ("undefined" != typeof window ? e = window._httpClientGlobalConfig : "object" == typeof self && (null === (t = null === self || void 0 === self ? void 0 : self.constructor) || void 0 === t || t.name)), e || {
                    httpMockServer: {
                        enabled: !1
                    }
                }
            }

            function $i(e) {
                var t;
                return (null === (t = null == e ? void 0 : e.headers) || void 0 === t ? void 0 : t["x-wix-request-id"]) || ""
            }
            var Ki = function(e) {
                var t = e.url,
                    n = e.disableWixHeaders,
                    r = e.wixHeadersOpts,
                    i = !n && function(e) {
                        var t = !Hi(e);
                        if (t) return !0;
                        var n = ".".concat(Vi(e));
                        return !!xi.find((function(e) {
                            return n.endsWith(".".concat(e))
                        }))
                    }(t);
                return i ? (0, Mi.createHeaders)(r) : {}
            };
            var Yi = function(e) {
                var t, n = e.requestOptions,
                    r = e.urlObject,
                    i = r.protocol,
                    o = r.host,
                    s = e.wixHeadersOpts,
                    a = e.globalConfig,
                    c = void 0 === a ? {
                        httpMockServer: {
                            enabled: !1
                        }
                    } : a,
                    u = n.url,
                    l = n.params,
                    d = n.disableWixHeaders,
                    h = n.headers;
                if (l && "object" != typeof l) throw new Error("Search params must be an object");
                var p = Ki({
                        url: u,
                        disableWixHeaders: d,
                        wixHeadersOpts: s
                    }),
                    f = function(e, t) {
                        if (t.httpMockServer.enabled) {
                            return {
                                url: Gi(e, new URL(t.httpMockServer.mockServerUrl).host)
                            }
                        }
                        return {}
                    }(u, c),
                    m = c.httpMockServer.enabled ? ((t = {})["x-wix-metro-original-url"] = function(e, t) {
                        var n = new URL(e, "http://unused.com"),
                            r = n.pathname,
                            i = n.searchParams;
                        if (t = t || i) {
                            var o = function(e) {
                                    return Object.entries(e).map((function(e) {
                                        var t = e[0],
                                            n = e[1];
                                        return "".concat(t, "=").concat(encodeURIComponent(n))
                                    })).flat().join("&")
                                }(t) || t.toString(),
                                s = o ? "?".concat(o) : "";
                            return "".concat(r).concat(s)
                        }
                        return r
                    }(u, l), t["x-wix-metro-original-host"] = Hi(u) ? Vi(u) : o, t["x-wix-metro-original-protocol"] = Hi(u) ? Bi(u) : i, t) : {};
                return (0, v.__assign)((0, v.__assign)((0, v.__assign)({}, n), f), {
                    headers: (0, v.__assign)((0, v.__assign)((0, v.__assign)({}, p), Ji(h)), m)
                })
            };

            function Ji(e) {
                return e = e || {}, Object.keys(e).reduce((function(t, n) {
                    var r;
                    return (0, v.__assign)((0, v.__assign)({}, t), ((r = {})[n.toLowerCase()] = e[n], r))
                }), {})
            }
            var Qi = ["code", "stack", "config", "request", "response", "toJSON", "__CANCEL__"],
                Xi = function(e) {
                    function t(n) {
                        var r = e.call(this, n.message) || this;
                        return r.isWixHttpError = !0, Object.setPrototypeOf(r, t.prototype), Qi.forEach((function(e) {
                            r[e] = n[e]
                        })), r
                    }
                    return (0, v.__extends)(t, e), Object.defineProperty(t.prototype, "requestId", {
                        get: function() {
                            return $i(this.response)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(Error),
                Zi = n(62399),
                eo = n.n(Zi),
                to = function() {
                    function e(e) {
                        void 0 === e && (e = {}), this.opts = e, this.opts = function(e) {
                            var t = eo();
                            Ui() && (t = require("axios/lib/adapters/http"));
                            return (0, v.__assign)({
                                adapter: t,
                                isSSR: !1
                            }, e)
                        }(this.opts), this.client = Di().create(this.opts)
                    }
                    return e.isHttpError = function(e) {
                        return !!(null == e ? void 0 : e.isWixHttpError)
                    }, e.prototype.request = function(e) {
                        var t, n;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var r, i, o, s, a, c, u = this;
                            return (0, v.__generator)(this, (function(l) {
                                var d;
                                return d = this.opts, r = d.baseURL ? Vi(d.baseURL) : d.isSSR ? Fi : "undefined" != typeof self ? self.location.host : "", i = function(e) {
                                    return e.baseURL ? Bi(e.baseURL) : e.isSSR ? ji : "undefined" != typeof self ? self.location.protocol : ""
                                }(this.opts), o = {
                                    protocol: i,
                                    host: r
                                }, s = "function" == typeof e ? e({
                                    isSSR: this.opts.isSSR,
                                    host: r
                                }) : e, a = (null === (n = (t = this.opts).getAppToken) || void 0 === n ? void 0 : n.call(t)) || "", c = Yi({
                                    requestOptions: s,
                                    urlObject: o,
                                    wixHeadersOpts: {
                                        signedInstance: a,
                                        artifactId: this.opts.artifactId,
                                        csrf: !1,
                                        multilingualOptions: this.opts.multilingualOptions
                                    },
                                    globalConfig: zi()
                                }), this.opts.isSSR && (c.baseURL = "".concat(ji, "://").concat(Fi)), [2, this.client.request(c).catch((function(e) {
                                    return u.maybeFallbackRequest(e, s, o, a)
                                })).catch((function(e) {
                                    return u.handleRequestError(e, c)
                                })).then((function(e) {
                                    return u.transformResponse(e, s)
                                }))]
                            }))
                        }))
                    }, e.prototype.get = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n;
                            return (0, v.__generator)(this, (function(r) {
                                return n = (0, v.__assign)((0, v.__assign)({}, t), {
                                    url: e,
                                    method: "GET"
                                }), [2, this.request(n)]
                            }))
                        }))
                    }, e.prototype.delete = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n;
                            return (0, v.__generator)(this, (function(r) {
                                return n = (0, v.__assign)((0, v.__assign)({}, t), {
                                    url: e,
                                    method: "DELETE"
                                }), [2, this.request(n)]
                            }))
                        }))
                    }, e.prototype.head = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n;
                            return (0, v.__generator)(this, (function(r) {
                                return n = (0, v.__assign)((0, v.__assign)({}, t), {
                                    url: e,
                                    method: "HEAD"
                                }), [2, this.request(n)]
                            }))
                        }))
                    }, e.prototype.options = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var n;
                            return (0, v.__generator)(this, (function(r) {
                                return n = (0, v.__assign)((0, v.__assign)({}, t), {
                                    url: e,
                                    method: "OPTIONS"
                                }), [2, this.request(n)]
                            }))
                        }))
                    }, e.prototype.post = function(e, t, n) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var r;
                            return (0, v.__generator)(this, (function(i) {
                                return r = (0, v.__assign)((0, v.__assign)({}, n), {
                                    url: e,
                                    data: t,
                                    method: "POST"
                                }), [2, this.request(r)]
                            }))
                        }))
                    }, e.prototype.put = function(e, t, n) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var r;
                            return (0, v.__generator)(this, (function(i) {
                                return r = (0, v.__assign)((0, v.__assign)({}, n), {
                                    url: e,
                                    data: t,
                                    method: "PUT"
                                }), [2, this.request(r)]
                            }))
                        }))
                    }, e.prototype.patch = function(e, t, n) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var r;
                            return (0, v.__generator)(this, (function(i) {
                                return r = (0, v.__assign)((0, v.__assign)({}, n), {
                                    url: e,
                                    data: t,
                                    method: "PATCH"
                                }), [2, this.request(r)]
                            }))
                        }))
                    }, Object.defineProperty(e.prototype, "CancelToken", {
                        get: function() {
                            return Di().CancelToken
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "isCancel", {
                        get: function() {
                            return Di().isCancel
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.handleRequestError = function(e, t) {
                        var n = new Xi(e);
                        throw function(e) {
                            (0, v.__awaiter)(this, void 0, void 0, (function() {
                                return (0, v.__generator)(this, (function(t) {
                                    switch (t.label) {
                                        case 0:
                                            return t.trys.push([0, 2, , 3]), [4, e()];
                                        case 1:
                                        case 2:
                                            return t.sent(), [3, 3];
                                        case 3:
                                            return [2]
                                    }
                                }))
                            }))
                        }((function() {
                            var e;
                            return null === (e = t.onError) || void 0 === e ? void 0 : e.call(t, n)
                        })), n
                    }, e.prototype.maybeFallbackRequest = function(e, t, n, r) {
                        var i, o, s;
                        if (zi().httpMockServer.enabled && zi().httpMockServer.allowUnmocked && 404 === (null === (i = e.response) || void 0 === i ? void 0 : i.status) && "NO_SCENARIO_FOUND" === (null === (s = null === (o = e.response) || void 0 === o ? void 0 : o.data) || void 0 === s ? void 0 : s.msg)) {
                            var a = Yi({
                                requestOptions: t,
                                urlObject: n,
                                wixHeadersOpts: {
                                    signedInstance: r,
                                    artifactId: this.opts.artifactId
                                }
                            });
                            return this.client.request(a)
                        }
                        throw e
                    }, e.prototype.transformResponse = function(e, t) {
                        var n = $i(e),
                            r = function(e, t) {
                                var n = e.data;
                                t._pickResponseBody && (n = Wi(e.data, t._pickResponseBody));
                                if (t._logs) {
                                    var r = Wi(e.data, t._logs);
                                    (null == r ? void 0 : r.length) && r.map((function(e) {
                                        return console.log.apply(console, e)
                                    }))
                                }
                                return n
                            }(e, t);
                        return (0, v.__assign)((0, v.__assign)({}, e), {
                            data: r,
                            requestId: n
                        })
                    }, e.CancelToken = Di().CancelToken, e.isCancel = Di().isCancel, e
                }();
            var no = function(e) {
                    var t, n = (t = (0, v.__assign)((0, v.__assign)({}, e), {
                        baseURL: e.baseURL || "/"
                    }), new to(t));
                    return function(e) {
                        return n.request(e).catch((function(e) {
                            throw new w(e, w.TYPES.HTTP_REQUEST)
                        }))
                    }
                },
                ro = function() {
                    function e() {
                        var e = this;
                        this.unseenChatroom = {
                            subscribeToCount: function(t, n) {
                                return e._assertInitialized(), e.unseenChatroomCountApi.subscribe(t, n)
                            },
                            markChatroomsAsSeen: function(t) {
                                return e._assertInitialized(), e.unseenChatroomCountApi.markChatroomsAsSeen(t)
                            }
                        }, this._initialized = !1, this._experiments = {}, this._onConnectCallbacks = [], this._onConnectingCallbacks = [], this._onConnectionEstablishedCallbacks = [], this._onDisconnectCallbacks = [], this._onInitCallbacks = [], this._connected = !1, this._connectivityProviderWasSet = !1, this._currentUser = new Ct
                    }
                    return e.prototype.waitForInitialized = function() {
                        var e = this;
                        return new Promise((function(t) {
                            return function(t) {
                                return e._registerOnInit((function() {
                                    return t()
                                }))
                            }(t)
                        }))
                    }, Object.defineProperty(e.prototype, "initialized", {
                        get: function() {
                            return this._initialized
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "appId", {
                        get: function() {
                            return this._appId
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "_chatroomsApi", {
                        get: function() {
                            return this.chatroomsApi
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "_chatroomApi", {
                        get: function() {
                            return this.chatroomApi
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "_persistenceService", {
                        get: function() {
                            return this.persistenceService
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "_subscriptionService", {
                        get: function() {
                            return this.subscriptionService
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.setRequestHandler = function(e) {
                        this.requestHandler = e.requestHandler || no({
                            baseURL: e.chatServerUrl
                        })
                    }, e.prototype.initWithHandshake = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t, n, r;
                            return (0, v.__generator)(this, (function(i) {
                                switch (i.label) {
                                    case 0:
                                        if (io(e), this.setConnectivityProviderIfNeeded(e.connectivityProvider), this.setRequestHandler(e), this.clear(), !(t = e.tokenServer)) throw new Error("Trying to call init with handshake without passing the issue server url");
                                        return [4, Bt(e.persistenceEngine)];
                                    case 1:
                                        return !(n = i.sent()) && t && di.online ? [4, Wt(t)] : [3, 3];
                                    case 2:
                                        n = i.sent(), i.label = 3;
                                    case 3:
                                        return r = so.init(Object.assign({}, e, {
                                            chatToken: n
                                        })), n ? [4, Vt(n, e.persistenceEngine)] : [3, 5];
                                    case 4:
                                        i.sent(), i.label = 5;
                                    case 5:
                                        return [2, r]
                                }
                            }))
                        }))
                    }, e.prototype.setConnectivityProviderIfNeeded = function(e) {
                        e && !this._connectivityProviderWasSet && (di.setConnectivityProvider(e), this._connectivityProviderWasSet = !0)
                    }, e.prototype.init = function(e) {
                        var t = this,
                            n = e.chatToken,
                            r = e.preFetch,
                            i = void 0 !== r && r,
                            o = e.appId;
                        this.setRequestHandler(e), this.initServices(e), this._initialized = !0, this._appId = o, this.notifyOnInit();
                        var s = di.online;
                        return di.waitForOnline.then((function() {
                            i && t._fetchRooms({
                                isSilent: !1
                            }), t.connectToRealtime({
                                chatToken: n,
                                eventHooks: t._eventHooks
                            }).catch((function(e) {
                                console.error("ErrorOnConnectToRealtime", e)
                            })), t.serverApi.http$fetchCurrentUserDisplayData().then((function(e) {
                                t._currentUser.displayData = e
                            })), t._connected = !0, t._onConnectCallbacks.forEach((function(e) {
                                return e()
                            })), t.chatroomsApi.fetchMessageDrafts(), s || t.subscriptionService.refreshSubscribedData(), di.executeEveryTimeOnBackToOnline(t.reconnect.bind(t, {
                                chatToken: n,
                                tokenServer: e.tokenServer
                            })), di.executeEveryTimeOnOffline(t.disconnect.bind(t))
                        })), this
                    }, e.prototype.initServices = function(e) {
                        var t, n = e.chatServerUrl,
                            r = e.chatToken,
                            i = e.eventHooks,
                            o = void 0 === i ? {} : i,
                            s = e.experiments,
                            a = void 0 === s ? {} : s,
                            c = e.appName,
                            u = e.persistenceEngine,
                            d = e.httpHeaders,
                            h = e.tokenServer,
                            p = e.connectivityProvider,
                            f = e.presenceOptions;
                        io({
                            chatServerUrl: n,
                            chatToken: r,
                            tokenServer: h
                        }), this.clear(), this._currentUser.loadJwtChatToken(r), lt.setAppName(c), this._currentUser.token = r, this._experiments = a, this._eventHooks = Object.assign(oo, o), this.realtimeClient = (t = new(Yr())(void 0, {
                            atomicServerTime: this.isExperimentOn(l.SdkExperiment.FirebaseAtomicServerTime)
                        }), {
                            connect: function(e) {
                                var n = e.realtimeServiceSetup,
                                    r = e.onEvent,
                                    i = e.eventHooks,
                                    o = void 0 === i ? Ei : i;
                                return (0, v.__awaiter)(this, void 0, void 0, (function() {
                                    var e, i, s, a, c, u, l, d, h, p;
                                    return (0, v.__generator)(this, (function(f) {
                                        switch (f.label) {
                                            case 0:
                                                if (e = function() {
                                                        var e = {
                                                            tag: "realtime",
                                                            description: "onConnect success"
                                                        };
                                                        return j.CI.emit(j.X3.MONITORING_BI, e), o.reportMonitoringBi(e)
                                                    }, i = function(e) {
                                                        var t = {
                                                            tag: "realtime",
                                                            description: "onConnect failure " + e
                                                        };
                                                        return j.CI.emit(j.X3.MONITORING_BI, t), o.reportMonitoringBi(t)
                                                    }, s = n.options, a = n.authKey, !(c = n.eventsPath)) throw u = "chat-sdk.realtime.client: unexpected data received", console.error(u, n), new Error(u);
                                                l = function(e, t) {
                                                    var n = e.value;
                                                    setTimeout((function() {
                                                        try {
                                                            var e = JSON.stringify(n);
                                                            o.reportMonitoringBi({
                                                                tag: "realtime",
                                                                description: "RT Event: " + n.type,
                                                                internal: e
                                                            })
                                                        } catch (e) {
                                                            console.error("Error parsing RT event value: " + n)
                                                        }
                                                    }), 0), r((0, v.__assign)((0, v.__assign)({}, n), {
                                                        connectionEstablishedTimestamp: t
                                                    }))
                                                }, d = c.split("/").slice(0, -1).join("/") + "/timestamp", f.label = 1;
                                            case 1:
                                                return f.trys.push([1, 4, , 5]), [4, t.connect(s, a)];
                                            case 2:
                                                return f.sent(), [4, t.getFirebaseServerTime(d)];
                                            case 3:
                                                return h = f.sent(), t.listenOnPath(c, {
                                                    orderBy: "timestamp",
                                                    startAt: Si(h)
                                                }).when("child_added").call((function(e) {
                                                    var t = e.value;
                                                    return l({
                                                        value: t
                                                    }, h)
                                                })), t.listenOnPath(c, {
                                                    orderBy: "timestamp",
                                                    startAt: Si(h)
                                                }).when("child_changed").call((function(e) {
                                                    var t = e.value;
                                                    return l({
                                                        value: t
                                                    }, h)
                                                })), e(), [3, 5];
                                            case 4:
                                                throw p = f.sent(), i(p), p;
                                            case 5:
                                                return [2]
                                        }
                                    }))
                                }))
                            },
                            disconnect: function() {
                                t.disconnect()
                            }
                        });
                        var m, g = new jt;
                        m = new Jt(h ? {
                            baseURL: n,
                            currentUser: this._currentUser,
                            httpHeaders: d,
                            tokenServer: h
                        } : {
                            baseURL: n,
                            currentUser: this._currentUser,
                            httpHeaders: d
                        }), this.serverApi = new Et(m), this.setConnectivityProviderIfNeeded(p), this.persistenceService = new Lt(u, this.getUserId(), this._currentUser.participantIds), this.unseenChatroomCountActions = new mi(this.serverApi), this.unreadChatroomCountActions = new _i(this.serverApi);
                        var _ = this.unreadChatroomCountActions,
                            y = vt(this.serverApi, this.persistenceService, this._eventHooks, this.unseenChatroomCountActions, _, a);
                        this.store = this._setupStoreReuseIfNecessary(y), this.unseenChatroomCountApi = new hi({
                            store: this.store,
                            actions: this.unseenChatroomCountActions
                        }), this.unreadChatroomCountApi = new ki({
                            store: this.store,
                            actions: this.unreadChatroomCountActions
                        });
                        var b = new Gr({
                                store: this.store,
                                chatroomsActions: y,
                                subscriptionService: g,
                                serverApi: this.serverApi,
                                unreadChatroomCountActions: this.unreadChatroomCountActions
                            }),
                            I = new at({
                                store: this.store,
                                chatroomsActions: y,
                                subscriptionService: g,
                                currentUser: this._currentUser,
                                enrichedChatroom: this.isExperimentOn(l.SdkExperiment.EnrichedChatroom)
                            });
                        this.messagesActions = bt(this.serverApi);
                        var E = new $r({
                                store: this.store,
                                messagesActions: this.messagesActions,
                                subscriptionService: g
                            }),
                            S = new Ot(this.store, y, this.serverApi, this.persistenceService);
                        this.presenceOptions = f, this.presence = new Ii(this._currentUser, this.serverApi, this.store), Object.assign(this, {
                            subscriptionService: g,
                            chatroomsActions: y,
                            chatroomsApi: b,
                            chatroomApi: I,
                            messagesApi: E,
                            textTypingService: S
                        })
                    }, e.prototype.clear = function() {
                        this._initialized && (this.store.dispatch(this.chatroomsActions.action$resetStore()), this._initialized = !1), this._connected && this.disconnect()
                    }, e.prototype.disconnect = function() {
                        this.store.dispatch(Jr.action$clearPresence()), this._onDisconnectCallbacks.forEach((function(e) {
                            return e()
                        })), this.realtimeClient.disconnect(), this._connected = !1
                    }, e.prototype.reissueTokenIfNeeded = function(e) {
                        var t = e.chatToken,
                            n = e.tokenServer;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e;
                            return (0, v.__generator)(this, (function(r) {
                                switch (r.label) {
                                    case 0:
                                        return n ? !t || Gt(t) ? [3, 1] : (this._currentUser.token = t, [3, 3]) : [2, Promise.reject("TokenServer must be provided")];
                                    case 1:
                                        return di.online ? (e = this._currentUser, [4, Wt(n)]) : [2, Promise.reject("Unable to reissue token when offline")];
                                    case 2:
                                        e.token = r.sent(), r.label = 3;
                                    case 3:
                                        return this._currentUser.loadJwtChatToken(t), [2, this._currentUser.token]
                                }
                            }))
                        }))
                    }, e.prototype.reconnect = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return this._assertInitialized(), this._connected ? [2] : [4, this.reissueTokenIfNeeded(e)];
                                    case 1:
                                        return t = n.sent(), this._onConnectCallbacks.forEach((function(e) {
                                            return e()
                                        })), [2, Promise.all([this.subscriptionService.refreshSubscribedData(), this.connectToRealtime({
                                            chatToken: t,
                                            eventHooks: this._eventHooks
                                        })])]
                                }
                            }))
                        }))
                    }, e.prototype.reconnectWithHandshake = function(e) {
                        var t = e.tokenServer;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var e;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        if (!t) throw new Error("Trying to reconnect chat-sdk without a `tokenServer`");
                                        return this._connected ? [2] : [4, Bt(this.persistenceService.persistenceEngine)];
                                    case 1:
                                        return e = n.sent(), [2, this.reconnect({
                                            chatToken: e,
                                            tokenServer: t
                                        })]
                                }
                            }))
                        }))
                    }, e.prototype.onConnecting = function(e) {
                        this._onConnectingCallbacks.push(e)
                    }, e.prototype.onConnectionEstablished = function(e) {
                        this._onConnectionEstablishedCallbacks.push(e)
                    }, e.prototype.onDisconnect = function(e) {
                        this._onDisconnectCallbacks.push(e)
                    }, e.prototype.subscribeToChatRoomsList = function(e) {
                        var t = e.subscriberId,
                            n = e.callback,
                            r = e.filter;
                        return this._assertInitialized(), this.chatroomsApi.subscribeToChatRoomsList({
                            subscriberId: t,
                            callback: n,
                            filter: r
                        })
                    }, e.prototype.subscribeToChatRoom = function(e) {
                        var t = e.chatroomId,
                            n = e.onChange,
                            r = e.onNewMessage,
                            i = e.onInitialFetchDone,
                            o = e.onError,
                            s = e.initialCursor,
                            a = e.cursorStrategy;
                        return this._assertInitialized(), this.chatroomApi.subscribeToChatRoom({
                            chatroomId: t,
                            onChange: n,
                            onNewMessage: r,
                            onInitialFetchDone: i,
                            onError: o,
                            initialCursor: s,
                            cursorStrategy: a
                        })
                    }, e.prototype.subscribeToGlobalUnreadStatus = function(e) {
                        var t = e.callback,
                            n = e.filter;
                        if (this._assertInitialized(), !n) throw Error("Filter is now required");
                        return this.unreadChatroomCountApi.subscribe(t, n)
                    }, e.prototype.subscribeToBreakdownUnreadStatus = function(e) {
                        var t = e.callback,
                            n = e.filter;
                        return this._assertInitialized(), this.unreadChatroomCountApi.subscribeToBreakdown(t, n)
                    }, e.prototype.getUnreadCount = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(n) {
                                return this._assertInitialized(), [2, this.serverApi.http$fetchUnreadChatroomIds({
                                    filter: e,
                                    unreadChatroomLimit: t
                                })]
                            }))
                        }))
                    }, e.prototype.subscribeToDrillInMessageIndications = function(e) {
                        var t = e.chatroomId,
                            n = e.messageId,
                            r = e.sequence,
                            i = e.callback;
                        return this._assertInitialized(), this.messagesApi.subscribeToDrillInMessageIndications({
                            chatroomId: t,
                            messageId: n,
                            sequence: r,
                            callback: i
                        })
                    }, e.prototype.getChatroom = function(e) {
                        var t = e.chatroomId;
                        return this._assertInitialized(), this.chatroomApi.getChatroom({
                            chatroomId: t
                        })
                    }, e.prototype.getUnreadCountForRoom = function(e) {
                        return this.chatroomsApi.getUnreadCountForRoom(e)
                    }, e.prototype.getUnreadCountForRooms = function(e) {
                        return this.chatroomsApi.getUnreadCountForRooms(e)
                    }, e.prototype.fetchRooms = function(e) {
                        var t = e.filter,
                            n = e.cursor,
                            r = e.isSilent,
                            i = void 0 !== r && r;
                        return this._assertInitialized(), this._fetchRooms({
                            filter: t,
                            cursor: n,
                            isSilent: i
                        })
                    }, e.prototype.sendMessage = function(e) {
                        return this._assertInitialized(), this.chatroomApi.sendMessage(e)
                    }, e.prototype.getMessageWithSender = function(e) {
                        return this.chatroomApi.getMessageWithSender(e)
                    }, e.prototype.addMessage = function(e) {
                        var t = e.dto,
                            n = e.transit;
                        return this._assertInitialized(), this.chatroomApi.addMessage({
                            dto: t,
                            transit: n
                        })
                    }, e.prototype.addChatrooms = function(e) {
                        var t = e.rooms;
                        return this._assertInitialized(), this.chatroomsApi.addRooms({
                            rooms: t
                        })
                    }, e.prototype.deleteMessage = function(e, t) {
                        return void 0 === t && (t = !1), this._assertInitialized(), this.chatroomApi.deleteMessage(e, t)
                    }, e.prototype.resendMessage = function(e) {
                        return this._assertInitialized(), this.chatroomApi.resendMessage(e)
                    }, e.prototype.deleteLabel = function(e) {
                        return this._assertInitialized(), this.chatroomApi.deleteLabel(e)
                    }, e.prototype.unstarRoom = function(e) {
                        return this._assertInitialized(), this.chatroomApi.unstarRoom(e)
                    }, e.prototype.starRoom = function(e) {
                        return this._assertInitialized(), this.chatroomApi.starRoom(e)
                    }, e.prototype.notifyTyping = function(e, t) {
                        return this._assertInitialized(), this.textTypingService.notifyTyping(e, t)
                    }, e.prototype.notifyTypingTextChange = function(e, t, n) {
                        return void 0 === n && (n = !0), this._assertInitialized(), this.textTypingService.notifyTextChange(e, t, n)
                    }, e.prototype.deleteChatroom = function(e) {
                        return this._assertInitialized(), this.chatroomsApi.deleteChatroom(e)
                    }, e.prototype.deleteChatrooms = function(e, t) {
                        return this._assertInitialized(), this.chatroomsApi.deleteChatrooms(e, t)
                    }, e.prototype.archiveChatroom = function(e) {
                        return this._assertInitialized(), this.chatroomsApi.archiveChatroom(e)
                    }, e.prototype.archiveChatrooms = function(e, t) {
                        return this._assertInitialized(), this.chatroomsApi.archiveChatrooms(e, t)
                    }, e.prototype.unarchiveChatrooms = function(e, t) {
                        return this._assertInitialized(), this.chatroomsApi.unarchiveChatrooms(e, t)
                    }, e.prototype.unarchiveChatroom = function(e) {
                        return this._assertInitialized(), this.chatroomsApi.unarchiveChatroom(e)
                    }, e.prototype.setLastMessageUnread = function(e) {
                        var t = e.chatroomId;
                        return this._assertInitialized(), this.chatroomApi.setLastMessageUnread({
                            chatroomId: t
                        })
                    }, e.prototype.isExperimentOn = function(e) {
                        return ct(this._experiments, e)
                    }, e.prototype.getUserId = function() {
                        return this._currentUser.userId
                    }, e.prototype.clearPersistence = function() {
                        this.persistenceService && (this.persistenceService.clearMessageDrafts(), this.persistenceService.clearToken())
                    }, e.prototype.setAllRoomsAsRead = function(e, t) {
                        return void 0 === t && (t = !0), this.chatroomsApi.markAllRoomsAsRead(e, t)
                    }, e.prototype.setMessagesRead = function(e) {
                        var t = e.chatroomId;
                        return this._assertInitialized(), this.chatroomApi.setMessagesRead({
                            chatroomId: t
                        })
                    }, e.prototype.setRoomsMessagesRead = function(e) {
                        return this.chatroomApi.setRoomsMessagesRead(e)
                    }, e.prototype.verifySearchEnabled = function() {
                        if (this.isExperimentOn(l.SdkExperiment.MoveSearchToInbox)) throw new Error("Trying to call Search function while it is not supported by chat-sdk anymore")
                    }, e.prototype.setRoomsMessagesUnread = function(e) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            var t;
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return t = this.getUserId(), [4, this.chatroomsApi.setChatroomsUnread(e, t)];
                                    case 1:
                                        return n.sent(), [2]
                                }
                            }))
                        }))
                    }, e.prototype.search = function(e) {
                        var t = e.searchTerm,
                            n = e.participantIds,
                            r = e.chatroomsPageSize,
                            i = void 0 === r ? 10 : r,
                            o = e.chatroomsNextPointer,
                            s = void 0 === o ? 0 : o,
                            a = e.messagesPageSize,
                            c = void 0 === a ? 10 : a,
                            u = e.messagesNextPointer,
                            l = void 0 === u ? 0 : u;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(e) {
                                return this.verifySearchEnabled(), [2, this.chatroomsApi.search({
                                    searchTerm: t,
                                    participantIds: n,
                                    chatroomsPageSize: i,
                                    chatroomsNextPointer: s,
                                    messagesPageSize: c,
                                    messagesNextPointer: l
                                })]
                            }))
                        }))
                    }, e.prototype.getMessagesPage = function(e) {
                        var t = e.chatroomId,
                            n = e.messageSequence,
                            r = e.pageSize;
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(e) {
                                switch (e.label) {
                                    case 0:
                                        return [4, this.serverApi.http$fetchRoomMessagesPage({
                                            chatroomId: t,
                                            messageSequence: n,
                                            pageSize: r
                                        })];
                                    case 1:
                                        return [2, e.sent().reverse().map((function(e) {
                                            return new _.Z(e)
                                        }))]
                                }
                            }))
                        }))
                    }, e.prototype.buttonInteraction = function(e, t) {
                        return (0, v.__awaiter)(this, void 0, void 0, (function() {
                            return (0, v.__generator)(this, (function(n) {
                                switch (n.label) {
                                    case 0:
                                        return this._assertInitialized(), [4, this.chatroomApi.buttonInteraction(e, t)];
                                    case 1:
                                        return n.sent(), [2]
                                }
                            }))
                        }))
                    }, e.prototype.updateHttpHeaders = function(e) {
                        this.serverApi.updateHttpHeaders(e)
                    }, e.prototype.notifyOnInit = function() {
                        this._onInitCallbacks.forEach((function(e) {
                            return e()
                        }))
                    }, e.prototype._registerOnInit = function(e) {
                        this._initialized ? e() : this._onInitCallbacks.push(e)
                    }, e.prototype.connectToRealtime = function(e) {
                        var t, n, r = this,
                            i = e.chatToken,
                            o = e.eventHooks;
                        return (null === (t = this.presenceOptions) || void 0 === t ? void 0 : t.disableWatch) || this.presence.watch(null === (n = this.presenceOptions) || void 0 === n ? void 0 : n.useNewConvention), this.store.dispatch(Jr.action$clearStalePresenceSessions()), this._onConnectingCallbacks.forEach((function(e) {
                            return e()
                        })), i ? this.serverApi.http$initRealtimeToken(i).then((function(e) {
                            return r.realtimeClient.connect({
                                realtimeServiceSetup: e,
                                onEvent: function(e) {
                                    return ui({
                                        store: r.store,
                                        chatroomsActions: r.chatroomsActions,
                                        messagesActions: r.messagesActions,
                                        data: e,
                                        currentUser: r._currentUser
                                    })
                                },
                                eventHooks: o
                            })
                        })).then((function() {
                            return r._onConnectionEstablishedCallbacks.forEach((function(e) {
                                return e()
                            }))
                        })) : Promise.reject("Unexpected error: Unable to connect to realtime without a chatToken")
                    }, e.prototype._fetchRooms = function(e) {
                        var t = e.filter,
                            n = void 0 === t ? void 0 : t,
                            r = e.cursor,
                            i = void 0 === r ? void 0 : r,
                            o = e.isSilent,
                            s = void 0 !== o && o;
                        return this.chatroomsApi.fetchRooms({
                            filter: n,
                            cursor: i,
                            isSilent: s
                        })
                    }, e.prototype._assertInitialized = function() {
                        if (!this.initialized) throw new Error("Trying to call chat-sdk without having it initialized")
                    }, e.prototype._setupStoreReuseIfNecessary = function(e) {
                        if (this.existingStore) {
                            var t = this.existingStore;
                            return t.dispatch(e.action$resetStore()), t
                        }
                        return this.existingStore = function(e) {
                            var t = (void 0 === e ? {} : e).initialState;
                            return Hr(Nr, t)
                        }(), this.existingStore
                    }, e.prototype.getRequestHandler = function() {
                        return this.requestHandler
                    }, e
                }();

            function io(e) {
                var t = e.chatServerUrl,
                    n = e.chatToken,
                    r = e.tokenServer;
                if (!n && !r) throw new Error("Trying to initialize chat-sdk without chatToken or tokenServer");
                if (!t) throw new Error("Trying to initialize chat-sdk without chatServerUrl")
            }
            var oo = {
                    reportMonitoringBi: function() {
                        return null
                    }
                },
                so = "object" == typeof window ? (window.chatSdk || (window.chatSdk = new ro), window.chatSdk) : new ro
        },
        53079: function(e, t) {
            "use strict";
            t.Z = {
                MESSAGE_SENT: "MessageSent",
                MESSAGE_DELETED: "MessageDeleted",
                MESSAGE_UPDATED: "MessageUpdated",
                CHATROOM_DELETED: "ChatroomDeleted",
                CHATROOM_CREATED: "ChatroomCreated",
                CHATROOM_MERGED: "ChatroomMerged",
                TYPING_STARTED: "TypingStarted",
                TYPING_STOPPED: "TypingStopped",
                CHATROOOM_DISPLAY_DATA_UPDATED: "ChatroomDisplayDataUpdated",
                CHATROOM_ARCHIVED: "ChatroomArchived",
                CHATROOM_UNARCHIVED: "ChatroomUnarchived",
                CHATROOM_READ: "ChatroomRead",
                CHATROOMS_ALL_READ: "AllChatroomsMarkedAsRead",
                CHATROOM_UNREAD: "ChatroomUnread",
                MESSAGE_INDICATION_UPDATE: "MessageIndicationUpdate",
                PRESENCE_EVENT: "Presence",
                EXTERNAL_HOST: "ExternalHost",
                OFFLINE_CHANNEL_UPDATED: "ParticipantOfflineChannelUpdated",
                LABEL_ADDED: "LabelAddedToChatrooms",
                LABEL_REMOVED: "LabelRemovedFromChatrooms"
            }
        },
        63017: function(e, t, n) {
            "use strict";
            n.d(t, {
                CI: function() {
                    return d
                },
                X3: function() {
                    return s
                },
                xc: function() {
                    return a
                },
                NH: function() {
                    return c
                },
                j8: function() {
                    return u
                },
                ys: function() {
                    return l
                }
            });
            var r = n(6659),
                i = n(53079),
                o = "object" == typeof window ? (window._chatInternalEventEmitter || (window._chatInternalEventEmitter = new r.EventEmitter), window._chatInternalEventEmitter) : new r.EventEmitter,
                s = {
                    MESSAGES_READ: "crm.events.messagesRead",
                    MESSAGE_SENT: "crm.events.messageSent",
                    NEW_REALTIME_MESSAGE: "crm.events.newRealtimeMessage",
                    BI: "biEvent",
                    BI_ERROR: "biDebugErrorEvent",
                    MONITORING_BI: "monitoringBi",
                    EXTERNAL_HOST: i.Z.EXTERNAL_HOST,
                    OFFLINE_CHANNEL_UPDATED: i.Z.OFFLINE_CHANNEL_UPDATED,
                    MESSAGE_INDICATION_UPDATE: i.Z.MESSAGE_INDICATION_UPDATE
                },
                a = {
                    FETCH_ENRICHED_CHATROOM_COMPLETED: "chat.internal.events.fetchEnrichedChatroomCompleted",
                    FETCH_DRILL_IN_MESSAGE_INDICATIONS_COMPLETED: "chat.internal.events.fetchDrillInMessageIndicationsCompleted"
                },
                c = function(e, t) {
                    o.on(e, t)
                },
                u = function(e, t) {
                    o.emit(e, t)
                },
                l = function(e, t) {
                    o.removeListener(e, t)
                },
                d = {
                    addListener: c,
                    removeListener: l,
                    CHAT_EVENTS: s,
                    emit: u
                }
        },
        20880: function() {},
        8075: function() {},
        35810: function(e, t, n) {
            "use strict";
            n.d(t, {
                o: function() {
                    return s
                },
                $: function() {
                    return a
                }
            });
            var r = n(48488),
                i = n.n(r),
                o = {
                    now: 18e4,
                    hour: 36e5,
                    day: 864e5,
                    week: 6048e5,
                    year: 314496e5
                };

            function s(e) {
                var t = new Date(e);
                return d(c(t), h, l, u.fullDate)(t)
            }

            function a(e) {
                var t, n, r, i, s = new Date(e),
                    a = s.getTime(),
                    c = [{
                        key: g(new Date),
                        val: f
                    }, {
                        key: (r = (new Date).getTime(), i = r - o.day, g(new Date(i))),
                        val: u.displayYesterday
                    }, {
                        key: (t = (new Date).getFullYear(), n = new Date(t, 0, 1), n.getTime()),
                        val: u.displayYearTime
                    }];
                return d(a, p, c, u.fullDateAndTime)(s)
            }

            function c(e) {
                var t = e.getTime();
                return (new Date).getTime() - t
            }
            var u = {
                    fullDate: function(e) {
                        return m(e)
                    },
                    now: function() {
                        return "now"
                    },
                    xMinsAgo: function(e) {
                        var t = c(e);
                        return Math.floor((t + 37) / 6e4) + " min"
                    },
                    today: function(e) {
                        return function(e) {
                            return e.getDay() === (new Date).getDay()
                        }(e) ? f(e) : "Yesterday"
                    },
                    thisWeek: function(e) {
                        return function(e) {
                            return e.getDay() === (new Date).getDay() - 1
                        }(e) ? "Yesterday" : function(e) {
                            return i()(e).format("ddd")
                        }(e)
                    },
                    thisYear: function(e) {
                        return function(e) {
                            return e.getFullYear() === (new Date).getFullYear()
                        }(e) ? function(e) {
                            return i()(e).format("MMM D")
                        }(e) : m(e)
                    },
                    displayYesterday: function(e) {
                        return i()(e).calendar()
                    },
                    displayYearTime: function(e) {
                        return i()(e).format("MMM D[, ]LT")
                    },
                    fullDateAndTime: function(e) {
                        return i()(e).format("l[, ]LT")
                    }
                },
                l = [{
                    key: o.now,
                    val: u.now
                }, {
                    key: o.hour,
                    val: u.xMinsAgo
                }, {
                    key: o.day,
                    val: u.today
                }, {
                    key: o.week,
                    val: u.thisWeek
                }, {
                    key: o.year,
                    val: u.thisYear
                }];

            function d(e, t, n, r) {
                for (var i = n.length, o = 0; o < i; o++) {
                    if (t(e, n[o].key)) return n[o].val
                }
                return r
            }
            var h = function(e, t) {
                    return e < t
                },
                p = function(e, t) {
                    return e > t
                };

            function f(e) {
                return i()(e).format("LT")
            }

            function m(e) {
                return i()(e).format("l")
            }

            function g(e) {
                var t = e.getFullYear(),
                    n = e.getMonth(),
                    r = e.getDate();
                return new Date(t, n, r).getTime()
            }
        },
        99779: function(e, t, n) {
            e.exports = n(93212)
        },
        62399: function(e, t, n) {
            "use strict";
            var r = n(5023),
                i = n(66399),
                o = n(35590),
                s = n(30332),
                a = n(45169),
                c = n(18709),
                u = n(17492),
                l = n(1941);
            e.exports = function(e) {
                return new Promise((function(t, n) {
                    var d = e.data,
                        h = e.headers,
                        p = e.responseType;
                    r.isFormData(d) && delete h["Content-Type"];
                    var f = new XMLHttpRequest;
                    if (e.auth) {
                        var m = e.auth.username || "",
                            g = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                        h.Authorization = "Basic " + btoa(m + ":" + g)
                    }
                    var _ = a(e.baseURL, e.url);

                    function v() {
                        if (f) {
                            var r = "getAllResponseHeaders" in f ? c(f.getAllResponseHeaders()) : null,
                                o = {
                                    data: p && "text" !== p && "json" !== p ? f.response : f.responseText,
                                    status: f.status,
                                    statusText: f.statusText,
                                    headers: r,
                                    config: e,
                                    request: f
                                };
                            i(t, n, o), f = null
                        }
                    }
                    if (f.open(e.method.toUpperCase(), s(_, e.params, e.paramsSerializer), !0), f.timeout = e.timeout, "onloadend" in f ? f.onloadend = v : f.onreadystatechange = function() {
                            f && 4 === f.readyState && (0 !== f.status || f.responseURL && 0 === f.responseURL.indexOf("file:")) && setTimeout(v)
                        }, f.onabort = function() {
                            f && (n(l("Request aborted", e, "ECONNABORTED", f)), f = null)
                        }, f.onerror = function() {
                            n(l("Network Error", e, null, f)), f = null
                        }, f.ontimeout = function() {
                            var t = "timeout of " + e.timeout + "ms exceeded";
                            e.timeoutErrorMessage && (t = e.timeoutErrorMessage), n(l(t, e, e.transitional && e.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", f)), f = null
                        }, r.isStandardBrowserEnv()) {
                        var y = (e.withCredentials || u(_)) && e.xsrfCookieName ? o.read(e.xsrfCookieName) : void 0;
                        y && (h[e.xsrfHeaderName] = y)
                    }
                    "setRequestHeader" in f && r.forEach(h, (function(e, t) {
                        void 0 === d && "content-type" === t.toLowerCase() ? delete h[t] : f.setRequestHeader(t, e)
                    })), r.isUndefined(e.withCredentials) || (f.withCredentials = !!e.withCredentials), p && "json" !== p && (f.responseType = e.responseType), "function" == typeof e.onDownloadProgress && f.addEventListener("progress", e.onDownloadProgress), "function" == typeof e.onUploadProgress && f.upload && f.upload.addEventListener("progress", e.onUploadProgress), e.cancelToken && e.cancelToken.promise.then((function(e) {
                        f && (f.abort(), n(e), f = null)
                    })), d || (d = null), f.send(d)
                }))
            }
        },
        93212: function(e, t, n) {
            "use strict";
            var r = n(5023),
                i = n(44979),
                o = n(3992),
                s = n(85723);

            function a(e) {
                var t = new o(e),
                    n = i(o.prototype.request, t);
                return r.extend(n, o.prototype, t), r.extend(n, t), n
            }
            var c = a(n(50991));
            c.Axios = o, c.create = function(e) {
                return a(s(c.defaults, e))
            }, c.Cancel = n(20255), c.CancelToken = n(59098), c.isCancel = n(43525), c.all = function(e) {
                return Promise.all(e)
            }, c.spread = n(29490), c.isAxiosError = n(91646), e.exports = c, e.exports.default = c
        },
        20255: function(e) {
            "use strict";

            function t(e) {
                this.message = e
            }
            t.prototype.toString = function() {
                return "Cancel" + (this.message ? ": " + this.message : "")
            }, t.prototype.__CANCEL__ = !0, e.exports = t
        },
        59098: function(e, t, n) {
            "use strict";
            var r = n(20255);

            function i(e) {
                if ("function" != typeof e) throw new TypeError("executor must be a function.");
                var t;
                this.promise = new Promise((function(e) {
                    t = e
                }));
                var n = this;
                e((function(e) {
                    n.reason || (n.reason = new r(e), t(n.reason))
                }))
            }
            i.prototype.throwIfRequested = function() {
                if (this.reason) throw this.reason
            }, i.source = function() {
                var e;
                return {
                    token: new i((function(t) {
                        e = t
                    })),
                    cancel: e
                }
            }, e.exports = i
        },
        43525: function(e) {
            "use strict";
            e.exports = function(e) {
                return !(!e || !e.__CANCEL__)
            }
        },
        3992: function(e, t, n) {
            "use strict";
            var r = n(5023),
                i = n(30332),
                o = n(71004),
                s = n(98241),
                a = n(85723),
                c = n(7058),
                u = c.validators;

            function l(e) {
                this.defaults = e, this.interceptors = {
                    request: new o,
                    response: new o
                }
            }
            l.prototype.request = function(e) {
                "string" == typeof e ? (e = arguments[1] || {}).url = arguments[0] : e = e || {}, (e = a(this.defaults, e)).method ? e.method = e.method.toLowerCase() : this.defaults.method ? e.method = this.defaults.method.toLowerCase() : e.method = "get";
                var t = e.transitional;
                void 0 !== t && c.assertOptions(t, {
                    silentJSONParsing: u.transitional(u.boolean, "1.0.0"),
                    forcedJSONParsing: u.transitional(u.boolean, "1.0.0"),
                    clarifyTimeoutError: u.transitional(u.boolean, "1.0.0")
                }, !1);
                var n = [],
                    r = !0;
                this.interceptors.request.forEach((function(t) {
                    "function" == typeof t.runWhen && !1 === t.runWhen(e) || (r = r && t.synchronous, n.unshift(t.fulfilled, t.rejected))
                }));
                var i, o = [];
                if (this.interceptors.response.forEach((function(e) {
                        o.push(e.fulfilled, e.rejected)
                    })), !r) {
                    var l = [s, void 0];
                    for (Array.prototype.unshift.apply(l, n), l = l.concat(o), i = Promise.resolve(e); l.length;) i = i.then(l.shift(), l.shift());
                    return i
                }
                for (var d = e; n.length;) {
                    var h = n.shift(),
                        p = n.shift();
                    try {
                        d = h(d)
                    } catch (e) {
                        p(e);
                        break
                    }
                }
                try {
                    i = s(d)
                } catch (e) {
                    return Promise.reject(e)
                }
                for (; o.length;) i = i.then(o.shift(), o.shift());
                return i
            }, l.prototype.getUri = function(e) {
                return e = a(this.defaults, e), i(e.url, e.params, e.paramsSerializer).replace(/^\?/, "")
            }, r.forEach(["delete", "get", "head", "options"], (function(e) {
                l.prototype[e] = function(t, n) {
                    return this.request(a(n || {}, {
                        method: e,
                        url: t,
                        data: (n || {}).data
                    }))
                }
            })), r.forEach(["post", "put", "patch"], (function(e) {
                l.prototype[e] = function(t, n, r) {
                    return this.request(a(r || {}, {
                        method: e,
                        url: t,
                        data: n
                    }))
                }
            })), e.exports = l
        },
        71004: function(e, t, n) {
            "use strict";
            var r = n(5023);

            function i() {
                this.handlers = []
            }
            i.prototype.use = function(e, t, n) {
                return this.handlers.push({
                    fulfilled: e,
                    rejected: t,
                    synchronous: !!n && n.synchronous,
                    runWhen: n ? n.runWhen : null
                }), this.handlers.length - 1
            }, i.prototype.eject = function(e) {
                this.handlers[e] && (this.handlers[e] = null)
            }, i.prototype.forEach = function(e) {
                r.forEach(this.handlers, (function(t) {
                    null !== t && e(t)
                }))
            }, e.exports = i
        },
        45169: function(e, t, n) {
            "use strict";
            var r = n(45021),
                i = n(25114);
            e.exports = function(e, t) {
                return e && !r(t) ? i(e, t) : t
            }
        },
        1941: function(e, t, n) {
            "use strict";
            var r = n(64553);
            e.exports = function(e, t, n, i, o) {
                var s = new Error(e);
                return r(s, t, n, i, o)
            }
        },
        98241: function(e, t, n) {
            "use strict";
            var r = n(5023),
                i = n(91991),
                o = n(43525),
                s = n(50991);

            function a(e) {
                e.cancelToken && e.cancelToken.throwIfRequested()
            }
            e.exports = function(e) {
                return a(e), e.headers = e.headers || {}, e.data = i.call(e, e.data, e.headers, e.transformRequest), e.headers = r.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), r.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (function(t) {
                    delete e.headers[t]
                })), (e.adapter || s.adapter)(e).then((function(t) {
                    return a(e), t.data = i.call(e, t.data, t.headers, e.transformResponse), t
                }), (function(t) {
                    return o(t) || (a(e), t && t.response && (t.response.data = i.call(e, t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t)
                }))
            }
        },
        64553: function(e) {
            "use strict";
            e.exports = function(e, t, n, r, i) {
                return e.config = t, n && (e.code = n), e.request = r, e.response = i, e.isAxiosError = !0, e.toJSON = function() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: this.config,
                        code: this.code
                    }
                }, e
            }
        },
        85723: function(e, t, n) {
            "use strict";
            var r = n(5023);
            e.exports = function(e, t) {
                t = t || {};
                var n = {},
                    i = ["url", "method", "data"],
                    o = ["headers", "auth", "proxy", "params"],
                    s = ["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "timeoutMessage", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "decompress", "maxContentLength", "maxBodyLength", "maxRedirects", "transport", "httpAgent", "httpsAgent", "cancelToken", "socketPath", "responseEncoding"],
                    a = ["validateStatus"];

                function c(e, t) {
                    return r.isPlainObject(e) && r.isPlainObject(t) ? r.merge(e, t) : r.isPlainObject(t) ? r.merge({}, t) : r.isArray(t) ? t.slice() : t
                }

                function u(i) {
                    r.isUndefined(t[i]) ? r.isUndefined(e[i]) || (n[i] = c(void 0, e[i])) : n[i] = c(e[i], t[i])
                }
                r.forEach(i, (function(e) {
                    r.isUndefined(t[e]) || (n[e] = c(void 0, t[e]))
                })), r.forEach(o, u), r.forEach(s, (function(i) {
                    r.isUndefined(t[i]) ? r.isUndefined(e[i]) || (n[i] = c(void 0, e[i])) : n[i] = c(void 0, t[i])
                })), r.forEach(a, (function(r) {
                    r in t ? n[r] = c(e[r], t[r]) : r in e && (n[r] = c(void 0, e[r]))
                }));
                var l = i.concat(o).concat(s).concat(a),
                    d = Object.keys(e).concat(Object.keys(t)).filter((function(e) {
                        return -1 === l.indexOf(e)
                    }));
                return r.forEach(d, u), n
            }
        },
        66399: function(e, t, n) {
            "use strict";
            var r = n(1941);
            e.exports = function(e, t, n) {
                var i = n.config.validateStatus;
                n.status && i && !i(n.status) ? t(r("Request failed with status code " + n.status, n.config, null, n.request, n)) : e(n)
            }
        },
        91991: function(e, t, n) {
            "use strict";
            var r = n(5023),
                i = n(50991);
            e.exports = function(e, t, n) {
                var o = this || i;
                return r.forEach(n, (function(n) {
                    e = n.call(o, e, t)
                })), e
            }
        },
        50991: function(e, t, n) {
            "use strict";
            var r = n(13158),
                i = n(5023),
                o = n(21631),
                s = n(64553),
                a = {
                    "Content-Type": "application/x-www-form-urlencoded"
                };

            function c(e, t) {
                !i.isUndefined(e) && i.isUndefined(e["Content-Type"]) && (e["Content-Type"] = t)
            }
            var u, l = {
                transitional: {
                    silentJSONParsing: !0,
                    forcedJSONParsing: !0,
                    clarifyTimeoutError: !1
                },
                adapter: (("undefined" != typeof XMLHttpRequest || void 0 !== r && "[object process]" === Object.prototype.toString.call(r)) && (u = n(62399)), u),
                transformRequest: [function(e, t) {
                    return o(t, "Accept"), o(t, "Content-Type"), i.isFormData(e) || i.isArrayBuffer(e) || i.isBuffer(e) || i.isStream(e) || i.isFile(e) || i.isBlob(e) ? e : i.isArrayBufferView(e) ? e.buffer : i.isURLSearchParams(e) ? (c(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : i.isObject(e) || t && "application/json" === t["Content-Type"] ? (c(t, "application/json"), function(e, t, n) {
                        if (i.isString(e)) try {
                            return (t || JSON.parse)(e), i.trim(e)
                        } catch (e) {
                            if ("SyntaxError" !== e.name) throw e
                        }
                        return (n || JSON.stringify)(e)
                    }(e)) : e
                }],
                transformResponse: [function(e) {
                    var t = this.transitional,
                        n = t && t.silentJSONParsing,
                        r = t && t.forcedJSONParsing,
                        o = !n && "json" === this.responseType;
                    if (o || r && i.isString(e) && e.length) try {
                        return JSON.parse(e)
                    } catch (e) {
                        if (o) {
                            if ("SyntaxError" === e.name) throw s(e, this, "E_JSON_PARSE");
                            throw e
                        }
                    }
                    return e
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                validateStatus: function(e) {
                    return e >= 200 && e < 300
                }
            };
            l.headers = {
                common: {
                    Accept: "application/json, text/plain, */*"
                }
            }, i.forEach(["delete", "get", "head"], (function(e) {
                l.headers[e] = {}
            })), i.forEach(["post", "put", "patch"], (function(e) {
                l.headers[e] = i.merge(a)
            })), e.exports = l
        },
        44979: function(e) {
            "use strict";
            e.exports = function(e, t) {
                return function() {
                    for (var n = new Array(arguments.length), r = 0; r < n.length; r++) n[r] = arguments[r];
                    return e.apply(t, n)
                }
            }
        },
        30332: function(e, t, n) {
            "use strict";
            var r = n(5023);

            function i(e) {
                return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }
            e.exports = function(e, t, n) {
                if (!t) return e;
                var o;
                if (n) o = n(t);
                else if (r.isURLSearchParams(t)) o = t.toString();
                else {
                    var s = [];
                    r.forEach(t, (function(e, t) {
                        null != e && (r.isArray(e) ? t += "[]" : e = [e], r.forEach(e, (function(e) {
                            r.isDate(e) ? e = e.toISOString() : r.isObject(e) && (e = JSON.stringify(e)), s.push(i(t) + "=" + i(e))
                        })))
                    })), o = s.join("&")
                }
                if (o) {
                    var a = e.indexOf("#"); - 1 !== a && (e = e.slice(0, a)), e += (-1 === e.indexOf("?") ? "?" : "&") + o
                }
                return e
            }
        },
        25114: function(e) {
            "use strict";
            e.exports = function(e, t) {
                return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e
            }
        },
        35590: function(e, t, n) {
            "use strict";
            var r = n(5023);
            e.exports = r.isStandardBrowserEnv() ? {
                write: function(e, t, n, i, o, s) {
                    var a = [];
                    a.push(e + "=" + encodeURIComponent(t)), r.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), r.isString(i) && a.push("path=" + i), r.isString(o) && a.push("domain=" + o), !0 === s && a.push("secure"), document.cookie = a.join("; ")
                },
                read: function(e) {
                    var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                    return t ? decodeURIComponent(t[3]) : null
                },
                remove: function(e) {
                    this.write(e, "", Date.now() - 864e5)
                }
            } : {
                write: function() {},
                read: function() {
                    return null
                },
                remove: function() {}
            }
        },
        45021: function(e) {
            "use strict";
            e.exports = function(e) {
                return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)
            }
        },
        91646: function(e) {
            "use strict";
            e.exports = function(e) {
                return "object" == typeof e && !0 === e.isAxiosError
            }
        },
        17492: function(e, t, n) {
            "use strict";
            var r = n(5023);
            e.exports = r.isStandardBrowserEnv() ? function() {
                var e, t = /(msie|trident)/i.test(navigator.userAgent),
                    n = document.createElement("a");

                function i(e) {
                    var r = e;
                    return t && (n.setAttribute("href", r), r = n.href), n.setAttribute("href", r), {
                        href: n.href,
                        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
                        host: n.host,
                        search: n.search ? n.search.replace(/^\?/, "") : "",
                        hash: n.hash ? n.hash.replace(/^#/, "") : "",
                        hostname: n.hostname,
                        port: n.port,
                        pathname: "/" === n.pathname.charAt(0) ? n.pathname : "/" + n.pathname
                    }
                }
                return e = i(window.location.href),
                    function(t) {
                        var n = r.isString(t) ? i(t) : t;
                        return n.protocol === e.protocol && n.host === e.host
                    }
            }() : function() {
                return !0
            }
        },
        21631: function(e, t, n) {
            "use strict";
            var r = n(5023);
            e.exports = function(e, t) {
                r.forEach(e, (function(n, r) {
                    r !== t && r.toUpperCase() === t.toUpperCase() && (e[t] = n, delete e[r])
                }))
            }
        },
        18709: function(e, t, n) {
            "use strict";
            var r = n(5023),
                i = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
            e.exports = function(e) {
                var t, n, o, s = {};
                return e ? (r.forEach(e.split("\n"), (function(e) {
                    if (o = e.indexOf(":"), t = r.trim(e.substr(0, o)).toLowerCase(), n = r.trim(e.substr(o + 1)), t) {
                        if (s[t] && i.indexOf(t) >= 0) return;
                        s[t] = "set-cookie" === t ? (s[t] ? s[t] : []).concat([n]) : s[t] ? s[t] + ", " + n : n
                    }
                })), s) : s
            }
        },
        29490: function(e) {
            "use strict";
            e.exports = function(e) {
                return function(t) {
                    return e.apply(null, t)
                }
            }
        },
        7058: function(e, t, n) {
            "use strict";
            var r = n(78609),
                i = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach((function(e, t) {
                i[e] = function(n) {
                    return typeof n === e || "a" + (t < 1 ? "n " : " ") + e
                }
            }));
            var o = {},
                s = r.version.split(".");

            function a(e, t) {
                for (var n = t ? t.split(".") : s, r = e.split("."), i = 0; i < 3; i++) {
                    if (n[i] > r[i]) return !0;
                    if (n[i] < r[i]) return !1
                }
                return !1
            }
            i.transitional = function(e, t, n) {
                var i = t && a(t);

                function s(e, t) {
                    return "[Axios v" + r.version + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "")
                }
                return function(n, r, a) {
                    if (!1 === e) throw new Error(s(r, " has been removed in " + t));
                    return i && !o[r] && (o[r] = !0, console.warn(s(r, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, r, a)
                }
            }, e.exports = {
                isOlderVersion: a,
                assertOptions: function(e, t, n) {
                    if ("object" != typeof e) throw new TypeError("options must be an object");
                    for (var r = Object.keys(e), i = r.length; i-- > 0;) {
                        var o = r[i],
                            s = t[o];
                        if (s) {
                            var a = e[o],
                                c = void 0 === a || s(a, o, e);
                            if (!0 !== c) throw new TypeError("option " + o + " must be " + c)
                        } else if (!0 !== n) throw Error("Unknown option " + o)
                    }
                },
                validators: i
            }
        },
        5023: function(e, t, n) {
            "use strict";
            var r = n(44979),
                i = Object.prototype.toString;

            function o(e) {
                return "[object Array]" === i.call(e)
            }

            function s(e) {
                return void 0 === e
            }

            function a(e) {
                return null !== e && "object" == typeof e
            }

            function c(e) {
                if ("[object Object]" !== i.call(e)) return !1;
                var t = Object.getPrototypeOf(e);
                return null === t || t === Object.prototype
            }

            function u(e) {
                return "[object Function]" === i.call(e)
            }

            function l(e, t) {
                if (null != e)
                    if ("object" != typeof e && (e = [e]), o(e))
                        for (var n = 0, r = e.length; n < r; n++) t.call(null, e[n], n, e);
                    else
                        for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.call(null, e[i], i, e)
            }
            e.exports = {
                isArray: o,
                isArrayBuffer: function(e) {
                    return "[object ArrayBuffer]" === i.call(e)
                },
                isBuffer: function(e) {
                    return null !== e && !s(e) && null !== e.constructor && !s(e.constructor) && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
                },
                isFormData: function(e) {
                    return "undefined" != typeof FormData && e instanceof FormData
                },
                isArrayBufferView: function(e) {
                    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && e.buffer instanceof ArrayBuffer
                },
                isString: function(e) {
                    return "string" == typeof e
                },
                isNumber: function(e) {
                    return "number" == typeof e
                },
                isObject: a,
                isPlainObject: c,
                isUndefined: s,
                isDate: function(e) {
                    return "[object Date]" === i.call(e)
                },
                isFile: function(e) {
                    return "[object File]" === i.call(e)
                },
                isBlob: function(e) {
                    return "[object Blob]" === i.call(e)
                },
                isFunction: u,
                isStream: function(e) {
                    return a(e) && u(e.pipe)
                },
                isURLSearchParams: function(e) {
                    return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams
                },
                isStandardBrowserEnv: function() {
                    return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && ("undefined" != typeof window && "undefined" != typeof document)
                },
                forEach: l,
                merge: function e() {
                    var t = {};

                    function n(n, r) {
                        c(t[r]) && c(n) ? t[r] = e(t[r], n) : c(n) ? t[r] = e({}, n) : o(n) ? t[r] = n.slice() : t[r] = n
                    }
                    for (var r = 0, i = arguments.length; r < i; r++) l(arguments[r], n);
                    return t
                },
                extend: function(e, t, n) {
                    return l(t, (function(t, i) {
                        e[i] = n && "function" == typeof t ? r(t, n) : t
                    })), e
                },
                trim: function(e) {
                    return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                },
                stripBOM: function(e) {
                    return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e
                }
            }
        },
        50377: function(e, t) {
            "use strict";

            function n(e) {
                return function(t) {
                    var n = t.dispatch,
                        r = t.getState;
                    return function(t) {
                        return function(i) {
                            return "function" == typeof i ? i(n, r, e) : t(i)
                        }
                    }
                }
            }
            var r = n();
            r.withExtraArgument = n, t.Z = r
        },
        19653: function(e) {
            for (var t = [], n = 0; n < 256; ++n) t[n] = (n + 256).toString(16).substr(1);
            e.exports = function(e, n) {
                var r = n || 0,
                    i = t;
                return [i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], "-", i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]], i[e[r++]]].join("")
            }
        },
        3537: function(e) {
            var t = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
            if (t) {
                var n = new Uint8Array(16);
                e.exports = function() {
                    return t(n), n
                }
            } else {
                var r = new Array(16);
                e.exports = function() {
                    for (var e, t = 0; t < 16; t++) 0 == (3 & t) && (e = 4294967296 * Math.random()), r[t] = e >>> ((3 & t) << 3) & 255;
                    return r
                }
            }
        },
        31454: function(e, t, n) {
            var r = n(3537),
                i = n(19653);
            e.exports = function(e, t, n) {
                var o = t && n || 0;
                "string" == typeof e && (t = "binary" === e ? new Array(16) : null, e = null);
                var s = (e = e || {}).random || (e.rng || r)();
                if (s[6] = 15 & s[6] | 64, s[8] = 63 & s[8] | 128, t)
                    for (var a = 0; a < 16; ++a) t[o + a] = s[a];
                return t || i(s)
            }
        },
        6659: function(e) {
            "use strict";
            var t = Object.prototype.hasOwnProperty,
                n = "~";

            function r() {}

            function i(e, t, n) {
                this.fn = e, this.context = t, this.once = n || !1
            }

            function o() {
                this._events = new r, this._eventsCount = 0
            }
            Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), o.prototype.eventNames = function() {
                var e, r, i = [];
                if (0 === this._eventsCount) return i;
                for (r in e = this._events) t.call(e, r) && i.push(n ? r.slice(1) : r);
                return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
            }, o.prototype.listeners = function(e, t) {
                var r = n ? n + e : e,
                    i = this._events[r];
                if (t) return !!i;
                if (!i) return [];
                if (i.fn) return [i.fn];
                for (var o = 0, s = i.length, a = new Array(s); o < s; o++) a[o] = i[o].fn;
                return a
            }, o.prototype.emit = function(e, t, r, i, o, s) {
                var a = n ? n + e : e;
                if (!this._events[a]) return !1;
                var c, u, l = this._events[a],
                    d = arguments.length;
                if (l.fn) {
                    switch (l.once && this.removeListener(e, l.fn, void 0, !0), d) {
                        case 1:
                            return l.fn.call(l.context), !0;
                        case 2:
                            return l.fn.call(l.context, t), !0;
                        case 3:
                            return l.fn.call(l.context, t, r), !0;
                        case 4:
                            return l.fn.call(l.context, t, r, i), !0;
                        case 5:
                            return l.fn.call(l.context, t, r, i, o), !0;
                        case 6:
                            return l.fn.call(l.context, t, r, i, o, s), !0
                    }
                    for (u = 1, c = new Array(d - 1); u < d; u++) c[u - 1] = arguments[u];
                    l.fn.apply(l.context, c)
                } else {
                    var h, p = l.length;
                    for (u = 0; u < p; u++) switch (l[u].once && this.removeListener(e, l[u].fn, void 0, !0), d) {
                        case 1:
                            l[u].fn.call(l[u].context);
                            break;
                        case 2:
                            l[u].fn.call(l[u].context, t);
                            break;
                        case 3:
                            l[u].fn.call(l[u].context, t, r);
                            break;
                        case 4:
                            l[u].fn.call(l[u].context, t, r, i);
                            break;
                        default:
                            if (!c)
                                for (h = 1, c = new Array(d - 1); h < d; h++) c[h - 1] = arguments[h];
                            l[u].fn.apply(l[u].context, c)
                    }
                }
                return !0
            }, o.prototype.on = function(e, t, r) {
                var o = new i(t, r || this),
                    s = n ? n + e : e;
                return this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], o] : this._events[s].push(o) : (this._events[s] = o, this._eventsCount++), this
            }, o.prototype.once = function(e, t, r) {
                var o = new i(t, r || this, !0),
                    s = n ? n + e : e;
                return this._events[s] ? this._events[s].fn ? this._events[s] = [this._events[s], o] : this._events[s].push(o) : (this._events[s] = o, this._eventsCount++), this
            }, o.prototype.removeListener = function(e, t, i, o) {
                var s = n ? n + e : e;
                if (!this._events[s]) return this;
                if (!t) return 0 == --this._eventsCount ? this._events = new r : delete this._events[s], this;
                var a = this._events[s];
                if (a.fn) a.fn !== t || o && !a.once || i && a.context !== i || (0 == --this._eventsCount ? this._events = new r : delete this._events[s]);
                else {
                    for (var c = 0, u = [], l = a.length; c < l; c++)(a[c].fn !== t || o && !a[c].once || i && a[c].context !== i) && u.push(a[c]);
                    u.length ? this._events[s] = 1 === u.length ? u[0] : u : 0 == --this._eventsCount ? this._events = new r : delete this._events[s]
                }
                return this
            }, o.prototype.removeAllListeners = function(e) {
                var t;
                return e ? (t = n ? n + e : e, this._events[t] && (0 == --this._eventsCount ? this._events = new r : delete this._events[t])) : (this._events = new r, this._eventsCount = 0), this
            }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prototype.setMaxListeners = function() {
                return this
            }, o.prefixed = n, o.EventEmitter = o, e.exports = o
        },
        45503: function() {},
        50799: function(e, t, n) {
            "use strict";
            n.r(t), n.d(t, {
                deleteDB: function() {
                    return _
                },
                openDB: function() {
                    return g
                },
                unwrap: function() {
                    return m
                },
                wrap: function() {
                    return f
                }
            });
            const r = (e, t) => t.some((t => e instanceof t));
            let i, o;
            const s = new WeakMap,
                a = new WeakMap,
                c = new WeakMap,
                u = new WeakMap,
                l = new WeakMap;
            let d = {
                get(e, t, n) {
                    if (e instanceof IDBTransaction) {
                        if ("done" === t) return a.get(e);
                        if ("objectStoreNames" === t) return e.objectStoreNames || c.get(e);
                        if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
                    }
                    return f(e[t])
                },
                set: (e, t, n) => (e[t] = n, !0),
                has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e
            };

            function h(e) {
                return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (o || (o = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function(...t) {
                    return e.apply(m(this), t), f(s.get(this))
                } : function(...t) {
                    return f(e.apply(m(this), t))
                } : function(t, ...n) {
                    const r = e.call(m(this), t, ...n);
                    return c.set(r, t.sort ? t.sort() : [t]), f(r)
                }
            }

            function p(e) {
                return "function" == typeof e ? h(e) : (e instanceof IDBTransaction && function(e) {
                    if (a.has(e)) return;
                    const t = new Promise(((t, n) => {
                        const r = () => {
                                e.removeEventListener("complete", i), e.removeEventListener("error", o), e.removeEventListener("abort", o)
                            },
                            i = () => {
                                t(), r()
                            },
                            o = () => {
                                n(e.error || new DOMException("AbortError", "AbortError")), r()
                            };
                        e.addEventListener("complete", i), e.addEventListener("error", o), e.addEventListener("abort", o)
                    }));
                    a.set(e, t)
                }(e), r(e, i || (i = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])) ? new Proxy(e, d) : e)
            }

            function f(e) {
                if (e instanceof IDBRequest) return function(e) {
                    const t = new Promise(((t, n) => {
                        const r = () => {
                                e.removeEventListener("success", i), e.removeEventListener("error", o)
                            },
                            i = () => {
                                t(f(e.result)), r()
                            },
                            o = () => {
                                n(e.error), r()
                            };
                        e.addEventListener("success", i), e.addEventListener("error", o)
                    }));
                    return t.then((t => {
                        t instanceof IDBCursor && s.set(t, e)
                    })).catch((() => {})), l.set(t, e), t
                }(e);
                if (u.has(e)) return u.get(e);
                const t = p(e);
                return t !== e && (u.set(e, t), l.set(t, e)), t
            }
            const m = e => l.get(e);

            function g(e, t, {
                blocked: n,
                upgrade: r,
                blocking: i,
                terminated: o
            } = {}) {
                const s = indexedDB.open(e, t),
                    a = f(s);
                return r && s.addEventListener("upgradeneeded", (e => {
                    r(f(s.result), e.oldVersion, e.newVersion, f(s.transaction), e)
                })), n && s.addEventListener("blocked", (e => n(e.oldVersion, e.newVersion, e))), a.then((e => {
                    o && e.addEventListener("close", (() => o())), i && e.addEventListener("versionchange", (e => i(e.oldVersion, e.newVersion, e)))
                })).catch((() => {})), a
            }

            function _(e, {
                blocked: t
            } = {}) {
                const n = indexedDB.deleteDatabase(e);
                return t && n.addEventListener("blocked", (e => t(e.oldVersion, e))), f(n).then((() => {}))
            }
            const v = ["get", "getKey", "getAll", "getAllKeys", "count"],
                y = ["put", "add", "delete", "clear"],
                b = new Map;

            function I(e, t) {
                if (!(e instanceof IDBDatabase) || t in e || "string" != typeof t) return;
                if (b.get(t)) return b.get(t);
                const n = t.replace(/FromIndex$/, ""),
                    r = t !== n,
                    i = y.includes(n);
                if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !i && !v.includes(n)) return;
                const o = async function(e, ...t) {
                    const o = this.transaction(e, i ? "readwrite" : "readonly");
                    let s = o.store;
                    return r && (s = s.index(t.shift())), (await Promise.all([s[n](...t), i && o.done]))[0]
                };
                return b.set(t, o), o
            }
            d = (e => ({ ...e,
                get: (t, n, r) => I(t, n) || e.get(t, n, r),
                has: (t, n) => !!I(t, n) || e.has(t, n)
            }))(d)
        },
        17612: function(e, t, n) {
            "use strict";
            n.d(t, {
                Z: function() {
                    return E
                }
            });
            var r = "object" == typeof global && global && global.Object === Object && global,
                i = "object" == typeof self && self && self.Object === Object && self,
                o = (r || i || Function("return this")()).Symbol,
                s = Object.prototype,
                a = s.hasOwnProperty,
                c = s.toString,
                u = o ? o.toStringTag : void 0;
            var l = function(e) {
                    var t = a.call(e, u),
                        n = e[u];
                    try {
                        e[u] = void 0;
                        var r = !0
                    } catch (e) {}
                    var i = c.call(e);
                    return r && (t ? e[u] = n : delete e[u]), i
                },
                d = Object.prototype.toString;
            var h = function(e) {
                    return d.call(e)
                },
                p = o ? o.toStringTag : void 0;
            var f = function(e) {
                return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : p && p in Object(e) ? l(e) : h(e)
            };
            var m = function(e, t) {
                return function(n) {
                    return e(t(n))
                }
            }(Object.getPrototypeOf, Object);
            var g = function(e) {
                    return null != e && "object" == typeof e
                },
                _ = Function.prototype,
                v = Object.prototype,
                y = _.toString,
                b = v.hasOwnProperty,
                I = y.call(Object);
            var E = function(e) {
                if (!g(e) || "[object Object]" != f(e)) return !1;
                var t = m(e);
                if (null === t) return !0;
                var n = b.call(t, "constructor") && t.constructor;
                return "function" == typeof n && n instanceof n && y.call(n) == I
            }
        },
        78609: function(e) {
            "use strict";
            e.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}')
        }
    }
]);
//# sourceMappingURL=chat-sdk.chunk.min.js.map